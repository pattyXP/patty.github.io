<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温暖的弦</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pattyxp.github.io/"/>
  <updated>2018-01-13T03:29:17.000Z</updated>
  <id>https://pattyxp.github.io/</id>
  
  <author>
    <name>Patty</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Objc对象的初始化</title>
    <link href="https://pattyxp.github.io/2018/01/12/Objc%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://pattyxp.github.io/2018/01/12/Objc对象的初始化/</id>
    <published>2018-01-12T06:13:13.000Z</published>
    <updated>2018-01-13T03:29:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文直接运行的是runtime Objc4-706版本，debug-objc的target，mac运行，在main.m文件添加code NSObject*obj=[[NSObject alloc]init];，打上断点一步步调试</p></blockquote><h2 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h2><p>先看下大致的流程<br><img src="/images/alloc流程图.png" alt="alloc流程"></p><p>断点首先进入 NSObject.mm中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br><span class="line">id</span><br><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone=false)</span><br><span class="line">&#123;</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil; //根据传参，此行不执行</span><br><span class="line"></span><br><span class="line">#if __OBJC2__</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">            bool dtor = cls-&gt;hasCxxDtor();</span><br><span class="line">            id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize());</span><br><span class="line">            if (slowpath(!obj)) return callBadAllocHandler(cls);</span><br><span class="line">            obj-&gt;initInstanceIsa(cls, dtor);</span><br><span class="line">            return obj;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行断点调试，发现最终调用class_createInstance<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">class_createInstance(Class cls, size_t extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    return _class_createInstanceFromZone(cls, extraBytes, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对象初始化中最重要的操作都在_class_createInstanceFromZone 方法中执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static __attribute__((always_inline))</span><br><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              bool cxxConstruct = true,</span><br><span class="line">                              size_t *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    if (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">        obj = (id)calloc(1, size);</span><br><span class="line">        if (!obj) return nil;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此，alloc方法执行完毕，所以重点就是分配了一块内存空间，初始化isa<br>在分配空间之前，需要先获取cls实例内存空间的大小，方法cls-&gt;instanceSize可以分析下</p><p>可见这是按照16字节对齐的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">       size_t size = alignedInstanceSize() + extraBytes;</span><br><span class="line">       // CF requires all objects be at least 16 bytes.</span><br><span class="line">       if (size &lt; 16) size = 16;</span><br><span class="line">       return size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Class&apos;s ivar size rounded up to a pointer-size boundary.</span><br><span class="line">uint32_t alignedInstanceSize() &#123;</span><br><span class="line">    return word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span><br><span class="line">    return (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// May be unaligned depending on class&apos;s ivars.</span><br><span class="line">uint32_t unalignedInstanceSize() &#123;</span><br><span class="line">    assert(isRealized());</span><br><span class="line">    return data()-&gt;ro-&gt;instanceSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拿到对象的大小之后，calloc分配空间，然后初始化对象的initIsa<br>obj-&gt;initInstanceIsa(cls, hasCxxDtor);进行对象的isa结构体初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    assert(hasCxxDtor == cls-&gt;hasCxxDtor());</span><br><span class="line"></span><br><span class="line">    initIsa(cls, true, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line">inline void</span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">        ...</span><br><span class="line">        isa_t newisa(0);</span><br><span class="line">        ...</span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">        isa = newisa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>可见init只是返回了当前的对象obj<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    return _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_objc_rootInit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    // In practice, it will be hard to rely on this function.</span><br><span class="line">    // Many classes do not properly chain -init calls.</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><pre><code>#define fastpath(x) (__builtin_expect(bool(x), 1))#define slowpath(x) (__builtin_expect(bool(x), 0))__builtin_expect的作用  这个指令是gcc引入的，作用是&quot;允许程序员将最有可能执行的分支告诉编译器&quot;。这个指令的写法为：__builtin_expect(EXP, N)。意思是：EXP==N的概率很大。一般的使用方法是将__builtin_expect指令封装为宏</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文内容还是比较简单的，对象的初始化，只是分配内存空间，初始化isa结构体，isa的初始化，可以查看另一篇文章<a href="_posts/isa的存在.md">isa的存在</a></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文直接运行的是runtime Objc4-706版本，debug-objc的target，mac运行，在main.m文件添加code NSObject*obj=[[NSObject alloc]init];，打上断点一步步调试&lt;/p&gt;
&lt;/blo
      
    
    </summary>
    
    
      <category term="源码分析" scheme="https://pattyxp.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>图片压缩算法</title>
    <link href="https://pattyxp.github.io/2018/01/11/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    <id>https://pattyxp.github.io/2018/01/11/图片压缩算法/</id>
    <published>2018-01-11T02:16:25.000Z</published>
    <updated>2018-01-11T02:43:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>压缩，可以拆分为压 和 缩</p><p>压，就是将图片的体积变小，图片的质量肯定下降<br>缩，就是将图片的尺寸变小，这样图片体积也会变小</p><p>有时候，需要上传图片到后台服务器，但是如单反照相机拍出来的图片轻则十几兆，一般服务器都会有一个图片压缩的上限，不可能接收很大的图片体积的，所以我们前端需要做处理。根据服务端能够接受的图片大小和图片体积，处理上传需要的最大图片质量。</p><p>因此可以先处理图片的尺寸，压缩到符合要求的尺寸之后，再看图片的大小是否还超过规定范围，超过的话再继续压缩体积</p><p>设计上可以设计为UIImage的分类，因为这是对图片的处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">static const float kMaxFileSize = xxx;</span><br><span class="line">static const float kMaxLayout = xxx;</span><br><span class="line"></span><br><span class="line">- (NSData *)imageCompressTargetPx:(NSInteger)targetPx maxFileSize:(uint64_t)maxFileSize &#123;</span><br><span class="line">    UIImage *newImage = nil;             // 尺寸压缩后的新图</span><br><span class="line">    BOOL drawImge = NO;                  // 是否需要重绘图片 默认是NO</span><br><span class="line"></span><br><span class="line">    CGFloat width = self.size.width;     // 源图片的宽</span><br><span class="line">    CGFloat height = self.size.height;   // 原图片的高</span><br><span class="line">    CGFloat scaledWidth = targetPx;      // 压缩时的宽度 默认是参照像素</span><br><span class="line">    CGFloat scaledHeight = targetPx;     // 压缩时的高度 默认是参照像素</span><br><span class="line"></span><br><span class="line">    if (maxFileSize &lt;= 0) &#123;</span><br><span class="line">        maxFileSize = kMaxFileSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //压缩指定尺寸</span><br><span class="line">    CGSize newSize = [self copressTargetLimitSize:self.size];</span><br><span class="line">    if (newSize.width != width ||newSize.height != height) &#123;</span><br><span class="line">        drawImge = YES;</span><br><span class="line">        scaledWidth = newSize.width;</span><br><span class="line">        scaledHeight = newSize.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果图片需要重绘 就按照新的宽高压缩重绘图片</span><br><span class="line">    if (drawImge == YES) &#123;</span><br><span class="line">        UIGraphicsBeginImageContext(CGSizeMake(scaledWidth, scaledHeight));</span><br><span class="line">        [self drawInRect:CGRectMake(0, 0, scaledWidth,scaledHeight)];</span><br><span class="line">        newImage =UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">        // 使当前的context出堆栈</span><br><span class="line">        UIGraphicsEndImageContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (newImage == nil) &#123;</span><br><span class="line">        newImage = self;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果图片大小大于要求大小,进行质量压缩</span><br><span class="line">    NSData * scaledImageData = nil;</span><br><span class="line">    if (UIImageJPEGRepresentation(newImage, 1) == nil) &#123;</span><br><span class="line">        scaledImageData = UIImagePNGRepresentation(newImage);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        scaledImageData = UIImageJPEGRepresentation(newImage, 1.0);</span><br><span class="line">        CGFloat scale = 0.9;</span><br><span class="line">        while(scaledImageData.length &gt;= maxFileSize)&#123;</span><br><span class="line">            scaledImageData = UIImageJPEGRepresentation(newImage, scale);</span><br><span class="line">            scale -= 0.1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return scaledImageData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -private</span><br><span class="line"></span><br><span class="line">- (CGSize)copressTargetLimitSize:(CGSize)originSize</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat width = originSize.width;     // 源图片的宽</span><br><span class="line">    CGFloat height = originSize.height;   // 原图片的高</span><br><span class="line">    BOOL drawImge = NO;                  // 是否需要重绘图片 默认是NO</span><br><span class="line">    CGFloat scaledWidth = kMaxLayout;      // 压缩时的宽度 默认是参照像素</span><br><span class="line">    CGFloat scaledHeight = kMaxLayout;     // 压缩时的高度 默认是参照像素</span><br><span class="line"></span><br><span class="line">    CGFloat targetPx = kMaxLayout;         // 压缩时的宽度 默认是参照像素</span><br><span class="line"></span><br><span class="line">    CGFloat max = MAX(width, height);</span><br><span class="line">    CGFloat min = MIN(width, height);</span><br><span class="line">    CGFloat factor = min/max;</span><br><span class="line"></span><br><span class="line">    if (width &lt;= 0 &amp;&amp; height &lt;= 0) &#123;</span><br><span class="line">        return originSize;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        drawImge = YES;</span><br><span class="line"></span><br><span class="line">        if (width &gt; height) &#123;</span><br><span class="line">            scaledWidth = targetPx;</span><br><span class="line">            scaledHeight = targetPx *factor;</span><br><span class="line">        &#125;else if (height &gt; width) &#123;</span><br><span class="line">            scaledHeight = targetPx;</span><br><span class="line">            scaledWidth = targetPx *factor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return CGSizeMake(scaledWidth, scaledHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;压缩，可以拆分为压 和 缩&lt;/p&gt;
&lt;p&gt;压，就是将图片的体积变小，图片的质量肯定下降&lt;br&gt;缩，就是将图片的尺寸变小，这样图片体积也会变小&lt;/p&gt;
&lt;p&gt;有时候，需要上传图片到后台服务器，但是如单反照相机拍出来的图片轻则十几兆，一般服务器都会有一个图片压缩的上限，不可能接
      
    
    </summary>
    
    
      <category term="原理" scheme="https://pattyxp.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>isa的存在</title>
    <link href="https://pattyxp.github.io/2018/01/10/isa%E7%9A%84%E5%AD%98%E5%9C%A8/"/>
    <id>https://pattyxp.github.io/2018/01/10/isa的存在/</id>
    <published>2018-01-10T06:20:40.000Z</published>
    <updated>2018-01-12T06:06:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><img src="/images/isa.png" alt="结构图"></p><p>在 Objective-C 中，对象的方法并没有存储于对象的结构体中（如果每一个对象都保存了自己能执行的方法，那么对内存的占用有极大的影响）。</p><p>当实例方法被调用时，它要通过自己持有的 isa 来查找对应的类，然后在这里的 class_data_bits_t 结构体中查找对应方法的实现。同时，每一个 objc_class 也有一个指向自己的父类的指针 super_class 用来查找继承的方法。</p><p>isa分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">union isa_t</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  isa_t() &#123; &#125;</span><br><span class="line">  isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  Class cls;</span><br><span class="line">  uintptr_t bits;</span><br><span class="line"></span><br><span class="line">  //如果是X86的结构，大致信息如下，还有arm_64这里就不贴了，大致字段差不多，多少有点差别</span><br><span class="line">  if __x86_64__  </span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</span><br><span class="line"></span><br><span class="line">    struct &#123;</span><br><span class="line">    uintptr_t nonpointer        : 1;</span><br><span class="line">    uintptr_t has_assoc         : 1;</span><br><span class="line">    uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">    uintptr_t shiftcls          : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000</span><br><span class="line">    uintptr_t magic             : 6;</span><br><span class="line">    uintptr_t weakly_referenced : 1;</span><br><span class="line">    uintptr_t deallocating      : 1;</span><br><span class="line">    uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">    uintptr_t extra_rc          : 8;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>union结构体 结构比较灵活，如下所示，一次只能容纳一件事，但是这个东西可能是一个int，一个浮点数等，这取决于你如何声明它。<br>isa_t、cls、 bits 还有结构体共用同一块地址空间，isa 总共会占据 64 位的内存空间（决定于其中的结构体）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef union MyUnion MYUNION;</span><br><span class="line">union MyUnion</span><br><span class="line">&#123;</span><br><span class="line">   int MyInt;</span><br><span class="line">   float MyFloat;</span><br><span class="line">&#125;;</span><br><span class="line">MyUnion将只包含一个int或一个浮点数，取决于你最近设置的。所以这样做：</span><br><span class="line"></span><br><span class="line">MYUNION u;</span><br><span class="line">u.MyInt = 10;</span><br><span class="line">你现在保持一个int等于10;</span><br><span class="line"></span><br><span class="line">u.MyFloat = 1.0;</span><br><span class="line">你现在拥有一个等于1.0的浮动。</span><br></pre></td></tr></table></figure></p><p>isa的内存结构图<br><img src="images/isa内存结构图.png" alt="isa结构图"></p><p>初始化<br>对于bits的设置可以在初始化中进行设置 objc-object.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    assert(hasCxxDtor == cls-&gt;hasCxxDtor());</span><br><span class="line"></span><br><span class="line">    initIsa(cls, true, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void</span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line"></span><br><span class="line">    if (!nonpointer) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        assert(!DisableNonpointerIsa);</span><br><span class="line">        assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line"></span><br><span class="line">        isa_t newisa(0);</span><br><span class="line"></span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">        assert(cls-&gt;classArrayIndex() &gt; 0);</span><br><span class="line">        newisa.bits = ISA_INDEX_MAGIC_VALUE; //赋值0x001d800000000001ULL</span><br><span class="line">        // isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        // isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();</span><br><span class="line">#else</span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        // isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        // isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        // This write must be performed in a single store in some cases</span><br><span class="line">        // (for example when realizing a class because other threads</span><br><span class="line">        // may simultaneously try to use the class).</span><br><span class="line">        // fixme use atomics here to guarantee single-store and to</span><br><span class="line">        // guarantee memory order w.r.t. the class index table</span><br><span class="line">        // ...but not too atomic because we don&apos;t want to hurt instantiation</span><br><span class="line">        isa = newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>newisa.bits = ISA_INDEX_MAGIC_VALUE; //赋值0x001d800000000001ULL则对应的64位显示的值如下图<br><img src="/images/isa赋值.png" alt="isa赋值后"></p><p>从图中了解到，在使用 ISA_MAGIC_VALUE 设置 isa_t 结构体之后，实际上只是设置了 indexed 以及 magic 这两部分的值。</p><ul><li>indexed 表示 isa_t 的类型<ul><li>0 表示 raw isa，也就是没有结构体的部分，访问对象的 isa 会直接返回一个指向 cls 的指针，也就是在 iPhone 迁移到 64 位系统之前时 isa 的类型。</li><li>1 表示当前 isa 不是指针，但是其中也有 cls 的信息，只是其中关于类的指针都是保存在 shiftcls 中。</li></ul></li><li><p>magic 的值为 0x3b 用于调试器判断当前对象是真的对象还是没有初始化的空间</p></li><li><p>has_cxx_dtor:在设置 indexed 和 magic 值之后，会设置 isa 的 has_cxx_dtor，这一位表示当前对象有 C++ 或者 ObjC 的析构器(destructor)，如果没有析构器就会快速释放内存。</p></li><li><p>shiftcls: 将当前对象对应的类指针存入 isa 结构体中</p><blockquote><p>isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;<br>所有类指针十六进制地址的最后一位都为 8 或者 0<br>将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。</p></blockquote></li></ul><ul><li><p>ISA() 方法<br>因为我们使用结构体取代了原有的 isa 指针，所以要提供一个方法 ISA() 来返回类指针。</p><p>其中 ISA_MASK 是宏定义，这里通过掩码的方式获取类指针：</p><p>#define ISA_MASK 0x00007ffffffffff8ULL<br>inline Class<br>objc_object::ISA()<br>{</p><pre><code>return (Class)(isa.bits &amp; ISA_MASK);//返回64bit中shiftcls位对应的值</code></pre><p>}</p></li></ul><h2 id="其它-bits"><a href="#其它-bits" class="headerlink" title="其它 bits"></a>其它 bits</h2><p>  在 isa_t 中，我们还有一些没有介绍的其它 bits，在这个小结就简单介绍下这些 bits 的作用</p><ul><li>has_assoc<br>对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存</li><li>weakly_referenced<br>对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放</li><li>deallocating<br>对象正在释放内存</li><li>has_sidetable_rc<br>对象的引用计数太大了，存不下</li><li>extra_rc<br>对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，extra_rc 的值就为 9</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>1、前缀：<br>0开头表示8进制，0x或0X开头表示16进制。</p><p>2、后缀：用来表示类型。<br>—— l或L表示long常量<br>—— u或U表示unsigned int常量<br>—— ul、uL、Ul、UL、lU、lu、LU、Lu表示unsigned long常量。（lu可以采用任意顺序和大小写表示）<br>—— ll、LL表示long long 常量。<br>—— ull、Ull、uLL、ULL表示unsigned long long常量。</p><blockquote><p>当希望常量被当作unsigned long long表示就在后面加上后缀ULL</p></blockquote><p>3、对于浮点常量，<br>—— f或F表示float<br>—— l或L表示long double<br>—— 其他都表示double</p><p>4、不带后缀时的规则——尽可能采用小的类型：<br>—— 对于10进制：int-&gt;long-&gt;long long<br>—— 对于8进制或16进制：int-&gt;unsigned int-&gt;long-&gt;unsigned long-&gt;long long -&gt;unsigned long long</p><h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><p>元类是Class对象的类。<br>简单的说：<br>将消息发送给对象时，会在对象的类的方法列表中查找该消息。<br>当你发送消息给一个类时，这个消息在类的元类的方法列表中查找。<br>元类是必不可少的，因为它存储了类的方法Class。Class因为每个类Class都有一个潜在唯一的类方法列表，所以每个方法都必须有一个唯一的元类。意味着所有的Class对象本身都不是同一个类。</p><p>元类具有NSObject元类作为它的类。<br>元类，也是一个对象，元类的class就是NSObject,NSObject的元类是自身。这意味着元类isa上的指针指向NSObject自己（这是它自己的一个实例）。</p><p>code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Class newClass =</span><br><span class="line">    objc_allocateClassPair([NSError class], &quot;RuntimeErrorSubclass&quot;, 0);</span><br><span class="line">class_addMethod(newClass, @selector(report), (IMP)ReportFunction, &quot;v@:&quot;);</span><br><span class="line">objc_registerClassPair(newClass);</span><br><span class="line"></span><br><span class="line">void ReportFunction(id self, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;This object is %p.&quot;, self);</span><br><span class="line">    NSLog(@&quot;Class is %@, and super is %@.&quot;, [self class], [self superclass]);</span><br><span class="line"></span><br><span class="line">    Class currentClass = [self class];</span><br><span class="line">    for (int i = 1; i &lt; 5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;Following the isa pointer %d times gives %p&quot;, i, currentClass);</span><br><span class="line">        currentClass = object_getClass(currentClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;NSObject&apos;s class is %p&quot;, [NSObject class]);</span><br><span class="line">    NSLog(@&quot;NSObject&apos;s meta class is %p&quot;, object_getClass([NSObject class]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用</span><br><span class="line">id instanceOfNewClass =</span><br><span class="line">    [[newClass alloc] initWithDomain:@&quot;someDomain&quot; code:0 userInfo:nil];</span><br><span class="line">[instanceOfNewClass performSelector:@selector(report)];</span><br><span class="line">[instanceOfNewClass release];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在运行时创建一个类只需三个简单的步骤：</span><br><span class="line"></span><br><span class="line">为“类对”分配存储（使用objc_allocateClassPair）。</span><br><span class="line">根据需要将方法和ivars添加到类中（我已经添加了一个方法class_addMethod）。</span><br><span class="line">注册该类，以便可以使用（使用objc_registerClassPair）。</span><br><span class="line"></span><br><span class="line">该函数objc_allocateClassPair只返回一个值：类。另一半就是元类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">打印如下:</span><br><span class="line">This object is 0x10010c810.</span><br><span class="line">Class is RuntimeErrorSubclass, and super is NSError.</span><br><span class="line">Following the isa pointer 1 times gives 0x10010c600</span><br><span class="line">Following the isa pointer 2 times gives 0x10010c630</span><br><span class="line">Following the isa pointer 3 times gives 0x7fff71038480</span><br><span class="line">Following the isa pointer 4 times gives 0x7fff71038480</span><br><span class="line">NSObject&apos;s class is 0x7fff710384a8</span><br><span class="line">NSObject&apos;s meta class is 0x7fff71038480</span><br><span class="line"></span><br><span class="line">通过isa重复的值来查看所到达的地址：</span><br><span class="line"></span><br><span class="line">该对象是地址0x10010c810。</span><br><span class="line">类是地址0x10010c600。</span><br><span class="line">元类是地址0x10010c630。</span><br><span class="line">元类的类（即NSObject元类）是地址0x7fff71038480。</span><br><span class="line">在NSObject元类的类本身。</span><br><span class="line">地址的价值并不重要，只是它展示了从类到元类到NSObject元类的进展。</span><br></pre></td></tr></table></figure></p><p>object_getClass 与 objc_getClass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class cls = [XXObject class];</span><br><span class="line">NSLog(@&quot;%p&quot;,cls);                  //0x1000011a8</span><br><span class="line">NSLog(@&quot;%p&quot;,object_getClass(cls));//0x100001180  </span><br><span class="line">NSLog(@&quot;%p&quot;,objc_getClass([NSStringFromClass(cls)UTF8String]));//0x1000011a8  </span><br><span class="line"></span><br><span class="line">object_getClass 返回 isa指向的类</span><br><span class="line">objc_getClass方法只是单纯地返回了Class</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.isa结构<br>2.元类 元类的概念</p><ul><li>Object_Class</li><li>objc_class<br>3.类在内存中的位置，在编译期间就已经确定了</li></ul><h2 id="阅读链接"><a href="#阅读链接" class="headerlink" title="阅读链接"></a>阅读链接</h2><p><a href="https://github.com/Draveness/analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md" target="_blank" rel="noopener">isa解读</a>  以上图片链接均来自于下面的文章中</p><p><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">关于元类</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="analyze" scheme="https://pattyxp.github.io/tags/analyze/"/>
    
  </entry>
  
  <entry>
    <title>为什么使用copy而不是Strong</title>
    <link href="https://pattyxp.github.io/2018/01/09/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8copy%E8%80%8C%E4%B8%8D%E6%98%AFStrong/"/>
    <id>https://pattyxp.github.io/2018/01/09/为什么使用copy而不是Strong/</id>
    <published>2018-01-09T09:20:30.000Z</published>
    <updated>2018-01-09T11:57:01.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//下面使用打印下指针看下</span><br><span class="line">NSMutableString *str1 = [NSMutableString stringWithFormat:@&quot;iOS&quot;];</span><br><span class="line">NSLog(@&quot;%p&quot;, str1);  //0x7b0c0006e0a0</span><br><span class="line">NSString *str_a1 = str1;</span><br><span class="line">NSLog(@&quot;%p&quot;, str_a1);  //0x7b0c0006e0a0</span><br><span class="line">NSString *str_b1 = [str1 copy];</span><br><span class="line">NSLog(@&quot;%p&quot;, str_b1);  //0xa00000000534f693</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSString *str2 = [NSMutableString stringWithFormat:@&quot;iOS&quot;];</span><br><span class="line">NSLog(@&quot;%p&quot;, str2);     //0x7b0c000776a0</span><br><span class="line">NSString *str_a2 = str2;</span><br><span class="line">NSLog(@&quot;%p&quot;, str_a2);  //0x7b0c000776a0</span><br><span class="line">NSString *str_b2 = [str2 copy];</span><br><span class="line">NSLog(@&quot;%p&quot;, str_b2);  //0xa00000000534f693</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSString *str3 = [NSString stringWithFormat:@&quot;iOS&quot;];</span><br><span class="line">NSLog(@&quot;%p&quot;, str3);   //0xa00000000534f693</span><br><span class="line">NSString *str_a3 = str3;</span><br><span class="line">NSLog(@&quot;%p&quot;, str_a3); //0xa00000000534f693</span><br><span class="line">NSString *str_b3 = [str3 copy];</span><br><span class="line">NSLog(@&quot;%p&quot;, str_b3); //0xa00000000534f693</span><br><span class="line"></span><br><span class="line">//结论:</span><br><span class="line"> 从一个 NSString 进行 copy 后赋值，copy 方法仍旧是浅拷贝</span><br><span class="line"> 从一个 NSMutableString 进行 copy 后赋值，copy 方法是深拷贝</span><br></pre></td></tr></table></figure><p>当令 NSString 对象指针指向一个 NSMutableString 的时候，则会对一个对象进行深复制。这也就是我们一直所说的在一个 Class 的成员是 NSString 类型的时候，修饰属性应该使用 copy ，其实就是在使用 mutable 对象进行赋值的时候，防止 mutable 对象的改变从而影响成员变量。</p><p>源码分析<br><a href="https://searchcode.com/file/12532490/libFoundation/Foundation/NSString.m" target="_blank" rel="noopener">NSString.m</a>中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    if (NSStringClass == Nil)</span><br><span class="line">        NSStringClass = [NSString class];</span><br><span class="line">    return RETAIN(self);</span><br><span class="line">&#125;</span><br><span class="line">- (id)mutableCopyWithZone:(NSZone*)zone &#123;</span><br><span class="line">    return [[NSMutableString allocWithZone:zone] initWithString:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>NSString copy方法，返回的是self自身，属于浅拷贝<br>mutableCopyWithZone方法，返回新初始化的对象NSMutableString，所以是深拷贝</p><p><a href="https://searchcode.com/file/68838008/jni%20w:%20itoa%20runtime%20and%20allocator/Foundation/NSMutableString.m" target="_blank" rel="noopener">NSMutableString.m</a> 中只发现了copyWithZone:和copy:方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(id)copy &#123;</span><br><span class="line">    return [[NSString alloc] initWithString:self];</span><br><span class="line">&#125;</span><br><span class="line">-(id)copyWithZone:(NSZone*)zone &#123;</span><br><span class="line">    return [[NSString allocWithZone:zone] initWithString:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>NSMutableString copy方法，会变成深复制，因为返回的对象如源码所示，调用了 NSString 的全能初始化方法，并且由一个新的 NSString 持有。<br>在源码中并没有重写mutableCopy方法，也没有实现mutableCopyWithZone:方法，所以会调用父类的mutableCopyWithZone。而在父类中 mutableCopyWithZone:方法中调用了 NSMutableString 的全局初始化方法，所以依旧是深复制。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@interface Man : NSObject</span><br><span class="line">@property (nonatomic, strong) NSString *eat;</span><br><span class="line">@property (nonatomic, copy) NSString *drink;</span><br><span class="line">@end</span><br><span class="line">@implementation Man</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">  Man *man = [[Man alloc] init];</span><br><span class="line">  NSMutableString *str = [NSMutableString stringWithFormat:@&quot;山珍海味&quot;];</span><br><span class="line"></span><br><span class="line">  man.eat = str;</span><br><span class="line">  man.drink = str;</span><br><span class="line">  NSLog(@&quot;%@-%@&quot;,man.eat,man.drink); // 山珍海味-山珍海味</span><br><span class="line"></span><br><span class="line">  [str appendString:@&quot;白开水&quot;];</span><br><span class="line">  NSLog(@&quot;%@-%@&quot;,man.eat,man.drink); //山珍海味白开水-山珍海味</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q 经典面试题：为什么 NSString 类型成员变量的修饰属性用 copy 而不是 strong (或 retain ) ？</p><p>A 当我们通过一个 NSMutableString 对 NSString 变量进行赋值，如果 NSString 的 property 是 strong 类型的时候，就会随着 NSMutableString 类型的变量一起变化。<br>strong修饰，仅仅是指针引用，增加了引用计数器</p><h2 id="阅读链接"><a href="#阅读链接" class="headerlink" title="阅读链接"></a>阅读链接</h2><p><a href="http://www.desgard.com/copy/" target="_blank" rel="noopener">http://www.desgard.com/copy/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://pattyxp.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>weak底层源码解析</title>
    <link href="https://pattyxp.github.io/2018/01/09/weak%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://pattyxp.github.io/2018/01/09/weak底层源码解析/</id>
    <published>2018-01-09T06:20:56.000Z</published>
    <updated>2018-01-10T03:12:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文分析是runtime源码 <a href="https://github.com/isaacselement/objc4-706" target="_blank" rel="noopener">objc4-706版本</a><br>OC code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// NSObject *obj = ...;</span><br><span class="line">__weak id weakPtr = obj;</span><br></pre></td></tr></table></figure></p><p>底层转为源码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// NSObject *obj = ...;</span><br><span class="line">objc_initWeak(&amp;weakPtr, obj);</span><br></pre></td></tr></table></figure></p><p>来看下NSObject.mm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_initWeak(id *location, id newObj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 这里传递了三个 bool 数值</span><br><span class="line">    // 使用 template 进行常量参数传递是为了优化性能</span><br><span class="line">    return storeWeak&lt;false/*old*/, true/*new*/, true/*crash*/&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续阅读 storeWeak() 的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">// HaveOld: true - 变量有值</span><br><span class="line">// false - 需要被及时清理，当前值可能为 nil</span><br><span class="line">// HaveNew: true - 需要被分配的新值，当前值可能为 nil</span><br><span class="line">// false - 不需要分配新值</span><br><span class="line">// CrashIfDeallocating: true - 说明 newObj 已经释放或者 newObj 不支持弱引用，该过程需要暂停</span><br><span class="line">// false - 用 nil 替代存储</span><br><span class="line"></span><br><span class="line">template &lt;bool HaveOld, bool HaveNew, bool CrashIfDeallocating&gt;</span><br><span class="line">static id</span><br><span class="line">storeWeak(id *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(HaveOld  ||  HaveNew);</span><br><span class="line">    if (!HaveNew) assert(newObj == nil);</span><br><span class="line">    // 用于标记已经初始化的类</span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">     // 声明新旧辅助表</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line">    // 获取新旧值（存在的话）的辅助表，并且加锁，</span><br><span class="line">    // 如果新旧值辅助表同时存在时，以锁的地址大小排序，防止锁的顺序问题</span><br><span class="line"> retry:</span><br><span class="line">    if (HaveOld) &#123;</span><br><span class="line">        // 如果有旧值的话，通过指针获取目标对象，  Q： 旧值的情况是不是指这个地址*location之前存的值？？？</span><br><span class="line">        // 再以目标对象的地址为索引，取得旧值对应的辅助表</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (HaveNew) &#123;</span><br><span class="line">        // 如果有新值，以新值的地址为索引，取得新值对应的辅助表</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SideTable::lockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    if (HaveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        // 线程冲突处理，</span><br><span class="line">        // 如果有旧值，但 location 指向的对象不为 oldObj，那很可能被其它线程修改过，</span><br><span class="line">        // 解锁并重试</span><br><span class="line">        SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (HaveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        if (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized())</span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">            _class_initialize(_class_getNonMetaClass(cls, (id)newObj));</span><br><span class="line"></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Clean up old value, if any.</span><br><span class="line">    // 从 oldObj 的弱引用条目删除弱引用的地址</span><br><span class="line">    if (HaveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Assign new value, if any.</span><br><span class="line">    // 把弱引用的地址注册到 newObj 的弱引用条目</span><br><span class="line">    if (HaveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table,</span><br><span class="line">                                                      (id)newObj, location,</span><br><span class="line">                                                      CrashIfDeallocating);</span><br><span class="line">        // weak_register_no_lock returns nil if weak store should be rejected</span><br><span class="line"></span><br><span class="line">        // Set is-weakly-referenced bit in refcount table.</span><br><span class="line">        if (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Do not set *location anywhere else. That would introduce a race.</span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // No new value. The storage is not changed.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    return (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li>SideTable 这个结构体 : 主要用于管理对象的引用计数和 weak 表</li><li>&amp;SideTables()[oldObj] : 根据对象的地址在缓存中取出对应的 SideTable 实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在取出实例方法的实现中，使用了 C++ 标准转换运算符 reinterpret_cast ，其表达方式为</p><blockquote><p>reinterpret_cast <new_type> (expression)<br>用来处理无关类型之间的转换。该关键字会产生一个新值，并保证与原参数（expression）拥有完全相同的比特位。</new_type></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="阅读链接"><a href="#阅读链接" class="headerlink" title="阅读链接"></a>阅读链接</h2><p><a href="http://www.desgard.com/weak/" target="_blank" rel="noopener">http://www.desgard.com/weak/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文分析是runtime源码 &lt;a href=&quot;https://github.com/isaacselement/objc4-706&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;objc4-706版本&lt;/a&gt;&lt;br&gt;OC code&lt;br&gt;&lt;figure 
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://pattyxp.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Block浅析持有对象</title>
    <link href="https://pattyxp.github.io/2018/01/08/Block%E6%B5%85%E6%9E%90%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/"/>
    <id>https://pattyxp.github.io/2018/01/08/Block浅析持有对象/</id>
    <published>2018-01-08T07:33:52.000Z</published>
    <updated>2018-01-10T01:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一段"><a href="#第一段" class="headerlink" title="第一段"></a>第一段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface TestObject ()</span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@end</span><br><span class="line">@implementation TestObject</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,self.name);</span><br><span class="line">    &#125;();</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>经过clang -rewrite-objc xx.m 之后得到 TestObject.cpp ，精简之后得到如下源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> // @interface TestObject ()</span><br><span class="line"> // @property (nonatomic, strong) NSString *name;</span><br><span class="line"> /* @end */</span><br><span class="line"></span><br><span class="line">// @implementation TestObject</span><br><span class="line"></span><br><span class="line">struct __TestObject__test_block_impl_0 &#123;</span><br><span class="line">    struct __block_impl impl;</span><br><span class="line">    struct __TestObject__test_block_desc_0* Desc;</span><br><span class="line">    TestObject *self;</span><br><span class="line">    __TestObject__test_block_impl_0(void *fp, struct __TestObject__test_block_desc_0 *desc, TestObject *_self, int flags=0) : self(_self) &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __TestObject__test_block_func_0(struct __TestObject__test_block_impl_0 *__cself) &#123;</span><br><span class="line">    TestObject *self = __cself-&gt;self; // bound by copy</span><br><span class="line"></span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_TestObject_b2287f_mi_0,((NSString *(*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(&quot;name&quot;)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  //这里可以观察到，在test_block_impl中，block持有了对象TestObject *self;</span><br></pre></td></tr></table></figure><h2 id="第二段"><a href="#第二段" class="headerlink" title="第二段"></a>第二段</h2><p> OC源码<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface TestObject ()</span><br><span class="line">@end</span><br><span class="line">@implementation TestObject</span><br><span class="line"></span><br><span class="line">int global_i = 1;</span><br><span class="line">static int static_global_j = 2;</span><br><span class="line"></span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    static int static_global_k = 3;</span><br><span class="line">    __block int value = 4;</span><br><span class="line"></span><br><span class="line">    void(^pig)()= ^()&#123;</span><br><span class="line">        global_i++;</span><br><span class="line">        static_global_j++;</span><br><span class="line">        static_global_k++;</span><br><span class="line">        value++;</span><br><span class="line">         NSLog(@&quot;Block中 变量 = %d  %d %d %d&quot;, global_i,static_global_j,static_global_k,value);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    global_i++;</span><br><span class="line">    static_global_j++;</span><br><span class="line">    static_global_k++;</span><br><span class="line">    value++;</span><br><span class="line">    NSLog(@&quot;Block中 变量 = %d  %d %d %d&quot;, global_i,static_global_j,static_global_k,value);</span><br><span class="line"></span><br><span class="line">    pig();</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>经过编译之后，得到大致的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">可见block里没有引用全局变量，静态全局变量，静态变量</span><br><span class="line"></span><br><span class="line">struct __Block_byref_value_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_value_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int value;  //新增一个对象，与外部的变量value同名</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct __TestObject__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __TestObject__test_block_desc_0* Desc;</span><br><span class="line">  int *static_global_k;   </span><br><span class="line">  __Block_byref_value_0 *value; // by ref</span><br><span class="line">  __TestObject__test_block_impl_0(void *fp, struct __TestObject__test_block_desc_0 *desc, int *_static_global_k, __Block_byref_value_0 *_value, int flags=0) : static_global_k(_static_global_k), value(_value-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">在__TestObject__test_block_impl_0中</span><br><span class="line">static_global_k和__Block_byref_value_0 *value</span><br><span class="line">被Block从外面捕获进来，成为__TestObject__test_block_impl_0这个结构体的成员变量了。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void __TestObject__test_block_func_0(struct __TestObject__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_value_0 *value = __cself-&gt;value; // bound by ref  </span><br><span class="line">  int *static_global_k = __cself-&gt;static_global_k; // bound by copy</span><br><span class="line"></span><br><span class="line">        global_i++;</span><br><span class="line">        static_global_j++;</span><br><span class="line">        (*static_global_k)++;</span><br><span class="line">        (value-&gt;__forwarding-&gt;value)++;</span><br><span class="line">         NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_TestObject_fb5e34_mi_0, global_i,static_global_j,(*static_global_k),(value-&gt;__forwarding-&gt;value));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>block捕获了自动变量value的值而不是地址，所以不会改变value在block外的值</p><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>OC代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^drink)();</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic, strong) drink doDrink;</span><br><span class="line">@property (nonatomic, strong) NSString *eat;</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface BlockViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BlockViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.eat = @&quot;山珍海味&quot;;</span><br><span class="line">    __weak typeof(Person*) weakSelf = person;</span><br><span class="line">    person.doDrink = ^&#123;</span><br><span class="line">        NSLog(@&quot;person eat = %@&quot;,weakSelf.eat);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>clang这样编译是不过的，将<strong>weak替换为</strong>unsafe_unretained，然后 clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk xx.m<br>clang之后源码，精简如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct __BlockViewController__viewDidLoad_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __BlockViewController__viewDidLoad_block_desc_0* Desc;</span><br><span class="line">  typeof(Person *) weakSelf;</span><br><span class="line">  __BlockViewController__viewDidLoad_block_impl_0(void *fp, struct __BlockViewController__viewDidLoad_block_desc_0 *desc, typeof(Person *) _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __BlockViewController__viewDidLoad_block_func_0(struct __BlockViewController__viewDidLoad_block_impl_0 *__cself) &#123;</span><br><span class="line">  typeof(Person *) weakSelf = __cself-&gt;weakSelf; // bound by copy</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_BlockViewController_7d49b7_mi_1,((NSString *(*)(id, SEL))(void *)objc_msgSend)((id)weakSelf, sel_registerName(&quot;eat&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">block持有的是typeof(Person *) weakSelf;</span><br><span class="line">底层实现objc_initWeak 和 objc_storeWeak</span><br></pre></td></tr></table></figure></p><p>##总结:<br>自动变量是以值传递方式传递到Block的构造函数里面去的。Block只捕获Block中会用到的变量。由于只捕获了自动变量的值，并非内存地址，所以Block内部不能改变自动变量的值<br>Block捕获的外部变量可以改变值的是 静态变量，静态全局变量，全局变量</p><p>下一篇将介绍__weak底层实现</p><p>##<br><a href="http://nsoio.github.io/2015/06/28/ARC%E4%B8%ADweak%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">http://nsoio.github.io/2015/06/28/ARC%E4%B8%ADweak%E5%AE%9E%E7%8E%B0/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一段&quot;&gt;&lt;a href=&quot;#第一段&quot; class=&quot;headerlink&quot; title=&quot;第一段&quot;&gt;&lt;/a&gt;第一段&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://pattyxp.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>load了解</title>
    <link href="https://pattyxp.github.io/2018/01/08/load%E4%BA%86%E8%A7%A3/"/>
    <id>https://pattyxp.github.io/2018/01/08/load了解/</id>
    <published>2018-01-08T03:29:31.000Z</published>
    <updated>2018-01-09T11:17:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>##程序启动加载的流程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//dyld(The Dynamic Link Editor)是 Apple 的动态链接库，系统内核做好启动程序的初始准备后，将其他事务交给 dyld 负责</span><br><span class="line">_dyld-start</span><br><span class="line">|</span><br><span class="line">_objc_init</span><br><span class="line">|</span><br><span class="line">_dyld_objc_notify_register</span><br><span class="line">|</span><br><span class="line">load_images</span><br></pre></td></tr></table></figure></p><p><img src="/images/load_images.png" alt="线程图"></p><p>类方法加载的流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    // Return without taking locks if there are no +load methods here.</span><br><span class="line">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    // Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((const headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br><span class="line">通过load_images进行类的存储prepare_load_methods，包括类的load方法和category方法，存在数组中loadable_classes和loadable_categories</span><br><span class="line">然后调用call_load_methods去调用call_class_loads和call_category_loads</span><br></pre></td></tr></table></figure><p>prepare_load_methods //将需要调用 load 方法的类添加到一个列表中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void prepare_load_methods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    classref_t *classlist =</span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        if (!cls) continue;  // category for ignored weak-linked class</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过_getObjc2NonlazyClassList 获取所有的类的列表之后，会通过 remapClass 获取类对应的指针，<br>然后调用 schedule_class_load 递归地安排当前类和没有调用 + load 父类进入列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED);</span><br><span class="line">&#125;</span><br><span class="line">在执行 add_class_to_loadable_list(cls) 将当前类加入加载列表之前，会先把父类加入待加载的列表，保证父类在子类前调用 load 方法。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void add_class_to_loadable_list(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    if (!method) return;  // Don&apos;t bother if cls has no +load method</span><br><span class="line"></span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(&quot;LOAD: class &apos;%s&apos; scheduled for +load&quot;,</span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*2 + 16;</span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            realloc(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              sizeof(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br><span class="line">判断当前loadable_classes是否被分配完，如果没有剩余空间，就会在当前数组的基础上扩大数组的大小：realloc，然后把传入的 class 以及对应的方法的实现加到列表中</span><br></pre></td></tr></table></figure><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*load_method)(cls, SEL_load); 这一句可以调用 load 方法？</span><br><span class="line">cls执行load_method指针指向的函数地址</span><br></pre></td></tr></table></figure><p>其实这里是C函数指针的概念<br>举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">void run() &#123;</span><br><span class="line">    printf(&quot;Hello World\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        void (*dy_run)() = run;</span><br><span class="line">        (*dy_run)();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">其结果会发现执行了 run 方法，并输出了 Hello World。这里，我们通过一个 void (*fptr)() 类型的函数指针，将 run 函数获取出，并运行函数。实际上其中的工作是抓取 run 函数的地址并存储在指针变量中。我们通过指针运行对应的地址部分，其效果为执行了 run 函数。</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下 Class 中 load 方法的全部流程，用流程图将其描述一下：<br><img src="/images/流程图.png" alt="流程图"></p><ul><li>Load Images: 通过 dyld 载入 image 文件，引入 Class。</li><li>Prepare Load Methods: 准备 load 方法。过滤无效类、无效方法，将 load 方法指针和所属 Class 指针收集至全局 Class 存储线性表 loadable_classes 中，其中会涉及到自动扩展空间和父类优先的递归调用问题。</li><li>Call Load Methods: 根据收集到的函数指针，对 load 方法进行动态调用。进一步过滤无效方法，并记录 log 日志。</li></ul><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>什么是images?<br>images表示的是二进制文件（可执行文件或者动态链接库.so文件）编译后的符号、代码等。所以 load_images 的工作是传入处理过后的二进制文件并让 Runtime 进行处理，并且每一个文件对应一个抽象实例来负责加载，这里的实例是 ImageLoader。</p><p>ImageLoader 处理二进制文件的时机是在 main 入口函数以前，它在加载文件时主要做两个工作：</p><ul><li>在程序运行时它先将动态链接的 image 递归加载 （也就是上面测试栈中一串的递归调用的时刻）</li><li>再从可执行文件 image 递归加载所有符号</li></ul><h2 id="阅读链接"><a href="#阅读链接" class="headerlink" title="阅读链接"></a>阅读链接</h2><p><a href="https://github.com/Draveness/analyze/blob/master/contents/objc/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%20load%20%E6%96%B9%E6%B3%95%E4%B9%88%EF%BC%9F.md" target="_blank" rel="noopener">https://github.com/Draveness/analyze/blob/master/contents/objc/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%20load%20%E6%96%B9%E6%B3%95%E4%B9%88%EF%BC%9F.md</a></p><p><a href="https://xiaozhuanlan.com/topic/3175268940" target="_blank" rel="noopener">https://xiaozhuanlan.com/topic/3175268940</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##程序启动加载的流程&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://pattyxp.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Log</title>
    <link href="https://pattyxp.github.io/2018/01/05/Log/"/>
    <id>https://pattyxp.github.io/2018/01/05/Log/</id>
    <published>2018-01-05T03:45:17.000Z</published>
    <updated>2018-01-05T05:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># define DLog(fmt, ...) NSLog((@&quot;[文件名:%s]\n&quot; &quot;[函数名:%s]\n&quot; &quot;[行号:%d] \n&quot; fmt), __FILE__, __FUNCTION__, __LINE__, ##__VA_ARGS__);</span><br></pre></td></tr></table></figure><p>参数解释：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__VA_ARGS__</span><br><span class="line"></span><br><span class="line">是一个可变参数的宏，很少人知道这个宏，这个可变参数的宏是新的C99规范中新增的，目前似乎只有gcc支（VC6.0的编译器不支持）。宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的&quot;,&quot;去掉的作用,否则会编译出错, 你可以试试。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__FILE__   宏在预编译时会替换成当前的源文件名</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__LINE__  宏在预编译时会替换成当前的行号</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__FUNCTION__  宏在预编译时会替换成当前的函数名称</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__PRETTY_FUNCTION__  底层库函数名</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt  实际上就是自己输入的参数 format</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="小知识点" scheme="https://pattyxp.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>WebViewJavascriptBridge</title>
    <link href="https://pattyxp.github.io/2018/01/04/WebViewJavascriptBdidge/"/>
    <id>https://pattyxp.github.io/2018/01/04/WebViewJavascriptBdidge/</id>
    <published>2018-01-04T05:42:00.000Z</published>
    <updated>2018-01-04T08:28:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个库主要是作为iOS(mac)和JS之间的桥梁，对于双方来说使用都非常的便利</p><p>文件结构非常简单，主要有三部分内容组成</p><p>WebViewJavascriptBridge (UIWebView:ios &amp;&amp; WebView:mac)<br>WKWebViewJavascriptBridge（WKWebView:ios）</p><p>WebViewJavascriptBridgeBase (实现类)</p><p>WebViewJavascriptBridge_js （JS代码注入类）</p><p>下面来简单描述下吧<br>WebViewJavascriptBridge 和 WKWebViewJavascriptBridge 两个类主要是针对iOS和mac上使用的，毕竟有所差别，iOS8之后使用WKWebView，所以才有了类WKWebViewJavascriptBridge，但是两个类在接口和声明上，属性，基本都是一致的，这样方便对外公开的接口，内部实现自动判断设备和版本号</p><p>下面说明主要针对WebViewJavascriptBridge</p><h2 id="WebViewJavascriptBridge-h"><a href="#WebViewJavascriptBridge-h" class="headerlink" title="WebViewJavascriptBridge.h"></a>WebViewJavascriptBridge.h</h2><ul><li><p>宏定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if (__MAC_OS_X_VERSION_MAX_ALLOWED &gt; __MAC_10_9 || __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_7_1)</span><br><span class="line">#define supportsWKWebView</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li><p>引入库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if defined supportsWKWebView</span><br><span class="line">#import &lt;WebKit/WebKit.h&gt;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li><p>宏定义 根据设备类型，引入对应的库，<br>定义 WVJB_WEBVIEW_TYPE、WVJB_WEBVIEW_DELEGATE_TYPE、WVJB_WEBVIEW_DELEGATE_INTERFACE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#if defined __MAC_OS_X_VERSION_MAX_ALLOWED</span><br><span class="line">    #define WVJB_PLATFORM_OSX</span><br><span class="line">    #define WVJB_WEBVIEW_TYPE WebView</span><br><span class="line">    #define WVJB_WEBVIEW_DELEGATE_TYPE NSObject&lt;WebViewJavascriptBridgeBaseDelegate&gt;</span><br><span class="line">    #define WVJB_WEBVIEW_DELEGATE_INTERFACE NSObject&lt;WebViewJavascriptBridgeBaseDelegate, WebPolicyDelegate&gt;</span><br><span class="line">#elif defined __IPHONE_OS_VERSION_MAX_ALLOWED</span><br><span class="line">    #import &lt;UIKit/UIWebView.h&gt;</span><br><span class="line">    #define WVJB_PLATFORM_IOS</span><br><span class="line">    #define WVJB_WEBVIEW_TYPE UIWebView</span><br><span class="line">    #define WVJB_WEBVIEW_DELEGATE_TYPE NSObject&lt;UIWebViewDelegate&gt;</span><br><span class="line">    #define WVJB_WEBVIEW_DELEGATE_INTERFACE NSObject&lt;UIWebViewDelegate, WebViewJavascriptBridgeBaseDelegate&gt;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li><p>对外公开实现方法</p></li></ul><h2 id="WebViewJavascriptBridge-m"><a href="#WebViewJavascriptBridge-m" class="headerlink" title="WebViewJavascriptBridge.m"></a>WebViewJavascriptBridge.m</h2><ul><li><p>如果支持WKWebView，引入对应的类，这样直接外部引入这个类就可以实现相应功能了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if defined(supportsWKWebView)</span><br><span class="line">#import &quot;WKWebViewJavascriptBridge.h&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li><p>宏定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if __has_feature(objc_arc_weak)</span><br><span class="line">    #define WVJB_WEAK __weak</span><br><span class="line">#else</span><br><span class="line">    #define WVJB_WEAK __unsafe_unretained</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li><p>内部属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@implementation WebViewJavascriptBridge &#123;</span><br><span class="line">    WVJB_WEAK WVJB_WEBVIEW_TYPE* _webView; //webview</span><br><span class="line">    WVJB_WEAK id _webViewDelegate;  //delegate</span><br><span class="line">    long _uniqueId;  //实测是在发送消息的时候，将消息体和responseBlock等数据一起存在字典里，字典里对应存放的key是uniqueId,value是responseBlock，对应一个webView类来说，此数不断加1 ，用以区分不同的message</span><br><span class="line">    WebViewJavascriptBridgeBase *_base; //具体实现的功能类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>两个类方法用于打印日志Log,最大长度500</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (void)enableLogging &#123;</span><br><span class="line">    [WebViewJavascriptBridgeBase enableLogging];</span><br><span class="line">&#125;</span><br><span class="line">+ (void)setLogMaxLength:(int)length &#123;</span><br><span class="line">    [WebViewJavascriptBridgeBase setLogMaxLength:length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化<br>可以看出，针对判断不同的类型生成对应的webViewBridge，如果不是已申明的对应webView类型，就报异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)bridgeForWebView:(id)webView &#123;</span><br><span class="line">    return [self bridge:webView];</span><br><span class="line">&#125;</span><br><span class="line">+ (instancetype)bridge:(id)webView &#123;</span><br><span class="line">#if defined supportsWKWebView</span><br><span class="line">    if ([webView isKindOfClass:[WKWebView class]]) &#123;</span><br><span class="line">        return (WebViewJavascriptBridge*) [WKWebViewJavascriptBridge bridgeForWebView:webView];</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    if ([webView isKindOfClass:[WVJB_WEBVIEW_TYPE class]]) &#123;</span><br><span class="line">        WebViewJavascriptBridge* bridge = [[self alloc] init];</span><br><span class="line">        [bridge _platformSpecificSetup:webView];</span><br><span class="line">        return bridge;</span><br><span class="line">    &#125;</span><br><span class="line">    [NSException raise:@&quot;BadWebViewType&quot; format:@&quot;Unknown web view type.&quot;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以看出，由该类封装的方法内部还是让base去做相对应的事情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)send:(id)data &#123;</span><br><span class="line">    [self send:data responseCallback:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)send:(id)data responseCallback:(WVJBResponseCallback)responseCallback &#123;</span><br><span class="line">    [_base sendData:data responseCallback:responseCallback handlerName:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)callHandler:(NSString *)handlerName &#123;</span><br><span class="line">    [self callHandler:handlerName data:nil responseCallback:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)callHandler:(NSString *)handlerName data:(id)data &#123;</span><br><span class="line">    [self callHandler:handlerName data:data responseCallback:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)callHandler:(NSString *)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback &#123;</span><br><span class="line">    [_base sendData:data responseCallback:responseCallback handlerName:handlerName];</span><br><span class="line">&#125;</span><br><span class="line">- (void)registerHandler:(NSString *)handlerName handler:(WVJBHandler)handler &#123;</span><br><span class="line">    _base.messageHandlers[handlerName] = [handler copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeHandler:(NSString *)handlerName &#123;</span><br><span class="line">    [_base.messageHandlers removeObjectForKey:handlerName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)disableJavscriptAlertBoxSafetyTimeout &#123;</span><br><span class="line">    [_base disableJavscriptAlertBoxSafetyTimeout];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>剩下的就是针对 OSX 以及 iOS 分别做的初始化操作和实现对应的方法了，目的是一样的，实现上稍有差异</p></li></ul><p>这里有一个属性_webViewDelegate，是由外部调用接口实现赋值的，如果有需要在请求开始，结束，失败的时候做特殊处理，可以调用该方法实现对应的代理方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setWebViewDelegate:(WVJB_WEBVIEW_DELEGATE_TYPE*)webViewDelegate &#123;</span><br><span class="line">    _webViewDelegate = webViewDelegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="WebViewJavascriptBridgeBase"><a href="#WebViewJavascriptBridgeBase" class="headerlink" title="WebViewJavascriptBridgeBase"></a>WebViewJavascriptBridgeBase</h2><ul><li><p>sendData方法，上面已经提到了，具体实现看下 核心差不多就是这些了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendData:(id)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(NSString*)handlerName &#123;</span><br><span class="line">    NSMutableDictionary* message = [NSMutableDictionary dictionary];</span><br><span class="line"></span><br><span class="line">    if (data) &#123;</span><br><span class="line">        message[@&quot;data&quot;] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (responseCallback) &#123;</span><br><span class="line">        NSString* callbackId = [NSString stringWithFormat:@&quot;objc_cb_%ld&quot;, ++_uniqueId];</span><br><span class="line">        self.responseCallbacks[callbackId] = [responseCallback copy];</span><br><span class="line">        message[@&quot;callbackId&quot;] = callbackId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (handlerName) &#123;</span><br><span class="line">        message[@&quot;handlerName&quot;] = handlerName;</span><br><span class="line">    &#125;</span><br><span class="line">    [self _queueMessage:message];//这里将数据组装在字典里，然后发送</span><br><span class="line">&#125;</span><br><span class="line">- (void)_queueMessage:(WVJBMessage*)message &#123;</span><br><span class="line">    if (self.startupMessageQueue) &#123;</span><br><span class="line">        [self.startupMessageQueue addObject:message];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self _dispatchMessage:message]; //消息执行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)_dispatchMessage:(WVJBMessage*)message &#123;</span><br><span class="line">    NSString *messageJSON = [self _serializeMessage:message pretty:NO];</span><br><span class="line">    [self _log:@&quot;SEND&quot; json:messageJSON];</span><br><span class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\\&quot; withString:@&quot;\\\\&quot;];</span><br><span class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\&quot;&quot; withString:@&quot;\\\&quot;&quot;];</span><br><span class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\&apos;&quot; withString:@&quot;\\\&apos;&quot;];</span><br><span class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\n&quot; withString:@&quot;\\n&quot;];</span><br><span class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\r&quot; withString:@&quot;\\r&quot;];</span><br><span class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\f&quot; withString:@&quot;\\f&quot;];</span><br><span class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\u2028&quot; withString:@&quot;\\u2028&quot;];</span><br><span class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\u2029&quot; withString:@&quot;\\u2029&quot;];</span><br><span class="line"></span><br><span class="line">    //以上是将消息字典转为JSON对象，然后字符转义</span><br><span class="line">    NSString* javascriptCommand = [NSString stringWithFormat:@&quot;WebViewJavascriptBridge._handleMessageFromObjC(&apos;%@&apos;);&quot;, messageJSON];//执行JS方法</span><br><span class="line">    if ([[NSThread currentThread] isMainThread]) &#123;</span><br><span class="line">        [self _evaluateJavascript:javascriptCommand];//主线程执行</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [self _evaluateJavascript:javascriptCommand];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>剩下的方法，主要就是在发送消息时候的数据类型校验之类的，由WebViewJavascriptBridge和WKWebViewJavascriptBridge调用<br>如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123;</span><br><span class="line">    if (webView != _webView) &#123; return YES; &#125; //校验</span><br><span class="line"></span><br><span class="line">    NSURL *url = [request URL];</span><br><span class="line">    __strong WVJB_WEBVIEW_DELEGATE_TYPE* strongDelegate = _webViewDelegate;</span><br><span class="line">    if ([_base isWebViewJavascriptBridgeURL:url]) &#123; //校验URL</span><br><span class="line">        if ([_base isBridgeLoadedURL:url]) &#123; //校验URL</span><br><span class="line">            [_base injectJavascriptFile]; //注入JS</span><br><span class="line">        &#125; else if ([_base isQueueMessageURL:url]) &#123; //校验URL</span><br><span class="line">            NSString *messageQueueString = [self _evaluateJavascript:[_base webViewJavascriptFetchQueyCommand]];</span><br><span class="line">            [_base flushMessageQueue:messageQueueString]; //执行消息队列</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [_base logUnkownMessage:url];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125; else if (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:@selector(webView:shouldStartLoadWithRequest:navigationType:)]) &#123; //如果有代理，拦截并执行代理方法</span><br><span class="line">        return [strongDelegate webView:webView shouldStartLoadWithRequest:request navigationType:navigationType];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="native-和-JS-如何交互"><a href="#native-和-JS-如何交互" class="headerlink" title="native 和 JS 如何交互"></a>native 和 JS 如何交互</h2><p>具体其实看下官方demo走一遍流程就明了了</p><p>JS调用native,如何响应</p><p>首先，JS实现如下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function setupWebViewJavascriptBridge(callback) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var WVJBIframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    WVJBIframe.style.display = &apos;none&apos;; //设置不显示</span><br><span class="line">    WVJBIframe.src = &apos;https://__bridge_loaded__&apos;;</span><br><span class="line">    document.documentElement.appendChild(WVJBIframe);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">JS 端调用 setupWebViewJavascriptBridge，注入了一个页面，不显示的，scr和base里面的定义kBridgeLoaded一致，所以判断时候满足isBridgeLoadedURL，就会调用注入JS的方法了</span><br></pre></td></tr></table></figure></p><p>JS 端调用 bridge.callHandler 时，调用 iOS handler，参数校验之后调用_doSend 函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function callHandler(handlerName, data, responseCallback) &#123;</span><br><span class="line">  if (arguments.length == 2 &amp;&amp; typeof data == &apos;function&apos;) &#123; //校验</span><br><span class="line">    responseCallback = data;</span><br><span class="line">    data = null;</span><br><span class="line">  &#125;</span><br><span class="line">  _doSend(&#123; handlerName:handlerName, data:data &#125;, responseCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _doSend(message, responseCallback) &#123;</span><br><span class="line">  if (responseCallback) &#123;</span><br><span class="line">    var callbackId = &apos;cb_&apos;+(uniqueId++)+&apos;_&apos;+new Date().getTime();</span><br><span class="line">    responseCallbacks[callbackId] = responseCallback;</span><br><span class="line">    message[&apos;callbackId&apos;] = callbackId;</span><br><span class="line">  &#125;</span><br><span class="line">  sendMessageQueue.push(message);</span><br><span class="line">  messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + &apos;://&apos; + QUEUE_HAS_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>可以看到 JS 端的代码中有 callHandler 函数的实现，其内部将入参 handlerName,data,responseCallback 以字典形式作为参数调用_doSend 方法，我们看一下_doSend 方法的实现:</p></blockquote><ul><li>doSend 方法内部会先判断入参中是否有回调</li><li>如果有回调则根据规则生成 callbackId 并且将回调 block 保存到 responseCallbacks字典，之后给消息也加入一个键值对保存刚才生成的 callbackId</li><li>给 sendMessageQueue 队列加入 message</li><li>messagingIframe.src 设置为 <a href="https://__wvjb_queue_message__" target="_blank" rel="noopener">https://__wvjb_queue_message__</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">messagingIframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">messagingIframe.style.display = &apos;none&apos;;</span><br><span class="line">messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + &apos;://&apos; + QUEUE_HAS_MESSAGE;</span><br><span class="line">document.documentElement.appendChild(messagingIframe);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>这里加入了一个 src 为 <a href="https://__wvjb_queue_message__" target="_blank" rel="noopener">https://__wvjb_queue_message__</a> 的 messagingIframe，它也是一个不可见的 iframe。这样 Native 端会收到一个 url 为 <a href="https://__wvjb_queue_message__" target="_blank" rel="noopener">https://__wvjb_queue_message__</a> 的 request，之后会进行各项判定，这次会满足[isQueueMessageURL：url]调用 Native 的MessageQueue 方法</p></blockquote><p>然后调用native端的核心方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">if ([_base isQueueMessageURL:url]) &#123;</span><br><span class="line">     NSString *messageQueueString = [self _evaluateJavascript:[_base webViewJavascriptFetchQueyCommand]];</span><br><span class="line">     //执行JS的fetchQueue方法，将JS的所有消息数组转为json然后清空数组</span><br><span class="line"></span><br><span class="line">     [_base flushMessageQueue:messageQueueString];//核心</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)flushMessageQueue:(NSString *)messageQueueString&#123;</span><br><span class="line">    ...</span><br><span class="line">    //将拿到的消息，解析</span><br><span class="line">    id messages = [self _deserializeMessageJSON:messageQueueString];</span><br><span class="line">    for (WVJBMessage* message in messages) &#123;</span><br><span class="line">        if (![message isKindOfClass:[WVJBMessage class]]) &#123;</span><br><span class="line">            NSLog(@&quot;WebViewJavascriptBridge: WARNING: Invalid %@ received: %@&quot;, [message class], message);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        [self _log:@&quot;RCVD&quot; json:message];</span><br><span class="line"></span><br><span class="line">        NSString* responseId = message[@&quot;responseId&quot;];</span><br><span class="line">        if (responseId) &#123;</span><br><span class="line">            WVJBResponseCallback responseCallback = _responseCallbacks[responseId];</span><br><span class="line">            responseCallback(message[@&quot;responseData&quot;]); //执行对应的responseBlock</span><br><span class="line">            [self.responseCallbacks removeObjectForKey:responseId];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            WVJBResponseCallback responseCallback = NULL;</span><br><span class="line">            NSString* callbackId = message[@&quot;callbackId&quot;];</span><br><span class="line">            if (callbackId) &#123;</span><br><span class="line">                responseCallback = ^(id responseData) &#123;</span><br><span class="line">                    if (responseData == nil) &#123;</span><br><span class="line">                        responseData = [NSNull null];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    WVJBMessage* msg = @&#123; @&quot;responseId&quot;:callbackId, @&quot;responseData&quot;:responseData &#125;;</span><br><span class="line">                    [self _queueMessage:msg];</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                responseCallback = ^(id ignoreResponseData) &#123;</span><br><span class="line">                    // Do nothing</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            //生成responseBlock</span><br><span class="line">            WVJBHandler handler = self.messageHandlers[message[@&quot;handlerName&quot;]];</span><br><span class="line"></span><br><span class="line">            if (!handler) &#123;</span><br><span class="line">                NSLog(@&quot;WVJBNoHandlerException, No handler for message from JS: %@&quot;, message);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //处理方法</span><br><span class="line">            handler(message[@&quot;data&quot;], responseCallback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>WebViewJavascriptBridge 的工作流：</p><ul><li>JS 端加入 src 为 <a href="https://__bridge_loaded__" target="_blank" rel="noopener">https://__bridge_loaded__</a> 的 iframe</li><li>Native 端检测到 Request，检测如果是 <strong>bridge_loaded</strong> 则通过当前的 WebView 组件注入 WebViewJavascriptBridge_JS 代码</li><li>注入代码成功之后会加入一个 messagingIframe，其 src 为 <a href="https://__wvjb_queue_message__" target="_blank" rel="noopener">https://__wvjb_queue_message__</a></li><li>之后不论是 Native 端还是 JS 端都可以通过 registerHandler 方法注册一个两端约定好的 HandlerName 的处理，也都可以通过 callHandler 方法通过约定好的 HandlerName 调用另一端的处理（两端处理消息的实现逻辑对称）</li></ul><h2 id="阅读文献"><a href="#阅读文献" class="headerlink" title="阅读文献"></a>阅读文献</h2><p>WebViewJavascriptBridge 源码中 Get 到的“桥梁美学”  <a href="http://www.10tiao.com/html/216/201712/2652556802/1.html" target="_blank" rel="noopener">http://www.10tiao.com/html/216/201712/2652556802/1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个库主要是作为iOS(mac)和JS之间的桥梁，对于双方来说使用都非常的便利&lt;/p&gt;
&lt;p&gt;文件结构非常简单，主要有三部分内容组成&lt;/p&gt;
&lt;p&gt;WebViewJavascriptBridge (UIWebView:ios &amp;amp;&amp;amp; WebView:mac)&lt;
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://pattyxp.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>2018Flag</title>
    <link href="https://pattyxp.github.io/2018/01/04/2018Flag/"/>
    <id>https://pattyxp.github.io/2018/01/04/2018Flag/</id>
    <published>2018-01-04T03:37:32.000Z</published>
    <updated>2018-01-11T02:48:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>今年初，创建下此博客，希望能够记录下自己的成长，工作之后感觉越来越懒了，需要监督自己了。<br>去年的时候记得也没有做什么特别的大事，只是出了趟国旅游，拿到了驾照，本来打算买车了，后面也没想法了。。。</p><p>生活Flag:<br>提高英语听说能力，坚持背单词，看美剧提高吧 ~ ~ ~<br>今年想要去趟成都旅游 ~ ~ ~</p><p>工作Flag:<br>多看点源码，学点新技术</p><p>今年就此在学习和生活上，都有个新的期待和变化吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今年初，创建下此博客，希望能够记录下自己的成长，工作之后感觉越来越懒了，需要监督自己了。&lt;br&gt;去年的时候记得也没有做什么特别的大事，只是出了趟国旅游，拿到了驾照，本来打算买车了，后面也没想法了。。。&lt;/p&gt;
&lt;p&gt;生活Flag:&lt;br&gt;提高英语听说能力，坚持背单词，看美剧
      
    
    </summary>
    
    
      <category term="生活" scheme="https://pattyxp.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>YYImage解析</title>
    <link href="https://pattyxp.github.io/2018/01/04/YYImage%E8%A7%A3%E6%9E%90/"/>
    <id>https://pattyxp.github.io/2018/01/04/YYImage解析/</id>
    <published>2018-01-04T03:00:02.000Z</published>
    <updated>2018-01-04T03:34:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>文件结构图如下:</p><p><img src="/images/YYImage文件结构.png" alt="YYImage文件结构"></p><h2 id="解析前api阅读实现思路"><a href="#解析前api阅读实现思路" class="headerlink" title="解析前api阅读实现思路:"></a>解析前api阅读实现思路:</h2><p>视图层<br>YYImage ：用于生成单张图片，可以根据图片的名称或者路径或者data实例化，接口和UIIImage相似<br>YYFrameImage: 用于记录一组图片，可以传入图片的数组、时间间隔数组，循环的次数，默认显示首图并初始化参数<br>YYSpriteSheetImage: 传入单张大图片，以及一组图片的每帧显示内容区域、图片显示的时间、循环的次数</p><p>显示层<br>YYAnimatedImageView</p><p>图片解码层<br>YYImageCoder</p><p>图片生成相对简单，对于多帧处理，以前很少接触，内存缓存和显示（编码解码方面）也都陌生些，<br>其实是有UIImageView来显示图片，动图可能含有多图或者多帧，所以需要动画来轮播，根据每张图片需要显示的动画时间来设置<br>阅读源码感受，实现比较优化，使用的预加载内存的方式提高效率，设置缓冲区，设置显示图片，如果没有就加入队列请求，开始重绘，播放动画。</p><p>##源码解读：</p><p>###YYImage</p><p><strong>支持的图片类型</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, YYImageType) &#123;</span><br><span class="line">    YYImageTypeUnknown = 0, ///&lt; unknown</span><br><span class="line">    YYImageTypeJPEG,        ///&lt; jpeg, jpg</span><br><span class="line">    YYImageTypeJPEG2000,    ///&lt; jp2</span><br><span class="line">    YYImageTypeTIFF,        ///&lt; tiff, tif</span><br><span class="line">    YYImageTypeBMP,         ///&lt; bmp</span><br><span class="line">    YYImageTypeICO,         ///&lt; ico</span><br><span class="line">    YYImageTypeICNS,        ///&lt; icns</span><br><span class="line">    YYImageTypeGIF,         ///&lt; gif</span><br><span class="line">    YYImageTypePNG,         ///&lt; png</span><br><span class="line">    YYImageTypeWebP,        ///&lt; webp</span><br><span class="line">    YYImageTypeOther,       ///&lt; other image format</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="YYFrameImage"><a href="#YYFrameImage" class="headerlink" title="YYFrameImage"></a>YYFrameImage</h3><p>专门用来显示基于帧的动画图像类<br>仅支持系统图片格式例如 png 和 jpeg<br>YYFrameImage 可以把静态图片类型如 png 和 jpeg 格式的静态图像用帧切换的方式以动态图片的形式显示，并且提供了 4 个常用的初始化方法方便我们使用。如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (nullable instancetype)initWithImagePaths:(NSArray&lt;NSString *&gt; *)paths</span><br><span class="line">                           oneFrameDuration:(NSTimeInterval)oneFrameDuration</span><br><span class="line">                                  loopCount:(NSUInteger)loopCount;</span><br><span class="line">- (nullable instancetype)initWithImagePaths:(NSArray&lt;NSString *&gt; *)paths</span><br><span class="line">                             frameDurations:(NSArray&lt;NSNumber *&gt; *)frameDurations</span><br><span class="line">                                  loopCount:(NSUInteger)loopCount;</span><br><span class="line">- (nullable instancetype)initWithImageDataArray:(NSArray&lt;NSData *&gt; *)dataArray</span><br><span class="line">                               oneFrameDuration:(NSTimeInterval)oneFrameDuration</span><br><span class="line">                                      loopCount:(NSUInteger)loopCount;</span><br><span class="line">- (nullable instancetype)initWithImageDataArray:(NSArray&lt;NSData *&gt; *)dataArray</span><br><span class="line">                                 frameDurations:(NSArray *)frameDurations</span><br><span class="line">                                      loopCount:(NSUInteger)loopCount;</span><br></pre></td></tr></table></figure></p><p>疑问code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)animatedImageFrameAtIndex:(NSUInteger)index &#123;</span><br><span class="line">    if (_imagePaths) &#123;</span><br><span class="line">        ...</span><br><span class="line">        return [[UIImage imageWithData:data scale:scale] imageByDecoded];</span><br><span class="line">        //Q:为什么需要实现imageByDecoded</span><br><span class="line">        //A:解码 否则只是先加载进入内存</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)imageByDecoded &#123;</span><br><span class="line">    if (self.isDecodedForDisplay) return self;//第一次decodecopy之后，下一次就不需要进行了</span><br><span class="line"></span><br><span class="line">    CGImageRef imageRef = self.CGImage;</span><br><span class="line">    if (!imageRef) return self;</span><br><span class="line"></span><br><span class="line">    CGImageRef newImageRef = YYCGImageCreateDecodedCopy(imageRef, YES);</span><br><span class="line">    if (!newImageRef) return self;</span><br><span class="line"></span><br><span class="line">    UIImage *newImage = [[self.class alloc] initWithCGImage:newImageRef scale:self.scale orientation:self.imageOrientation];</span><br><span class="line">    CGImageRelease(newImageRef);</span><br><span class="line">    if (!newImage) newImage = self; // decode failed, return self.</span><br><span class="line">    newImage.isDecodedForDisplay = YES;</span><br><span class="line">    return newImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###YYSpriteSheetImage<br>提供一个初始化方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (nullable instancetype)initWithSpriteSheetImage:(UIImage *)image</span><br><span class="line">                                     contentRects:(NSArray&lt;NSValue *&gt; *)contentRects</span><br><span class="line">                                   frameDurations:(NSArray&lt;NSNumber *&gt; *)frameDurations</span><br><span class="line">                                        loopCount:(NSUInteger)loopCount;</span><br><span class="line"></span><br><span class="line">一个实例方法</span><br><span class="line">- (CGRect)contentsRectForCALayerAtIndex:(NSUInteger)index;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (CGRect)contentsRectForCALayerAtIndex:(NSUInteger)index &#123;</span><br><span class="line">    CGRect layerRect = CGRectMake(0, 0, 1, 1);</span><br><span class="line">    if (index &gt;= _contentRects.count) return layerRect; //校验入参索引</span><br><span class="line"></span><br><span class="line">    CGSize imageSize = self.size;</span><br><span class="line">    CGRect rect = [self animatedImageContentsRectAtIndex:index];//找到对应索引的真实位置 RealRect</span><br><span class="line">    if (imageSize.width &gt; 0.01 &amp;&amp; imageSize.height &gt; 0.01) &#123;</span><br><span class="line">        layerRect.origin.x = rect.origin.x / imageSize.width;</span><br><span class="line">        layerRect.origin.y = rect.origin.y / imageSize.height;</span><br><span class="line">        layerRect.size.width = rect.size.width / imageSize.width;</span><br><span class="line">        layerRect.size.height = rect.size.height / imageSize.height;//得到指定索引帧的逻辑定位 LogicRect</span><br><span class="line">        layerRect = CGRectIntersection(layerRect, CGRectMake(0, 0, 1, 1));//确保逻辑定位没有超出画布的部分</span><br><span class="line">        if (CGRectIsNull(layerRect) || CGRectIsEmpty(layerRect)) &#123;</span><br><span class="line">            layerRect = CGRectMake(0, 0, 1, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return layerRect;//将处理后的逻辑定位 LogicRect 作为图层定位 LayerRect 返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">根据索引找到对应帧的 CALayer 位置，该接口返回一个由 0.0~1.0 之间的数值组成的图层定位 LayerRect</span><br></pre></td></tr></table></figure><p>###YYAnimatedImageView</p><h4 id="图片更改4步骤"><a href="#图片更改4步骤" class="headerlink" title="图片更改4步骤:"></a>图片更改4步骤:</h4><p>改变图片<br>重置动画<br>初始化动画参数<br>重绘</p><h4 id="YYAnimatedImageView"><a href="#YYAnimatedImageView" class="headerlink" title="YYAnimatedImageView"></a>YYAnimatedImageView</h4><p>使图片动起来是依靠 CADisplayLink</p><p>变量切换帧图像，其内部的实现逻辑可以简单理解为：<br>根据当前帧索引推出下一帧索引<br>使用下一帧索引去帧缓冲区尝试获取对应帧图像<br>如果找到对应帧图像则使用渲染绘制功能<br>如果没找到则根据条件向图片请求队列加入请求操作</p><h4 id="值得一提的实现细节"><a href="#值得一提的实现细节" class="headerlink" title="值得一提的实现细节"></a>值得一提的实现细节</h4><p>YYAnimatedImageView 实现<br>&gt;<br>对帧缓冲区_buffer 的操作都使用_lock 上锁<br>通过将图片请求队列_requestQueue 的 maxConcurrentOperationCount 设置为 1 使图片请求队列成为串行队列（最大并发数为 1）<br>图片请求队列中加入的操作均为_YYAnimatedImageViewFetchOperation<br>为了避免使用 CADisplayLink 可能造成的循环引用设计了_YYImageWeakProxy</p><p>YYAnimatedImageViewFetchOperation</p><p>####这里简单描述一下 main 函数内部实现逻辑：<br>&gt;<br>判断帧缓冲区大小<br>扫描下一帧以及当前允许缓冲范围内之后的帧图片<br>如果发现丢失的帧则尝试重新获取帧图像并加入到帧缓冲<br>操作中对于 view 缓冲区的操作也都上了锁<br>操作由于是放入图片请求队列中进行的，内部有对 isCancelled 做判断，如果操作已经被取消（发生在更改图片、停止动画、手动更改当前帧、收到内存警告或 App 进入后台等）则需要及时跳出<br>对于新的线程优先级只在 main 方法范围内有效，所以推荐把操作的实现放在 main 中而非 start（如需覆盖 start 方法时，需要关注 isExecuting 和 isFinished 两个 key paths）</p><h2 id="疑问code"><a href="#疑问code" class="headerlink" title="疑问code"></a>疑问code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> LOCK(</span><br><span class="line">         if (_buffer.count) &#123;</span><br><span class="line">             NSMutableDictionary *holder = _buffer;</span><br><span class="line">             _buffer = [NSMutableDictionary new];</span><br><span class="line">             dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;</span><br><span class="line">                 // Capture the dictionary to global queue,</span><br><span class="line">                 // release these images in background to avoid blocking UI thread.</span><br><span class="line">                 [holder class];</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">    );</span><br><span class="line">Q:怎么做到的  [holder class]怎么就能够release these images</span><br><span class="line">A: 每个异步线程，其实内部都有一个对应的autoreleasePool，当执行 [holder class]，这个holder类就被放进了当前的线程池，当方法结束，线程池就将改对象进行释放，因此buffer里的数据也就慢慢清掉了，缓存的图片数据就不占用内存空间了</span><br></pre></td></tr></table></figure><p>##扩展 NSOperation</p><ul><li><p>执行主任务</p><blockquote><p>从最低限度上来说，每一个 operation 都应该至少实现以下两个方法：<br>1.一个自定义的初始化方法；<br>2.main 方法。</p></blockquote></li><li><p>响应取消事件</p></li></ul><blockquote><p>当一个 operation 开始执行后，它会一直执行它的任务直到完成或被取消为止。我们可以在任意时间点取消一个 operation ，甚至是在它还未开始执行之前。为了让我们自定义的 operation 能够支持取消事件，我们需要在代码中定期地检查 isCancelled 方法的返回值，一旦检查到这个方法返回 YES ，我们就需要立即停止执行接下来的任务。根据苹果官方的说法，isCancelled 方法本身是足够轻量的，所以就算是频繁地调用它也不会给系统带来太大的负担。<br>The isCancelled method itself is very lightweight and can be called frequently without any significant performance penalty.<br>通常来说，当我们自定义一个 operation 类时，我们需要考虑在以下几个关键点检查 isCancelled 方法的返回值：<br>在真正开始执行任务之前；<br>至少在每次循环中检查一次，而如果一次循环的时间本身就比较长的话，则需要检查得更加频繁；<br>在任何相对来说比较容易中止 operation 的地方。<br>看到这里，我想你应该可以意识到一点，那就是尽管 operation 是支持取消操作的，但却并不是立即取消的，而是在你调用了 operation 的 cancel 方法之后的下一个 isCancelled 的检查点取消的。</p></blockquote><h2 id="YYImageCoder-源码解析"><a href="#YYImageCoder-源码解析" class="headerlink" title="YYImageCoder  源码解析"></a>YYImageCoder  源码解析</h2><p>主要就是对于图片的解压缩，解压缩到位图才能够正常的渲染，但是图片的解压缩一般都在显示的时候才会去做而且是在主线程，非常耗CPU，所以需要提前在子线程先进行解压缩操作是非常必要的</p><p>这里主要就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CG_EXTERN CGContextRef __nullable CGBitmapContextCreate(void * __nullable data,</span><br><span class="line">    size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow,</span><br><span class="line">    CGColorSpaceRef cg_nullable space, uint32_t bitmapInfo)</span><br><span class="line">    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);</span><br></pre></td></tr></table></figure></p><ul><li>data ：如果不为 NULL ，那么它应该指向一块大小至少为 bytesPerRow * height 字节的内存；如果 为 NULL ，那么系统就会为我们自动分配和释放所需的内存，所以一般指定 NULL 即可；</li><li>width 和 height ：位图的宽度和高度，分别赋值为图片的像素宽度和像素高度即可；</li><li>bitsPerComponent ：像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可；</li><li>bytesPerRow ：位图的每一行使用的字节数，大小至少为 width * bytes per pixel 字节。有意思的是，当我们指定 0 时，系统不仅会为我们自动计算，而且还会进行 cache line alignment 的优化，更多信息可以查看 what is byte alignment (cache line alignment) for Core Animation? Why it matters? 和 Why is my image’s Bytes per Row more than its Bytes per Pixel times its Width? ，亲测可用；</li><li>space ：就是我们前面提到的颜色空间，一般使用 RGB 即可；</li><li>bitmapInfo ：就是我们前面提到的位图的布局信息。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>图片动图的切换绘制，使用递归锁，信号量,线程和缓冲区提高效率<br>支持的图片类型非常丰富<br>编码解码看着很复杂，绘图</p><p>代码封装性好，接口很简单，实现很逻辑</p><h2 id="阅读链接"><a href="#阅读链接" class="headerlink" title="阅读链接"></a>阅读链接</h2><p><a href="http://www.jianshu.com/p/9601a4b8d01c" target="_blank" rel="noopener">http://www.jianshu.com/p/9601a4b8d01c</a></p><p><a href="http://www.leichunfeng.com/" target="_blank" rel="noopener">http://www.leichunfeng.com/</a></p><p>YYImagecoder源码解析:<a href="http://www.jianshu.com/p/b1750084c7a5" target="_blank" rel="noopener">http://www.jianshu.com/p/b1750084c7a5</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文件结构图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/YYImage文件结构.png&quot; alt=&quot;YYImage文件结构&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;解析前api阅读实现思路&quot;&gt;&lt;a href=&quot;#解析前api阅读实现思路&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://pattyxp.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MJRefresh解析</title>
    <link href="https://pattyxp.github.io/2018/01/04/MJRefresh%E8%A7%A3%E6%9E%90/"/>
    <id>https://pattyxp.github.io/2018/01/04/MJRefresh解析/</id>
    <published>2018-01-04T02:53:46.000Z</published>
    <updated>2018-01-04T03:34:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析前阅读api"><a href="#解析前阅读api" class="headerlink" title="解析前阅读api"></a>解析前阅读api</h2><p>MJRefreshComponent.h</p><p>1.MJRefreshState 有5个状态，如果我设计，只会想到4个， willRefresh和 pulling状态会认为是一致的<br>2.刚开始看的时候，觉得监听只需要contentOffset和pan手势就够了</p><p>解析前总结：<br>设计一个UIView，把刷新控件都初始化好，然后状态就根据拖动刷新的状态去更新就好了。<br>依据拖动的手势和位移，修改父类scrollView的contentSize，显示刷新控件和隐藏控件，调用刷新的方法和回调方法即可。</p><h2 id="疑问code"><a href="#疑问code" class="headerlink" title="疑问code"></a>疑问code</h2><p>beginRefreshing方法里，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (self.window) &#123;</span><br><span class="line">    self.state = MJRefreshStateRefreshing;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有时候window为null，原因是view没有完全加载完成或者在ViewDidload中才刚刚加载完,view的window属性无法被获取<br>正确应该使用UIApplication.keywindow</p><h2 id="文件结构功能图-Github上已有-http-t-cn-RYHwK6n"><a href="#文件结构功能图-Github上已有-http-t-cn-RYHwK6n" class="headerlink" title="文件结构功能图 Github上已有(http://t.cn/RYHwK6n)"></a>文件结构功能图 Github上已有(<a href="http://t.cn/RYHwK6n" target="_blank" rel="noopener">http://t.cn/RYHwK6n</a>)</h2><p><strong>MJRefreshComponent</strong> 这个类作为该控件的基类，涵盖了基类所具备的一些：状态，回调block，子类继承的方法等</p><p>##Header<br><strong>MJRefreshHeader</strong>    MJRefreshHeader继承于MJRefreshComponent，它做了这几件事：初始化方法，初始化y和高度，状态切换等</p><p>疑问点:<br>一开始不明白基类MJRefreshComponent为什么申明的状态有五个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** 刷新控件的状态 */</span><br><span class="line">typedef NS_ENUM(NSInteger, MJRefreshState) &#123;</span><br><span class="line">    /** 普通闲置状态 */</span><br><span class="line">    MJRefreshStateIdle = 1,</span><br><span class="line">    /** 松开就可以进行刷新的状态 */</span><br><span class="line">    MJRefreshStatePulling,</span><br><span class="line">    /** 正在刷新中的状态 */</span><br><span class="line">    MJRefreshStateRefreshing,</span><br><span class="line">    /** 即将刷新的状态 */</span><br><span class="line">    MJRefreshStateWillRefresh,</span><br><span class="line">    /** 所有数据加载完毕，没有更多的数据了 */</span><br><span class="line">    MJRefreshStateNoMoreData</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>以为MJRefreshStatePulling是多余的，我设计的话应该只会有4个，<br>现在明白了，header刷新的时候，状态切换的因素有两个：一个是下拉的距离是否超过临界值，另一个是 手指是否离开屏幕。<br>即使在下拉的距离超过了临界距离（状态栏 + 导航栏 + header高度），如果手指没有离开屏幕，那么也不能马上进行刷新，而是将状态切换为：可以刷新。<br>一旦手指离开了屏幕，马上将状态切换为正在刷新。</p><p><strong>MJRefreshStateHeader</strong> 带有状态文字的刷新控件<br>stateLabel 和 lastUpdatedTimeLabel ，根据状态的切换变化内容，显示时间的label还可以依据用户自定义的日期格式显示，<br>lastUpdatedTimeLabel可以隐藏</p><p><strong>MJRefreshNormalHeader</strong> 带有_arrowView和loadingView<br>根据刷新的state来隐藏和显示这两个视图</p><p><strong>MJRefreshGifHeader</strong> 左侧是一个gif动画<br>可以根据不同状态配置不同的照片和动画时间</p><p>##Footer</p><p><strong>MJRefreshFooter:</strong><br>与header相比，只是多了设置MJRefreshStateNoMoreData状态</p><p>提供以下几个功能:<br>初始化视图<br>没有数据时候重设对应状态<br>没有数据时候对应的操作<br>是否支持自动隐藏视图，如果支持，将替换系统的reloadData方法为自定义的方法，内部实现是多执行一句mj_reloadDataBlock回调</p><p>在视图添加或者移除的时候，设置setMj_reloadDataBlock方法，之前奇怪为什么header的时候没有，这个功能是为了刷新数据结束的时候根据当前的cell个数（tableview或collectionview的数据源为空）来判断是否需要隐藏footerView</p><p><strong>MJRefreshBackFooter</strong> 需要上拉才会触发刷新动作<br>当状态结束，恢复初始状态 （？？？ 回弹体现什么）<br><strong>MJRefreshAutoFooter</strong> 自动上拉加载类。滑动到底部触发刷新动作，无需上拉操作。<br>triggerAutomaticallyRefreshPercent 底部控件出现多少就开始自动刷新<br>automaticallyRefresh 是否自动刷新，默认YES</p><p><strong>MJRefreshBackStateFooter</strong> 提供label ，可以设置不同状态下的标签内容<br><strong>MJRefreshBackNormalFooter</strong> 提供箭头和loading圆圈，根据状态显示和隐藏<br><strong>MJRefreshBackGifFooter</strong> 提供设置gif动画的一组图片</p><p><strong>MJRefreshAutoStateFooter</strong> 相比较MJRefreshBackStateFooter，给stateLabel添加了手势，当点击的时候如果当前是默认状态就执行刷新<br><strong>MJRefreshAutoNormalFooter</strong> 提供箭头和loading圆圈，根据状态显示和隐藏<br><strong>MJRefreshAutoGifFooter</strong> 提供设置gif动画的一组图片</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MJRefreshHeader: 负责header的高度和调整header自身在外部的位置。<br>MJRefreshStateHeader:负责header内部的stateLabel和lastUpdatedTimeLabel的布局和不同状态下内部文字的显示。<br>MJRefreshNormalHeader:负责header内部的loadingView以及arrowView的布局和不同状态下的显示。<br>MJRefreshGifHeader:负责header内部的Gif动画的布局和不同状态下的显示。</p><p>MJRefreshFooter: 负责footer高度和监听scrollView数据的变化<br>MJRefreshBackFooter:跟Header的封装思路是一样的<br>MJRefreshAutoFooter:类似于MJRefreshHeader类的功能</p><p>以下设计思路和对应的header一致<br>MJRefreshBackStateFooter：封装思路类似于MJRefreshStateHeader<br>MJRefreshBackNormalFooter：封装思路类似于MJRefreshNormalHeader<br>MJRefreshBackGifFooter：封装思路类似于MJRefreshGifHeader<br>MJRefreshAutoStateFooter：封装思路类似于MJRefreshStateHeader<br>MJRefreshAutoNormalFooter：封装思路类似于MJRefreshNormalHeader<br>MJRefreshAutoGifFooter：封装思路类似于MJRefreshGifHeader</p><p>通过一个基类来定义一些状态和一些需要子类实现的接口。通过一层一层地继承，让每一层的子类各司其职，只完成真正属于自己的任务，提高了框架的可定制性，而且对于功能的扩展和bug的追踪也很有帮助，非常值得我们参考与借鉴。</p><p>##优秀code</p><p>1.很多地方设置控件的frame的时候，都是通过先判断其约束的个数如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (self.lastUpdatedTimeLabel.constraints.count == 0) &#123;&#125;</span><br></pre></td></tr></table></figure><p>然后再设置约束，就比较仔细</p><p>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MJRefreshCheckState 状态检查，通过宏来与之前状态比较，一样就return</span><br></pre></td></tr></table></figure></p><p>3.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">willMoveToSuperview方法，在里面判断移除之前的观察者</span><br></pre></td></tr></table></figure></p><p>4.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)mj_textWith &#123;</span><br><span class="line">    CGFloat stringWidth = 0;</span><br><span class="line">    CGSize size = CGSizeMake(MAXFLOAT, MAXFLOAT);</span><br><span class="line">    if (self.text.length &gt; 0) &#123;</span><br><span class="line">#if defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000</span><br><span class="line">        stringWidth =[self.text</span><br><span class="line">                      boundingRectWithSize:size</span><br><span class="line">                      options:NSStringDrawingUsesLineFragmentOrigin</span><br><span class="line">                      attributes:@&#123;NSFontAttributeName:self.font&#125;</span><br><span class="line">                      context:nil].size.width;</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">        stringWidth = [self.text sizeWithFont:self.font</span><br><span class="line">                             constrainedToSize:size</span><br><span class="line">                                 lineBreakMode:NSLineBreakByCharWrapping].width;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">    return stringWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.多语言设置</p><h2 id="阅读资料："><a href="#阅读资料：" class="headerlink" title="阅读资料："></a>阅读资料：</h2><p><a href="http://www.jianshu.com/p/89ca6437c5e9" target="_blank" rel="noopener">http://www.jianshu.com/p/89ca6437c5e9</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析前阅读api&quot;&gt;&lt;a href=&quot;#解析前阅读api&quot; class=&quot;headerlink&quot; title=&quot;解析前阅读api&quot;&gt;&lt;/a&gt;解析前阅读api&lt;/h2&gt;&lt;p&gt;MJRefreshComponent.h&lt;/p&gt;
&lt;p&gt;1.MJRefreshState 有
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://pattyxp.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建</title>
    <link href="https://pattyxp.github.io/2018/01/02/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://pattyxp.github.io/2018/01/02/博客搭建/</id>
    <published>2018-01-02T09:43:15.000Z</published>
    <updated>2018-01-04T03:32:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>之前一直有在收集一些大神的博客，自己也肖想了一把建立自己的博客地址，于是乎就有了个开端</p><p>在此之前，我也是小白一枚啊，遇到了一些非常浅显的坑，但是一直没有发现导致纠结了一下，整个整下来大概花了2小时吧 ~ ~ ~</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>首先安装些必备的环境是分分钟的事情啦，网上有相关教程的，如有问题请自行google</p><ul><li>Node.js</li><li><p>Git (Xcode自带，可以绕行)</p></li><li><p>当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：<br>$ sudo npm install -g hexo</p></li><li><p>初始化</p></li></ul><p>本地自己建立存放的文件夹，cd到当前文件目录下，执行以下命令<br>$ hexo init xxx (xxx 是你建立的文件夹名称。cd到xxx文件夹下，执行如下命令，安装npm：)<br>$ npm install<br>执行如下命令，开启hexo服务器:<br>$ hexo s<br>此时，浏览器中打开网址<a href="http://localhost:4000，" target="_blank" rel="noopener">http://localhost:4000，</a><br>能看到helloWorld的页面，此时本地显示已经OK<br>效果如图:<br><img src="/images/初建博客.png" alt="效果如图"></p><ul><li>管理github<br>建立自己的github账号之后，将mac下的ssh内容上传到setting里相应的位置<br>选择新建一个responsity，注意，命名非常重要，我就是在这里被卡了一小时的感觉<br>比如我的Github名称是pattyXP,但是建立的仓库名称，需要符合规则: github名称.github.io ，我一开始写错了，写成了patty.github.io，为此哀伤一下下 ~ ~ ~<br>然后，进入到该仓库的主页下，选择setting，滑到GitHub Pages一级，将source选择为master，点击save，这是为什么呢？（因为之前在本地文件下有一个.yml，打开后往下滑到最后，修改成下边的样子：<br>deploy:<br>  type: git<br>  repository: <a href="https://github.com/pattyXP/pattyXP.github.io.git" target="_blank" rel="noopener">https://github.com/pattyXP/pattyXP.github.io.git</a><br> branch: master）<br>然后打开自己的<a href="https://pattyxp.github.io/">https://pattyxp.github.io/</a><br>效果就和本地的localhost:4000一模一样了(😅)</li></ul><h2 id="后面的维护"><a href="#后面的维护" class="headerlink" title="后面的维护"></a>后面的维护</h2><p>hexo支持markdown语法，所以本地的文章可以使用markdown语法来编写，之后保存为xx.md即可，放在博客的文件夹下的source/_posts/xx.md即可<br>最后，执行如下命令就可以上传成功了<br>hexo new xxx<br>hexo g （生成静态页面）<br>hexo d  (将文章部署到Github)</p><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p>可能还需要用到的命令<br>hexo clean<br>hexo d -g</p><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><p>博客搭建教程: <a href="http://jeasonstudio.github.io" target="_blank" rel="noopener">http://jeasonstudio.github.io</a><br>博客主题搭建: <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a><br>博客主题定制化: <a href="http://shenzekun.cn/" target="_blank" rel="noopener">http://shenzekun.cn/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;p&gt;之前一直有在收集一些大神的博客，自己也肖想了一把建立自己的博客地址，于是乎就有了个开端&lt;/p&gt;
&lt;p&gt;在此之前，我也是小白一枚啊，遇到了一些
      
    
    </summary>
    
    
      <category term="工具" scheme="https://pattyxp.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
