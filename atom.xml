<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温暖的弦</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pattyxp.github.io/"/>
  <updated>2018-01-04T02:54:01.000Z</updated>
  <id>https://pattyxp.github.io/</id>
  
  <author>
    <name>Patty</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MJRefresh解析</title>
    <link href="https://pattyxp.github.io/2018/01/04/MJRefresh%E8%A7%A3%E6%9E%90/"/>
    <id>https://pattyxp.github.io/2018/01/04/MJRefresh解析/</id>
    <published>2018-01-04T02:53:46.000Z</published>
    <updated>2018-01-04T02:54:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析前阅读api"><a href="#解析前阅读api" class="headerlink" title="解析前阅读api"></a>解析前阅读api</h2><p>MJRefreshComponent.h</p><p>1.<br>MJRefreshState 有5个状态，我设计的话，肯定只有4个，在 willRefresh和 pulling状态，我会认为是一样的<br>2.刚开始看的时候，觉得监听只需要contentOffset和pan手势就够了</p><p>总结：<br>设计一个UIView，把刷新控件都初始化好，然后状态就根据拖动刷新的状态去更新就好了。<br>依据拖动的手势和位移，修改父类scrollView的contentSize，显示刷新控件和隐藏控件，调用刷新的方法和回调方法即可。</p><h2 id="疑问code"><a href="#疑问code" class="headerlink" title="疑问code"></a>疑问code</h2><p>beginRefreshing方法里，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (self.window) &#123;</span><br><span class="line">    self.state = MJRefreshStateRefreshing;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有时候window为null，原因是view没有完全加载完成或者在ViewDidload中才刚刚加载完,view的window属性无法被获取<br>正确应该使用UIApplication.keywindow</p><h2 id="文件结构功能图-Github上已有-http-t-cn-RYHwK6n"><a href="#文件结构功能图-Github上已有-http-t-cn-RYHwK6n" class="headerlink" title="文件结构功能图 Github上已有(http://t.cn/RYHwK6n)"></a>文件结构功能图 Github上已有(<a href="http://t.cn/RYHwK6n" target="_blank" rel="noopener">http://t.cn/RYHwK6n</a>)</h2><p><strong>MJRefreshComponent</strong> 这个类作为该控件的基类，涵盖了基类所具备的一些：状态，回调block，子类继承的方法等</p><p>##Header<br><strong>MJRefreshHeader</strong>    MJRefreshHeader继承于MJRefreshComponent，它做了这几件事：初始化方法，初始化y和高度，状态切换等</p><p>疑问点:<br>一开始不明白基类MJRefreshComponent为什么申明的状态有五个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** 刷新控件的状态 */</span><br><span class="line">typedef NS_ENUM(NSInteger, MJRefreshState) &#123;</span><br><span class="line">    /** 普通闲置状态 */</span><br><span class="line">    MJRefreshStateIdle = 1,</span><br><span class="line">    /** 松开就可以进行刷新的状态 */</span><br><span class="line">    MJRefreshStatePulling,</span><br><span class="line">    /** 正在刷新中的状态 */</span><br><span class="line">    MJRefreshStateRefreshing,</span><br><span class="line">    /** 即将刷新的状态 */</span><br><span class="line">    MJRefreshStateWillRefresh,</span><br><span class="line">    /** 所有数据加载完毕，没有更多的数据了 */</span><br><span class="line">    MJRefreshStateNoMoreData</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>以为MJRefreshStatePulling是多余的，我设计的话应该只会有4个，<br>现在明白了，header刷新的时候，状态切换的因素有两个：一个是下拉的距离是否超过临界值，另一个是 手指是否离开屏幕。<br>即使在下拉的距离超过了临界距离（状态栏 + 导航栏 + header高度），如果手指没有离开屏幕，那么也不能马上进行刷新，而是将状态切换为：可以刷新。<br>一旦手指离开了屏幕，马上将状态切换为正在刷新。</p><p><strong>MJRefreshStateHeader</strong> 带有状态文字的刷新控件<br>stateLabel 和 lastUpdatedTimeLabel ，根据状态的切换变化内容，显示时间的label还可以依据用户自定义的日期格式显示，<br>lastUpdatedTimeLabel可以隐藏</p><p><strong>MJRefreshNormalHeader</strong> 带有_arrowView和loadingView<br>根据刷新的state来隐藏和显示这两个视图</p><p><strong>MJRefreshGifHeader</strong> 左侧是一个gif动画<br>可以根据不同状态配置不同的照片和动画时间</p><p>##Footer</p><p><strong>MJRefreshFooter:</strong><br>与header相比，只是多了设置MJRefreshStateNoMoreData状态</p><p>提供以下几个功能:<br>初始化视图<br>没有数据时候重设对应状态<br>没有数据时候对应的操作<br>是否支持自动隐藏视图，如果支持，将替换系统的reloadData方法为自定义的方法，内部实现是多执行一句mj_reloadDataBlock回调</p><p>在视图添加或者移除的时候，设置setMj_reloadDataBlock方法，之前奇怪为什么header的时候没有，这个功能是为了刷新数据结束的时候根据当前的cell个数（tableview或collectionview的数据源为空）来判断是否需要隐藏footerView</p><p><strong>MJRefreshBackFooter</strong> 需要上拉才会触发刷新动作<br>当状态结束，恢复初始状态 （？？？ 回弹体现什么）<br><strong>MJRefreshAutoFooter</strong> 自动上拉加载类。滑动到底部触发刷新动作，无需上拉操作。<br>triggerAutomaticallyRefreshPercent 底部控件出现多少就开始自动刷新<br>automaticallyRefresh 是否自动刷新，默认YES</p><p><strong>MJRefreshBackStateFooter</strong> 提供label ，可以设置不同状态下的标签内容<br><strong>MJRefreshBackNormalFooter</strong> 提供箭头和loading圆圈，根据状态显示和隐藏<br><strong>MJRefreshBackGifFooter</strong> 提供设置gif动画的一组图片</p><p><strong>MJRefreshAutoStateFooter</strong> 相比较MJRefreshBackStateFooter，给stateLabel添加了手势，当点击的时候如果当前是默认状态就执行刷新<br><strong>MJRefreshAutoNormalFooter</strong>提供箭头和loading圆圈，根据状态显示和隐藏<br><strong>MJRefreshAutoGifFooter</strong>提供设置gif动画的一组图片</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MJRefreshHeader: 负责header的高度和调整header自身在外部的位置。<br>MJRefreshStateHeader:负责header内部的stateLabel和lastUpdatedTimeLabel的布局和不同状态下内部文字的显示。<br>MJRefreshNormalHeader:负责header内部的loadingView以及arrowView的布局和不同状态下的显示。<br>MJRefreshGifHeader:负责header内部的Gif动画的布局和不同状态下的显示。</p><p>MJRefreshFooter: 负责footer高度和监听scrollView数据的变化<br>MJRefreshBackFooter:跟Header的封装思路是一样的<br>MJRefreshAutoFooter:类似于MJRefreshHeader类的功能</p><p>以下设计思路和对应的header一致<br>MJRefreshBackStateFooter：封装思路类似于MJRefreshStateHeader<br>MJRefreshBackNormalFooter：封装思路类似于MJRefreshNormalHeader<br>MJRefreshBackGifFooter：封装思路类似于MJRefreshGifHeader<br>MJRefreshAutoStateFooter：封装思路类似于MJRefreshStateHeader<br>MJRefreshAutoNormalFooter：封装思路类似于MJRefreshNormalHeader<br>MJRefreshAutoGifFooter：封装思路类似于MJRefreshGifHeader</p><p>通过一个基类来定义一些状态和一些需要子类实现的接口。通过一层一层地继承，让每一层的子类各司其职，只完成真正属于自己的任务，提高了框架的可定制性，而且对于功能的扩展和bug的追踪也很有帮助，非常值得我们参考与借鉴。</p><p>##优秀code</p><p>1.很多地方设置控件的frame的时候，都是通过先判断其约束的个数如<br><figure class="highlight plain"><figcaption><span>(self.lastUpdatedTimeLabel.constraints.count </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">然后再设置约束，就比较仔细</span><br><span class="line"></span><br><span class="line">2.</span><br></pre></td></tr></table></figure></p><p>MJRefreshCheckState 状态检查，通过宏来与之前状态比较，一样就return<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3.</span><br></pre></td></tr></table></figure></p><p>willMoveToSuperview方法，在里面判断移除之前的观察者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4.</span><br></pre></td></tr></table></figure></p><ul><li><p>(CGFloat)mj_textWith {<br>  CGFloat stringWidth = 0;<br>  CGSize size = CGSizeMake(MAXFLOAT, MAXFLOAT);<br>  if (self.text.length &gt; 0) {<br>#if defined(<strong>IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; </strong>IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000</p><pre><code>stringWidth =[self.text              boundingRectWithSize:size              options:NSStringDrawingUsesLineFragmentOrigin              attributes:@{NSFontAttributeName:self.font}              context:nil].size.width;</code></pre><p>#else</p><pre><code>stringWidth = [self.text sizeWithFont:self.font                     constrainedToSize:size                         lineBreakMode:NSLineBreakByCharWrapping].width;</code></pre><p>#endif<br>  }<br>  return stringWidth;<br>}<br>```<br>5.<br>多语言设置</p></li></ul><h2 id="阅读资料："><a href="#阅读资料：" class="headerlink" title="阅读资料："></a>阅读资料：</h2><p><a href="http://www.jianshu.com/p/89ca6437c5e9" target="_blank" rel="noopener">http://www.jianshu.com/p/89ca6437c5e9</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析前阅读api&quot;&gt;&lt;a href=&quot;#解析前阅读api&quot; class=&quot;headerlink&quot; title=&quot;解析前阅读api&quot;&gt;&lt;/a&gt;解析前阅读api&lt;/h2&gt;&lt;p&gt;MJRefreshComponent.h&lt;/p&gt;
&lt;p&gt;1.&lt;br&gt;MJRefreshSta
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博客搭建</title>
    <link href="https://pattyxp.github.io/2018/01/02/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://pattyxp.github.io/2018/01/02/博客搭建/</id>
    <published>2018-01-02T09:43:15.000Z</published>
    <updated>2018-01-04T02:49:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>之前一直有在收集一些大神的博客，自己也肖想了一把建立自己的博客地址，于是乎就有了个开端</p><p>在此之前，我也是小白一枚啊，遇到了一些非常浅显的坑，但是一直没有发现导致纠结了一下，整个整下来大概花了2小时吧 ~ ~ ~</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>首先安装些必备的环境是分分钟的事情啦，网上有相关教程的，如有问题请自行google</p><ul><li>Node.js</li><li><p>Git (Xcode自带，可以绕行)</p></li><li><p>当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：<br>$ sudo npm install -g hexo</p></li><li><p>初始化</p></li></ul><p>本地自己建立存放的文件夹，cd到当前文件目录下，执行以下命令<br>$ hexo init xxx (xxx 是你建立的文件夹名称。cd到xxx文件夹下，执行如下命令，安装npm：)<br>$ npm install<br>执行如下命令，开启hexo服务器:<br>$ hexo s<br>此时，浏览器中打开网址<a href="http://localhost:4000，" target="_blank" rel="noopener">http://localhost:4000，</a><br>能看到helloWorld的页面，此时本地显示已经OK</p><ul><li>管理github<br>建立自己的github账号之后，将mac下的ssh内容上传到setting里相应的位置<br>选择新建一个responsity，注意，命名非常重要，我就是在这里被卡了一小时的感觉<br>比如我的Github名称是pattyXP,但是建立的仓库名称，需要符合规则: github名称.github.io ，我一开始写错了，写成了patty.github.io，为此哀伤一下下 ~ ~ ~<br>然后，进入到该仓库的主页下，选择setting，滑到GitHub Pages一级，将source选择为master，点击save，这是为什么呢？（因为之前在本地文件下有一个.yml，打开后往下滑到最后，修改成下边的样子：<br>deploy:<br>  type: git<br>  repository: <a href="https://github.com/pattyXP/pattyXP.github.io.git" target="_blank" rel="noopener">https://github.com/pattyXP/pattyXP.github.io.git</a><br> branch: master）<br>然后打开自己的<a href="https://pattyxp.github.io/">https://pattyxp.github.io/</a><br>效果就和本地的localhost:4000一模一样了(😅)</li></ul><h2 id="后面的维护"><a href="#后面的维护" class="headerlink" title="后面的维护"></a>后面的维护</h2><p>hexo支持markdown语法，所以本地的文章可以使用markdown语法来编写，之后保存为xx.md即可，放在博客的文件夹下的source/_posts/xx.md即可<br>最后，执行如下命令就可以上传成功了<br>hexo new xxx<br>hexo g （生成静态页面）<br>hexo d  (将文章部署到Github)</p><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p>可能还需要用到的命令<br>hexo clean<br>hexo d -g</p><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><p>博客搭建教程: <a href="http://jeasonstudio.github.io" target="_blank" rel="noopener">http://jeasonstudio.github.io</a><br>博客主题搭建: <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a><br>博客主题定制化: <a href="http://shenzekun.cn/" target="_blank" rel="noopener">http://shenzekun.cn/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;p&gt;之前一直有在收集一些大神的博客，自己也肖想了一把建立自己的博客地址，于是乎就有了个开端&lt;/p&gt;
&lt;p&gt;在此之前，我也是小白一枚啊，遇到了一些
      
    
    </summary>
    
    
      <category term="工具" scheme="https://pattyxp.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
