<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温暖的弦</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pattyxp.github.io/"/>
  <updated>2018-07-03T14:58:17.728Z</updated>
  <id>https://pattyxp.github.io/</id>
  
  <author>
    <name>Patty</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WWDC-Notification</title>
    <link href="https://pattyxp.github.io/2018/07/02/WWDC-Notification/"/>
    <id>https://pattyxp.github.io/2018/07/02/WWDC-Notification/</id>
    <published>2018-07-02T13:00:00.000Z</published>
    <updated>2018-07-03T14:58:17.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2018年WWDC召开至今， 围绕User Notification相关的iOS12特性介绍非常多<br>此次主要是针对用户体验带来的分组通知特性及相关的交互，下面围绕以下几点展开说明</p><ul><li>Grouped Notifications</li><li>Notification content extensions</li><li>Notification management</li><li>Provisional authorization</li><li>Critical alerts</li></ul><h3 id="Grouped-Notifications"><a href="#Grouped-Notifications" class="headerlink" title="Grouped Notifications"></a>Grouped Notifications</h3><p><img src="/images/WWDC-group1.png" alt="WWDC-group1"></p><p>iOS12 之后</p><p><img src="/images/WWDC-group2.png" alt="WWDC-group2"></p><p>同一APP的通知可被合成一个通知组，点击可以展开组里的通知<br>通知的分组可以采用两种方式实现:</p><ul><li>自动实现 （Automatic grouping）系统根据APP的bundle id 分组，开发者不需要进行额外操作</li><li>线程标识 （Thread identifier） <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本地通知</span></span><br><span class="line"><span class="keyword">let</span> content = <span class="type">UNMutableNotificationContent</span>()</span><br><span class="line">content.title = <span class="string">"New Photo"</span></span><br><span class="line">content.body = <span class="string">"Jane Doe posted a new photo"</span></span><br><span class="line">content.threadIdentifier = <span class="string">"thread-identifier"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程通知</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aps"</span> : &#123;</span><br><span class="line">        <span class="string">"alert"</span> : &#123;</span><br><span class="line">            <span class="string">"title"</span> : <span class="string">"New Photo"</span>,</span><br><span class="line">            <span class="string">"body"</span> : <span class="string">"Jane Doe posted a new photo"</span>,</span><br><span class="line">            <span class="string">"thread-id"</span> : <span class="string">"thread-identifier"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/WWDC-group3.png" alt="WWDC-group3"></p><p>用户可以在设置里控制管理方式<br><img src="/images/WWDC-group4.png" alt="WWDC-group4"><br><img src="/images/WWDC-group5.png" alt="WWDC-group5"></p><h3 id="Notification-content-extensions"><a href="#Notification-content-extensions" class="headerlink" title="Notification content extensions"></a>Notification content extensions</h3><p>此特性在iOS 10就出现了,用于自定义通知视图的样式,在iOS 12上针对此做了提升</p><p><img src="/images/WWDC-group12.png" alt="WWDC-group12"></p><ul><li>在plist中设置属性，会影响通知界面的交互功能</li></ul><p><img src="/images/WWDC-group13.png" alt="WWDC-group13"></p><p><img src="/images/WWDC-group14.png" alt="WWDC-group14"></p><ul><li>默认中间部分交互是没有的，需要在plist表中增加属性<code>UNNotificationExtensionUserInteractionEnabled</code>为<code>YES</code></li></ul><p><img src="/images/WWDC-group15.png" alt="WWDC-group15"></p><ul><li>notificationActions<br><code>notificationActions</code>允许获取用户当前的操作，更新新的操作</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSExtensionContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">12.0</span>, *)</span><br><span class="line">    <span class="keyword">var</span> notificationActions: [<span class="type">UNNotificationAction</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notification Content Extensions</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationViewController</span>: <span class="title">UIViewController</span>, <span class="title">UNNotificationContentExtension</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> response: UNNotificationResponse, completionHandler completion:</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="params">(UNNotificationContentExtensionResponseOption)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> response.actionIdentifier == <span class="string">"like-action"</span> &#123;</span><br><span class="line">            <span class="comment">// Update state...</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> unlikeAction = <span class="type">UNNotificationAction</span>(identifier: <span class="string">"unlike-action"</span>,</span><br><span class="line">                                                             title: <span class="string">"Unlike"</span>, options: [])</span><br><span class="line">                <span class="keyword">let</span> currentActions = extensionContext?.notificationActions</span><br><span class="line">                <span class="keyword">let</span> commentAction = currentActions![<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">let</span> newActions = [ unlikeAction, commentAction ]</span><br><span class="line">                extensionContext?.notificationActions = newActions</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>添加Actions</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> likeAction = <span class="type">UNNotificationAction</span>(identifier: <span class="string">"like-action"</span>,</span><br><span class="line">                                           title: <span class="string">"Like"</span>,</span><br><span class="line">                                         options: [])</span><br><span class="line"><span class="keyword">let</span> commentAction = <span class="type">UNTextInputNotificationAction</span>(identifier: <span class="string">"comment-action"</span>,</span><br><span class="line">                                                       title: <span class="string">"Comment"</span>,</span><br><span class="line">                                                     options: [],</span><br><span class="line">                                        textInputButtonTitle: <span class="string">"Comment"</span>,</span><br><span class="line">                                        textInputPlaceholder: <span class="string">"Type here..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> category = <span class="type">UNNotificationCategory</span>(identifier: <span class="string">"extension-example"</span>,</span><br><span class="line">                                         actions: [ likeAction, commentAction ],</span><br><span class="line">                               intentIdentifiers: [],</span><br><span class="line">                                         options: [])</span><br><span class="line"></span><br><span class="line"><span class="type">UNUserNotificationCenter</span>.current().setNotificationCategories([ category ])</span><br></pre></td></tr></table></figure></li><li><p>处理Actions</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UserNotifications</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppDelegate</span>: <span class="title">UNUserNotificationCenterDelegate</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">userNotificationCenter</span><span class="params">(<span class="number">_</span> center: UNUserNotificationCenter,</span></span></span><br><span class="line"><span class="function"><span class="params">            didReceive response: UNNotificationResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">            withCompletionHandler completionHandler: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Handle action response here</span></span><br><span class="line">            <span class="keyword">if</span> response.actionIdentifier == <span class="string">"like-action"</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                likeLabel?.text = <span class="string">"You liked this photo"</span></span><br><span class="line">                likedPhoto()</span><br><span class="line">            &#125;</span><br><span class="line">            completion(.doNotDismiss)</span><br><span class="line">            completion(.dismiss)</span><br><span class="line">            completion(.dismissAndForward)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动App</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSExtensionContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@available</span>(iOS <span class="number">12.0</span>, *)</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">performNotificationDefaultAction</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UserNotificationsUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationViewController</span>: <span class="title">UIViewController</span>, <span class="title">UNNotificationContentExtension</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@IBOutlet</span> <span class="keyword">var</span> allCommentsButton: <span class="type">UIButton</span>?</span><br><span class="line">        ...</span><br><span class="line">        allCommentsButton?.addTarget(<span class="keyword">self</span>, action: #selector(launchApp), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">        ...</span><br><span class="line">        <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">launchApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">              extensionContext?.performNotificationDefaultAction()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>隐藏通知内容扩展界面<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSExtensionContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">12.0</span>, *)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dismissNotificationContentExtension</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UserNotificationsUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationViewController</span>: <span class="title">UIViewController</span>, <span class="title">UNNotificationContentExtension</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> likeButton: <span class="type">UIButton</span>?</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    likeButton?.addTarget(<span class="keyword">self</span>, action: #selector(likeButtonTapped), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">likeButtonTapped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        likedPhoto()</span><br><span class="line">        extensionContext?.dismissNotificationContentExtension()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>需要注意的是，调用这个 API 并不会移除那条通知，如果需要移除通知可以调用下面的 API<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UNUserNotificationCenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeDeliveredNotifications</span><span class="params">(withIdentifiers identifiers: [String])</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Notification-management"><a href="#Notification-management" class="headerlink" title="Notification management"></a>Notification management</h3><p>为方便用户操作应用的设置通知页面，在推送页面上加入了全新的管理页面方便操作</p><p><img src="/images/WWDC-group6.png" alt="WWDC-group6"></p><ul><li>隐式通知 (Deliver Quietly )    只会显示在通知中心，不会带有声音提醒，应用角标</li><li>显式推送（Deliver Prominently） 显示推送会开启所有的通知选项。</li></ul><p>管理页面的入口有三种方式进入</p><ul><li>系统根据用户操作自动给出<br><img src="/images/WWDC-group7.png" alt="WWDC-group7"></li><li>左滑通知<br><img src="/images/WWDC-group8.png" alt="WWDC-group8"></li><li>点击通知详情<br><img src="/images/WWDC-group9.png" alt="WWDC-group9"></li></ul><p>当然，在新的通知管理页面，iOS12 提供了新的方法可以根据需要自定义，当点击页面的按钮操作<br>可以通过以下方法获取该行为<br><img src="/images/WWDC-group10.png" alt="WWDC-group10"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> UserNotifications</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIApplicationDelegate</span>, <span class="title">UNUserNotificationCenterDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userNotificationCenter</span><span class="params">(<span class="number">_</span> center: UNUserNotificationCenter, openSettingsFor notification: UNNotification? )</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Provisional-authorization"><a href="#Provisional-authorization" class="headerlink" title="Provisional authorization"></a>Provisional authorization</h3><p>ios 12 提供了一种新的授权机制:临时授权<br>给用户推送的消息不需要通过用户授权弹窗，不过只能隐式推送给用户，不带系统声音和角标<br>在代码中只需要设置参数<code>provisional</code>即可</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Requesting Provisional Authorization</span></span><br><span class="line"><span class="keyword">let</span> notificationCenter = <span class="type">UNUserNotificationCenter</span>.current()</span><br><span class="line">    </span><br><span class="line">    notificationCenter.requestAuthorization(</span><br><span class="line">        options:[.badge, .sound, .alert, .provisional]) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Critical-alerts"><a href="#Critical-alerts" class="headerlink" title="Critical alerts"></a>Critical alerts</h3><p>在勿扰模式或关闭铃声的情况下依然可以收到重要的通知或App设置的铃声</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2018年WWDC召开至今， 围绕User Notification相关的iOS12特性介绍非常多&lt;br&gt;此次主要是针对用户体验带来的分组通
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>YYModel解析</title>
    <link href="https://pattyxp.github.io/2018/06/20/YYModel%E8%A7%A3%E6%9E%90/"/>
    <id>https://pattyxp.github.io/2018/06/20/YYModel解析/</id>
    <published>2018-06-20T06:10:04.000Z</published>
    <updated>2018-06-21T02:51:26.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>Model的定义与实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYTemplateModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> type;   </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span>  *templateNames;      </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span>  *templateId;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>  *items;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYTemplateModel</span></span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)modelContainerPropertyGenericClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">             <span class="string">@"items"</span>: [YYItem <span class="keyword">class</span>]</span><br><span class="line">             &#125;;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)modelCustomPropertyMapper &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">             <span class="string">@"name"</span>: @[<span class="string">@"name"</span>, <span class="string">@"Name"</span>],</span><br><span class="line">             <span class="string">@"templateNames"</span>:@[<span class="string">@"templateName"</span>],         </span><br><span class="line">             <span class="string">@"templateId"</span>:<span class="string">@"id"</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际在使用中，通常是将Model与json进行相互转换</p><h2 id="YYModel-解析流程"><a href="#YYModel-解析流程" class="headerlink" title="YYModel 解析流程"></a>YYModel 解析流程</h2><h3 id="yy-modelToJSONObject-NSObject-YYModel-m-model转为json"><a href="#yy-modelToJSONObject-NSObject-YYModel-m-model转为json" class="headerlink" title="yy_modelToJSONObject (NSObject+YYModel.m)  model转为json"></a>yy_modelToJSONObject (NSObject+YYModel.m)  model转为json</h3><p>实际是对<code>ModelToJSONObjectRecursive</code>封装</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)yy_modelToJSONObject &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Apple said:</span></span><br><span class="line"><span class="comment">     The top level object is an NSArray or NSDictionary.</span></span><br><span class="line"><span class="comment">     All objects are instances of NSString, NSNumber, NSArray, NSDictionary, or NSNull.</span></span><br><span class="line"><span class="comment">     All dictionary keys are instances of NSString.</span></span><br><span class="line"><span class="comment">     Numbers are not NaN or infinity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">id</span> jsonObject = ModelToJSONObjectRecursive(<span class="keyword">self</span>); </span><br><span class="line">    <span class="comment">//对Model进行类型判断，符合指定类型才返回，否则返回nil</span></span><br><span class="line">    <span class="comment">//返回值类型包括 NSString,NSNumber，NSArray,NSDictionary,or NSNull</span></span><br><span class="line">    <span class="keyword">if</span> ([jsonObject isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> jsonObject;</span><br><span class="line">    <span class="keyword">if</span> ([jsonObject isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> jsonObject;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ModelToJSONObjectRecursive"><a href="#ModelToJSONObjectRecursive" class="headerlink" title="ModelToJSONObjectRecursive"></a>ModelToJSONObjectRecursive</h3><p>将Object转为json并返回</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> ModelToJSONObjectRecursive(<span class="built_in">NSObject</span> *model) &#123;</span><br><span class="line">    <span class="comment">//进行基础类型判断，如果满足直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!model || model == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSURL</span> *)model).absoluteString;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSAttributedString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSAttributedString</span> *)model).string;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDate</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> [YYISODateFormatter() stringFromDate:(<span class="keyword">id</span>)model];</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是自定义类型判断</span></span><br><span class="line"></span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model <span class="keyword">class</span>]];</span><br><span class="line">    <span class="comment">//根据model转为YYModelMeta,，此处对modelMeta的获取和设置都有加信号量控制，防止出现线程问题</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!modelMeta || modelMeta-&gt;_keyMappedCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *result = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">64</span>];</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSMutableDictionary</span> *dic = result; <span class="comment">// avoid retain and release in block</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历mapper</span></span><br><span class="line">    [modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!propertyMeta-&gt;_<span class="keyword">getter</span>) <span class="keyword">return</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_isCNumber) &#123; <span class="comment">//匹配CNumber类型</span></span><br><span class="line">            value = ModelCreateNumberFromProperty(model, propertyMeta);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMeta-&gt;_nsType) &#123; <span class="comment">//大部分情况执行</span></span><br><span class="line">            <span class="keyword">id</span> v = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);<span class="comment">//从model获取对应属性propertyMeta的值，赋值给V</span></span><br><span class="line">            value = ModelToJSONObjectRecursive(v); <span class="comment">//对V的类型做判断，如果是基础类型直接返回赋值给value</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeObject: &#123;</span><br><span class="line">                    <span class="keyword">id</span> v = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = ModelToJSONObjectRecursive(v);</span><br><span class="line">                    <span class="keyword">if</span> (value == (<span class="keyword">id</span>)kCFNull) value = <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeClass: &#123;</span><br><span class="line">                    Class v = ((Class (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromClass</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeSEL: &#123;</span><br><span class="line">                    SEL v = ((SEL (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromSelector</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!value) <span class="keyword">return</span>; <span class="comment">//非空判断</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyPath) &#123; </span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *superDic = dic;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *subDic = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *key = propertyMeta-&gt;_mappedToKeyPath[i];</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> == max) &#123; <span class="comment">// end</span></span><br><span class="line">                    <span class="keyword">if</span> (!superDic[key]) superDic[key] = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                subDic = superDic[key];</span><br><span class="line">                <span class="keyword">if</span> (subDic) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ([subDic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                        subDic = subDic.mutableCopy;</span><br><span class="line">                        superDic[key] = subDic;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    subDic = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">                    superDic[key] = subDic;</span><br><span class="line">                &#125;</span><br><span class="line">                superDic = subDic;</span><br><span class="line">                subDic = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//大部分情况</span></span><br><span class="line">            <span class="keyword">if</span> (!dic[propertyMeta-&gt;_mappedToKey]) &#123;</span><br><span class="line">                dic[propertyMeta-&gt;_mappedToKey] = value;  <span class="comment">//dic 赋值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomTransformToDictionary) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> suc = [((<span class="keyword">id</span>&lt;YYModel&gt;)model) modelCustomTransformToDictionary:dic];</span><br><span class="line">        <span class="keyword">if</span> (!suc) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// result = dic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ModelToJSONObjectRecursive</code>方法总结</p><ul><li>判断基础类型，直接返回</li><li>自定义类型，初始化生成<code>YYModelMeta</code>实例</li><li>遍历mapper方法，执行propertyMeta的getter方法，将返回值赋给dic返回</li></ul><h3 id="YYModelMeta初始化"><a href="#YYModelMeta初始化" class="headerlink" title="YYModelMeta初始化"></a>YYModelMeta初始化</h3><p><img src="/images/YYModelMeta初始化.png" alt="YYModelMeta初始化"></p><p><code>- (instancetype)initWithClass:(Class)cls</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithClass:(Class)cls &#123;</span><br><span class="line">    //初始化YYClassInfo</span><br><span class="line">    YYClassInfo *classInfo = [YYClassInfo classInfoWithClass:cls];</span><br><span class="line">    if (!classInfo) return nil;</span><br><span class="line">    self = [super init];</span><br><span class="line">    </span><br><span class="line">    // Get black list 判断当前类是否实现黑名单</span><br><span class="line">    NSSet *blacklist = nil;</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelPropertyBlacklist)]) &#123;</span><br><span class="line">        NSArray *properties = [(id&lt;YYModel&gt;)cls modelPropertyBlacklist]; //获取黑名单数组</span><br><span class="line">        if (properties) &#123; </span><br><span class="line">            blacklist = [NSSet setWithArray:properties]; //赋值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Get white list  判断当前类是否实现白名单</span><br><span class="line">    NSSet *whitelist = nil;</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelPropertyWhitelist)]) &#123;</span><br><span class="line">        NSArray *properties = [(id&lt;YYModel&gt;)cls modelPropertyWhitelist];</span><br><span class="line">        if (properties) &#123;</span><br><span class="line">            whitelist = [NSSet setWithArray:properties];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Get container property&apos;s generic class</span><br><span class="line">    //判断当前类是否实现属性与类对应方法</span><br><span class="line">    NSDictionary *genericMapper = nil;</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelContainerPropertyGenericClass)]) &#123;</span><br><span class="line">        genericMapper = [(id&lt;YYModel&gt;)cls modelContainerPropertyGenericClass];</span><br><span class="line">        if (genericMapper) &#123; //获取到实现的字典</span><br><span class="line">            NSMutableDictionary *tmp = [NSMutableDictionary new]; </span><br><span class="line">            // 遍历字典</span><br><span class="line">            [genericMapper enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">                if (![key isKindOfClass:[NSString class]]) return; //如果key不满足类型，返回</span><br><span class="line">                Class meta = object_getClass(obj); //返回obj的isa所指向的类</span><br><span class="line">                if (!meta) return;</span><br><span class="line">                if (class_isMetaClass(meta)) &#123; //如果是元类</span><br><span class="line">                    tmp[key] = obj;  //赋值</span><br><span class="line">                &#125; else if ([obj isKindOfClass:[NSString class]]) &#123; //如果obj是NSString</span><br><span class="line">                    Class cls = NSClassFromString(obj); //转为Cls</span><br><span class="line">                    if (cls) &#123;</span><br><span class="line">                        tmp[key] = cls; //赋值Cls</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">            genericMapper = tmp; //赋值genericMapper</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Create all property metas. 遍历所有属性含父类，但忽略 NSObject/NSProxy类</span><br><span class="line">    NSMutableDictionary *allPropertyMetas = [NSMutableDictionary new];</span><br><span class="line">    //allPropertyMetas 存储所以属性对应的propertyMeta</span><br><span class="line"></span><br><span class="line">    YYClassInfo *curClassInfo = classInfo;</span><br><span class="line">    //遍历至根类，将所有的属性进行赋值</span><br><span class="line">    while (curClassInfo &amp;&amp; curClassInfo.superCls != nil) &#123; // recursive parse super class, but ignore root class (NSObject/NSProxy)</span><br><span class="line">        for (YYClassPropertyInfo *propertyInfo in curClassInfo.propertyInfos.allValues) &#123;</span><br><span class="line">            if (!propertyInfo.name) continue;</span><br><span class="line">            if (blacklist &amp;&amp; [blacklist containsObject:propertyInfo.name]) continue;</span><br><span class="line">            if (whitelist &amp;&amp; ![whitelist containsObject:propertyInfo.name]) continue;</span><br><span class="line"></span><br><span class="line">            // 根据classInfo propertyInfo genericMapper初始化YYModelPropertyMeta</span><br><span class="line">            _YYModelPropertyMeta *meta = [_YYModelPropertyMeta metaWithClassInfo:classInfo</span><br><span class="line">                                                                    propertyInfo:propertyInfo</span><br><span class="line">                                                                         generic:genericMapper[propertyInfo.name]];</span><br><span class="line">            if (!meta || !meta-&gt;_name) continue;</span><br><span class="line">            if (!meta-&gt;_getter || !meta-&gt;_setter) continue;</span><br><span class="line">            if (allPropertyMetas[meta-&gt;_name]) continue;</span><br><span class="line">            allPropertyMetas[meta-&gt;_name] = meta;</span><br><span class="line">        &#125;</span><br><span class="line">        curClassInfo = curClassInfo.superClassInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    if (allPropertyMetas.count) _allPropertyMetas = allPropertyMetas.allValues.copy;</span><br><span class="line">    </span><br><span class="line">    // create mapper</span><br><span class="line">    NSMutableDictionary *mapper = [NSMutableDictionary new];</span><br><span class="line">    NSMutableArray *keyPathPropertyMetas = [NSMutableArray new];</span><br><span class="line">    NSMutableArray *multiKeysPropertyMetas = [NSMutableArray new];</span><br><span class="line">    </span><br><span class="line">    //实现对应的自定义属性方法</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelCustomPropertyMapper)]) &#123;</span><br><span class="line">        NSDictionary *customMapper = [(id &lt;YYModel&gt;)cls modelCustomPropertyMapper];//获取实现方法的字典</span><br><span class="line">        [customMapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyName, NSString *mappedToKey, BOOL *stop) &#123;</span><br><span class="line">            //获取属性列表中对应属性的meta</span><br><span class="line">            _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName];</span><br><span class="line">            if (!propertyMeta) return; //如果不存在return掉</span><br><span class="line">            [allPropertyMetas removeObjectForKey:propertyName];//如果存在自定义属性，先从属性列表中删除</span><br><span class="line">            </span><br><span class="line">            if ([mappedToKey isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">                  /** 根据上面示例源码</span><br><span class="line">                     mappedToKey:  id</span><br><span class="line">                    */</span><br><span class="line">                if (mappedToKey.length == 0) return;</span><br><span class="line">                </span><br><span class="line">                propertyMeta-&gt;_mappedToKey = mappedToKey; //赋值mappedToKey</span><br><span class="line">                NSArray *keyPath = [mappedToKey componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">                for (NSString *onePath in keyPath) &#123;</span><br><span class="line">                    if (onePath.length == 0) &#123;</span><br><span class="line">                        NSMutableArray *tmp = keyPath.mutableCopy;</span><br><span class="line">                        [tmp removeObject:@&quot;&quot;]; //将空值移除</span><br><span class="line">                        keyPath = tmp;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (keyPath.count &gt; 1) &#123; //对应多个.</span><br><span class="line">                    propertyMeta-&gt;_mappedToKeyPath = keyPath;</span><br><span class="line">                    [keyPathPropertyMetas addObject:propertyMeta];</span><br><span class="line">                &#125;</span><br><span class="line">                propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;</span><br><span class="line">                mapper[mappedToKey] = propertyMeta;</span><br><span class="line">                </span><br><span class="line">                /** mapper</span><br><span class="line">                mapper:</span><br><span class="line">                &#123;</span><br><span class="line">                     id = &quot;&lt;_YYModelPropertyMeta: 0x6040006eb800&gt;&quot;;</span><br><span class="line">                     (</span><br><span class="line">                        templateName</span><br><span class="line">                     ) = &quot;&lt;_YYModelPropertyMeta: 0x604000ae6980&gt;&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                */</span><br><span class="line">            &#125; else if ([mappedToKey isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">                /** 根据上面示例源码</span><br><span class="line">                mappedToKey:</span><br><span class="line">                &lt;__NSSingleObjectArrayI 0x600000204190&gt;(</span><br><span class="line">                    templateName</span><br><span class="line">                )</span><br><span class="line">                */</span><br><span class="line">                NSMutableArray *mappedToKeyArray = [NSMutableArray new];</span><br><span class="line">                for (NSString *oneKey in ((NSArray *)mappedToKey)) &#123;</span><br><span class="line">                    if (![oneKey isKindOfClass:[NSString class]]) continue;</span><br><span class="line">                    if (oneKey.length == 0) continue;</span><br><span class="line">                    </span><br><span class="line">                    NSArray *keyPath = [oneKey componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">                    if (keyPath.count &gt; 1) &#123;</span><br><span class="line">                        [mappedToKeyArray addObject:keyPath];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        [mappedToKeyArray addObject:oneKey];</span><br><span class="line">                        /** mappedToKeyArray:</span><br><span class="line">                        &lt;__NSArrayM 0x60400685ee70&gt;(</span><br><span class="line">                            templateName</span><br><span class="line">                        )</span><br><span class="line">                        */</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    if (!propertyMeta-&gt;_mappedToKey) &#123;</span><br><span class="line">                        propertyMeta-&gt;_mappedToKey = oneKey; //赋值mappedToKey</span><br><span class="line">                        propertyMeta-&gt;_mappedToKeyPath = keyPath.count &gt; 1 ? keyPath : nil;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!propertyMeta-&gt;_mappedToKey) return; //判断如果为空，return</span><br><span class="line">                </span><br><span class="line">                propertyMeta-&gt;_mappedToKeyArray = mappedToKeyArray; //赋值mappedToKeyArray</span><br><span class="line">                [multiKeysPropertyMetas addObject:propertyMeta];// 赋值multiKeysPropertyMetas</span><br><span class="line">                </span><br><span class="line">                propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;</span><br><span class="line">                mapper[mappedToKey] = propertyMeta; </span><br><span class="line">                /**</span><br><span class="line">                mapper:</span><br><span class="line">                &#123;</span><br><span class="line">                         (</span><br><span class="line">                         templateName</span><br><span class="line">                        ) = &quot;&lt;_YYModelPropertyMeta: 0x604000ae6980&gt;&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                */</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [allPropertyMetas enumerateKeysAndObjectsUsingBlock:^(NSString *name, _YYModelPropertyMeta *propertyMeta, BOOL *stop) &#123;</span><br><span class="line">        propertyMeta-&gt;_mappedToKey = name; //赋值_mappedToKey</span><br><span class="line">        propertyMeta-&gt;_next = mapper[name] ?: nil;</span><br><span class="line">        mapper[name] = propertyMeta; //赋值mapper 此时mapper内元素数量是和当前Model的属性数量一致的</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    if (mapper.count) _mapper = mapper; </span><br><span class="line">    if (keyPathPropertyMetas) _keyPathPropertyMetas = keyPathPropertyMetas;</span><br><span class="line">    if (multiKeysPropertyMetas) _multiKeysPropertyMetas = multiKeysPropertyMetas;</span><br><span class="line">    </span><br><span class="line">    _classInfo = classInfo;</span><br><span class="line">    _keyMappedCount = _allPropertyMetas.count;</span><br><span class="line">    _nsType = YYClassGetNSType(cls);</span><br><span class="line">    _hasCustomWillTransformFromDictionary = ([cls instancesRespondToSelector:@selector(modelCustomWillTransformFromDictionary:)]);</span><br><span class="line">    _hasCustomTransformFromDictionary = ([cls instancesRespondToSelector:@selector(modelCustomTransformFromDictionary:)]);</span><br><span class="line">    _hasCustomTransformToDictionary = ([cls instancesRespondToSelector:@selector(modelCustomTransformToDictionary:)]);</span><br><span class="line">    _hasCustomClassFromDictionary = ([cls respondsToSelector:@selector(modelCustomClassForDictionary:)]);</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>YYModelMeta</code>初始化方法总结</p><ul><li>初始化YYClassInfo, 内部初始化会实现superClassInfo的赋值 直到根类</li><li>解析内部实现的方法如黑名单，白名单</li><li>解析方法modelContainerPropertyGenericClass，此方法较常见<br> genericMapper字典存储该方法内对指定字段的替换，如通常情况下是<code>items</code>字段，数组类型，内部包含相同类型的model<br> 比如genericMapper:<br>  {<pre><code>items = YYItem;</code></pre>  }</li><li>while循环，allPropertyMetas字典存储当前classInfo对象的属性，并循环到父类的所有属性（直到superCls != nil）<br>  比如allPropertyMetas:<br>  {<br>  items = “<_yymodelpropertymeta: 0x6000004e1700="">“;<br>  type = “<_yymodelpropertymeta: 0x6000008f7c00="">“;<br>  templateNames = “<_yymodelpropertymeta: 0x6000008a5c02="">“;<br>  templateId =  “<_yymodelpropertymeta: 0x6000008b2a00="">“;<br>  }</_yymodelpropertymeta:></_yymodelpropertymeta:></_yymodelpropertymeta:></_yymodelpropertymeta:></li><li>解析方法modelCustomPropertyMapper<br>  赋值每个propertyMeta的mappedToKey/mappedToKeyPath/next/_mappedToKeyArray<br>  赋值mapper  如<code>mapper[mappedToKey] = propertyMeta;</code></li><li>遍历allPropertyMetas字典 将对应propertyMeta 正确赋值 ，mapper数组添加每个遍历到的propertyMeta保证mapper数组内元素和当前Model的属性一致</li><li>剩余的属性赋值</li></ul><p>此时可以查看到 当前Model的mapper值<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mapper:</span><br><span class="line">&#123;</span><br><span class="line">    items = <span class="string">"&lt;_YYModelPropertyMeta: 0x6000004f3300&gt;"</span>;</span><br><span class="line">    <span class="keyword">id</span> = <span class="string">"&lt;_YYModelPropertyMeta: 0x6000006e9a00&gt;"</span>;</span><br><span class="line">    type = <span class="string">"&lt;_YYModelPropertyMeta: 0x6000008efc80&gt;"</span>;</span><br><span class="line">    (</span><br><span class="line">        templateName,</span><br><span class="line">        templateNames</span><br><span class="line">    ) = <span class="string">"&lt;_YYModelPropertyMeta: 0x6000008eeb00&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>补下照<br><img src="/images/YYModelPropertyMeta初始化.png" alt="YYModelPropertyMeta初始化"></p><p>以上是初始化方法，那么实际使用，就需要开始运用这些属性了</p><p>通常在解析拿到的json数据，调用方法<code>yy_modelWithDictionary</code></p><h3 id="yy-modelWithDictionary-json转Model"><a href="#yy-modelWithDictionary-json转Model" class="headerlink" title="yy_modelWithDictionary  json转Model"></a>yy_modelWithDictionary  json转Model</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)yy_modelWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionary &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dictionary || dictionary == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">nil</span>;  <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span> (![dictionary isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">//不是字典类型，直接返回</span></span><br><span class="line">    </span><br><span class="line">    Class cls = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:cls]; <span class="comment">//获取model对应的YYModelMeta，如果已经初始化，直接从缓存字典获取</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomClassFromDictionary) &#123;</span><br><span class="line">        cls = [cls modelCustomClassForDictionary:dictionary] ?: cls;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *one = [cls new];</span><br><span class="line">    <span class="keyword">if</span> ([one yy_modelSetWithDictionary:dictionary]) <span class="keyword">return</span> one;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部封装<code>yy_modelSetWithDictionary</code><br>方法调用栈如下<br><img src="/images/YYModel解析底层.png" alt="YYModel解析底层"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)yy_modelSetWithDictionary:(<span class="built_in">NSDictionary</span> *)dic &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dic || dic == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(<span class="keyword">self</span>)];</span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_keyMappedCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>; <span class="comment">//如果没有属性，返回</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在这里能修改数据源字典</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomWillTransformFromDictionary) &#123;</span><br><span class="line">        dic = [((<span class="keyword">id</span>&lt;YYModel&gt;)<span class="keyword">self</span>) modelCustomWillTransformFromDictionary:dic];</span><br><span class="line">        <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ModelSetContext context = &#123;<span class="number">0</span>&#125;; <span class="comment">//上下文的几个属性都赋值给context</span></span><br><span class="line">    context.modelMeta = (__bridge <span class="keyword">void</span> *)(modelMeta);</span><br><span class="line">    context.model = (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>);</span><br><span class="line">    context.dictionary = (__bridge <span class="keyword">void</span> *)(dic);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_keyMappedCount &gt;= <span class="built_in">CFDictionaryGetCount</span>((<span class="built_in">CFDictionaryRef</span>)dic)) &#123;</span><br><span class="line">        <span class="built_in">CFDictionaryApplyFunction</span>((<span class="built_in">CFDictionaryRef</span>)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class="line">        <span class="keyword">if</span> (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class="line">            <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class="line">                                 <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="built_in">CFArrayGetCount</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class="line">            <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class="line">                                 <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="built_in">CFArrayGetCount</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_allPropertyMetas,</span><br><span class="line">                             <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, modelMeta-&gt;_keyMappedCount),</span><br><span class="line">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                             &amp;context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123;</span><br><span class="line">        <span class="keyword">return</span> [((<span class="keyword">id</span>&lt;YYModel&gt;)<span class="keyword">self</span>) modelCustomTransformFromDictionary:dic];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ModelSetWithPropertyMetaArrayFunction"><a href="#ModelSetWithPropertyMetaArrayFunction" class="headerlink" title="ModelSetWithPropertyMetaArrayFunction"></a>ModelSetWithPropertyMetaArrayFunction</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Apply function for model property meta, to set dictionary to model.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param _propertyMeta should not be nil, _YYModelPropertyMeta.</span></span><br><span class="line"><span class="comment"> @param _context      _context.model and _context.dictionary should not be nil.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ModelSetWithPropertyMetaArrayFunction(<span class="keyword">const</span> <span class="keyword">void</span> *_propertyMeta, <span class="keyword">void</span> *_context) &#123;</span><br><span class="line">    ModelSetContext *context = _context;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSDictionary</span> *dictionary = (__bridge <span class="built_in">NSDictionary</span> *)(context-&gt;dictionary);</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *propertyMeta = (__bridge _YYModelPropertyMeta *)(_propertyMeta);</span><br><span class="line">    <span class="keyword">if</span> (!propertyMeta-&gt;_<span class="keyword">setter</span>) <span class="keyword">return</span>; <span class="comment">//propertyMeta没有setter方法，返回</span></span><br><span class="line">    <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyArray) &#123;   <span class="comment">// 多个key对应同一属性赋值</span></span><br><span class="line">        value = YYValueForMultiKeys(dictionary, propertyMeta-&gt;_mappedToKeyArray);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyPath) &#123;  <span class="comment">// keyPath赋值</span></span><br><span class="line">        value = YYValueForKeyPath(dictionary, propertyMeta-&gt;_mappedToKeyPath);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = [dictionary objectForKey:propertyMeta-&gt;_mappedToKey];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model = (__bridge <span class="keyword">id</span>)(context-&gt;model);</span><br><span class="line">        ModelSetValueForProperty(model, value, propertyMeta); <span class="comment">//属性赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ModelSetWithDictionaryFunction"><a href="#ModelSetWithDictionaryFunction" class="headerlink" title="ModelSetWithDictionaryFunction"></a>ModelSetWithDictionaryFunction</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ModelSetWithDictionaryFunction(<span class="keyword">const</span> <span class="keyword">void</span> *_key, <span class="keyword">const</span> <span class="keyword">void</span> *_value, <span class="keyword">void</span> *_context) &#123;</span><br><span class="line">    ModelSetContext *context = _context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据上下文结构体 ModelSetContext 取出 _YYModelMeta / _YYModelPropertyMeta / model</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelMeta *meta = (__bridge _YYModelMeta *)(context-&gt;modelMeta);</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *propertyMeta = [meta-&gt;_mapper objectForKey:(__bridge <span class="keyword">id</span>)(_key)];</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model = (__bridge <span class="keyword">id</span>)(context-&gt;model);</span><br><span class="line">    <span class="keyword">while</span> (propertyMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_<span class="keyword">setter</span>) &#123; <span class="comment">//调用对应的setter方法赋值model的value属性</span></span><br><span class="line">            ModelSetValueForProperty(model, (__bridge __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>)_value, propertyMeta);</span><br><span class="line">            <span class="comment">//底层调用msg_send方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        propertyMeta = propertyMeta-&gt;_next;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li>CFArrayApplyFunction<br>为数组内指定范围的每个元素调用一次指定的方法,上面指定的方法有<code>ModelSetWithPropertyMetaArrayFunction</code>/<code>ModelSetWithDictionaryFunction</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体上YYmodel数据解析</p><ul><li>根据cls进行初始化生成model对应的<code>YYModelMeta</code>，包含mapper,里面含有每个属性（YYModelPropertyMeta）</li><li>根据对应的json 与 YYModelMeta 进行相互转换赋值，会进行各种类型及判空处理</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h2&gt;&lt;p&gt;Model的定义与实现&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dispatch系列</title>
    <link href="https://pattyxp.github.io/2018/06/07/Dispatch%E7%B3%BB%E5%88%97/"/>
    <id>https://pattyxp.github.io/2018/06/07/Dispatch系列/</id>
    <published>2018-06-07T01:46:16.000Z</published>
    <updated>2018-06-07T02:48:17.572Z</updated>
    
    <content type="html"><![CDATA[<p>本系列源码地址 <a href="https://opensource.apple.com/tarballs/libdispatch" target="_blank" rel="noopener">libdispatch</a><br>研读版本 <code>libdispatch-339.92.1</code></p><p>思维导图<br><img src="/images/dispatch重要函数.png" alt="dispatch重要函数"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本系列源码地址 &lt;a href=&quot;https://opensource.apple.com/tarballs/libdispatch&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;libdispatch&lt;/a&gt;&lt;br&gt;研读版本 &lt;code&gt;libdispa
      
    
    </summary>
    
    
      <category term="Dispatch" scheme="https://pattyxp.github.io/tags/Dispatch/"/>
    
  </entry>
  
  <entry>
    <title>Objc-protocol实现原理</title>
    <link href="https://pattyxp.github.io/2018/05/22/Objc-protocol%E5%8E%9F%E7%90%86/"/>
    <id>https://pattyxp.github.io/2018/05/22/Objc-protocol原理/</id>
    <published>2018-05-22T09:24:40.000Z</published>
    <updated>2018-05-24T03:29:27.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文直接运行的是runtime Objc4-706版本，debug-objc的target，mac运行</p><p>本篇研究以下问题</p><ul><li>Protocol的实现原理</li></ul><p>若要查看category实现原理，请自行查阅之前的<a href="https://pattyxp.github.io/2018/02/11/Objc-category%E7%AF%87/">博客</a></p><p>源码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt;pig.h</span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">pigProtocol</span></span></span><br><span class="line">- (<span class="keyword">void</span>)updateAge;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Pig</span> : <span class="title">NSObject</span>&lt;<span class="title">pigProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line">+ (<span class="keyword">id</span>)createPig;</span><br><span class="line">- (<span class="keyword">void</span>)updateAge;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">&gt;pig.m</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Pig</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)createPig</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> new];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)updateAge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.age = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"对象age:%@"</span>,<span class="keyword">self</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">&gt;main.m</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Pig *pigObject = [Pig createPig];</span><br><span class="line">        [pigObject updateAge];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先在整个应用中，在main函数打上断点，可以观察到最初函数调用栈如图<br><img src="/images/OC4-init.png" alt="OC4-init"></p><p>在<code>objc-runtime-new.mm</code>文件 L:2284 方法<code>_read_images</code>内有对<code>protocol</code>、<code>category</code>等的赋值操作<br><code>_read_images</code>方法是从当前镜像内加载相应的类及其属性</p><p>在方法内部<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">        Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">        assert(cls);</span><br><span class="line">        NXMapTable *protocol_map = protocols(); <span class="comment">//创建表</span></span><br><span class="line">        <span class="keyword">bool</span> isPreoptimized = hi-&gt;isPreoptimized();</span><br><span class="line">        <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line"></span><br><span class="line">        protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            readProtocol(protolist[i], cls, protocol_map, </span><br><span class="line">                         isPreoptimized, isBundle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>protocols()</code>内部实现是有个静态变量，判断是否存在表，不存在就创建<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NXMapTable *protocols(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> NXMapTable *protocol_map = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    INIT_ONCE_PTR(protocol_map, </span><br><span class="line">                  NXCreateMapTable(NXStrValueMapPrototype, <span class="number">16</span>), </span><br><span class="line">                  NXFreeMapTable(v) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> protocol_map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>_getObjc2ProtocolList</code>获取该路径下的协议列表，此处没有源码<br>下面还有个重要的方法<code>readProtocol</code><br>可以先看下里面的一些变量，这里很多协议都会走这里，如<code>NSCopying</code>、<code>NSCoding</code><br><img src="/images/OC4-protocol.png" alt="OC4-protocol"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readProtocol(protocol_t *newproto, Class protocol_class,</span><br><span class="line">             NXMapTable *protocol_map, </span><br><span class="line">             <span class="keyword">bool</span> headerIsPreoptimized, <span class="keyword">bool</span> headerIsBundle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This is not enough to make protocols in unloaded bundles safe, </span></span><br><span class="line">    <span class="comment">// but it does prevent crashes when looking up unrelated protocols.</span></span><br><span class="line">    auto insertFn = headerIsBundle ? NXMapKeyCopyingInsert : NXMapInsert;</span><br><span class="line"></span><br><span class="line">    protocol_t *oldproto = (protocol_t *)getProtocol(newproto-&gt;mangledName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldproto) &#123;  <span class="comment">//如果存在oldproto 结束</span></span><br><span class="line">        <span class="comment">// Some other definition already won.</span></span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s  "</span></span><br><span class="line">                         <span class="string">"(duplicate of %p)"</span>,</span><br><span class="line">                         newproto, oldproto-&gt;nameForLogging(), oldproto);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (headerIsPreoptimized) &#123;</span><br><span class="line">        <span class="comment">// Shared cache initialized the protocol object itself, </span></span><br><span class="line">        <span class="comment">// but in order to allow out-of-cache replacement we need </span></span><br><span class="line">        <span class="comment">// to add it to the protocol table now.</span></span><br><span class="line"></span><br><span class="line">        protocol_t *cacheproto = (protocol_t *)</span><br><span class="line">            getPreoptimizedProtocol(newproto-&gt;mangledName);</span><br><span class="line">        protocol_t *installedproto;</span><br><span class="line">        <span class="keyword">if</span> (cacheproto  &amp;&amp;  cacheproto != newproto) &#123;</span><br><span class="line">            <span class="comment">// Another definition in the shared cache wins (because </span></span><br><span class="line">            <span class="comment">// everything in the cache was fixed up to point to it).</span></span><br><span class="line">            installedproto = cacheproto;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This definition wins.</span></span><br><span class="line">            installedproto = newproto;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        assert(installedproto-&gt;getIsa() == protocol_class);</span><br><span class="line">        assert(installedproto-&gt;size &gt;= <span class="keyword">sizeof</span>(protocol_t));</span><br><span class="line">        insertFn(protocol_map, installedproto-&gt;mangledName, </span><br><span class="line">                 installedproto);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s"</span>, </span><br><span class="line">                         installedproto, installedproto-&gt;nameForLogging());</span><br><span class="line">            <span class="keyword">if</span> (newproto != installedproto) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s  "</span></span><br><span class="line">                             <span class="string">"(duplicate of %p)"</span>, </span><br><span class="line">                             newproto, installedproto-&gt;nameForLogging(), </span><br><span class="line">                             installedproto);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newproto-&gt;size &gt;= <span class="keyword">sizeof</span>(protocol_t)) &#123; <span class="comment">//如果新协议size大于96 sizeof(protocol_t)=96</span></span><br><span class="line">        <span class="comment">// New protocol from an un-preoptimized image</span></span><br><span class="line">        <span class="comment">// with sufficient storage. Fix it up in place.</span></span><br><span class="line">        <span class="comment">// fixme duplicate protocols from unloadable bundle</span></span><br><span class="line">        newproto-&gt;initIsa(protocol_class);  <span class="comment">// fixme pinned  //初始化isa</span></span><br><span class="line">        insertFn(protocol_map, newproto-&gt;mangledName, newproto);<span class="comment">// 插入协议到指定的protocol_map</span></span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s"</span>,</span><br><span class="line">                         newproto, newproto-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// New protocol from an un-preoptimized image </span></span><br><span class="line">        <span class="comment">// with insufficient storage. Reallocate it.</span></span><br><span class="line">        <span class="comment">// fixme duplicate protocols from unloadable bundle</span></span><br><span class="line">        size_t size = max(<span class="keyword">sizeof</span>(protocol_t), (size_t)newproto-&gt;size);</span><br><span class="line">        protocol_t *installedproto = (protocol_t *)calloc(size, <span class="number">1</span>);</span><br><span class="line">        memcpy(installedproto, newproto, newproto-&gt;size);</span><br><span class="line">        installedproto-&gt;size = (<span class="keyword">typeof</span>(installedproto-&gt;size))size;</span><br><span class="line">        </span><br><span class="line">        installedproto-&gt;initIsa(protocol_class);  <span class="comment">// fixme pinned</span></span><br><span class="line">        insertFn(protocol_map, installedproto-&gt;mangledName, installedproto);</span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s  "</span>, </span><br><span class="line">                         installedproto, installedproto-&gt;nameForLogging());</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s  "</span></span><br><span class="line">                         <span class="string">"(reallocated to %p)"</span>, </span><br><span class="line">                         newproto, installedproto-&gt;nameForLogging(), </span><br><span class="line">                         installedproto);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要监听自己需要的协议如<code>pigProtocol</code>，可以打断点<br><img src="/images/OC4-pigProtol断点.png" alt="OC4-pigProtol断点"><br><img src="/images/OC4-pigProtocol.png" alt="OC4-pigProtocol"></p><p>当协议存储在协议表之后，调用协议，其实就是方法查找的问题，可以看下之前的文章<em>消息的发送与查找</em><br><img src="/images/OC4-pigProtocol查找调用.png" alt="OC4-pigProtocol查找调用"></p><p>此处关于<code>NXMapTable</code>将在下章进行分析</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li><p>calloc<br>  <code>calloc()</code> 函数用来动态地分配内存空间并初始化为 0，其原型为：<br>  <code>void* calloc (size_t num, size_t size);</code></p><p>  <code>calloc()</code> 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</p><p>  【返回值】分配成功返回指向该内存的地址，失败则返回 NULL。</p><p>  <code>calloc()</code> 与 <code>malloc()</code>的一个重要区别是：<code>calloc()</code> 在动态分配完内存后，自动初始化该内存空间为零，而 <code>malloc()</code> 不初始化，里边数据是未知的垃圾数据</p></li><li><p>memcpy<br>  函数原型<code>void *memcpy(void*dest, const void *src, size_t n);</code><br>  由src指向地址为起始地址的连续n个字节的数据复制到以destin指向地址为起始地址的空间内。<br>  【返回值】函数返回一个指向dest的指针</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文直接运行的是runtime Objc4-706版本，debug-objc的target，mac运行&lt;/p&gt;
&lt;p&gt;本篇研究以下问题&lt;/p
      
    
    </summary>
    
    
      <category term="Objc" scheme="https://pattyxp.github.io/tags/Objc/"/>
    
  </entry>
  
  <entry>
    <title>Objc-load调查</title>
    <link href="https://pattyxp.github.io/2018/05/18/Objc-load%E8%B0%83%E6%9F%A5/"/>
    <id>https://pattyxp.github.io/2018/05/18/Objc-load调查/</id>
    <published>2018-05-18T09:28:19.000Z</published>
    <updated>2018-05-25T02:59:32.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇研究以下问题</p><ul><li>load方法调用时机和顺序问题</li><li>多个分类中有load方法是怎么处理的</li><li>为什么load方法不存在方法缓存覆盖问题</li></ul><p>先来看下load方法的加载时机<br>源码主要包含以下类:</p><ul><li>Pig类</li><li>PigCate1</li><li><p>PigCate2<br>每个类都包含<code>load</code>方法,打印当前<code>_cmd</code><br>在每个<code>load</code>处添加断点，函数调用栈如下<br>!(OC4-load)(/images/OC4-load.png)</p></li><li><p>load方法并不需要调用就会执行<br>从方法的调用栈可以知道，此时方法的调用顺序<br><code>load_images</code> 是镜像加载</p><blockquote><p>此处的镜像，一部分是系统准备的一些框架如CoreFoundation，还有很多的动态链接库</p></blockquote></li></ul><h3 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="comment">//判断是否存在load方法</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);<span class="comment">//准备加载load方法的工作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant) //调用load方法</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="prepare-load-methods"><a href="#prepare-load-methods" class="headerlink" title="prepare_load_methods"></a>prepare_load_methods</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> prepare_load_methods(<span class="keyword">const</span> headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);<span class="comment">//获取所有的类的列表</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">        <span class="comment">//remapClass 获取类对应的指针</span></span><br><span class="line">        <span class="comment">//schedule_class_load 递归调用当前(没有调用过load方法的类及其父类)加入列表中，优先加入父类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="comment">//将分类加入到列表中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="schedule-class-load"><a href="#schedule-class-load" class="headerlink" title="schedule_class_load"></a>schedule_class_load</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//保证当前类还没有调用load方法</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    <span class="comment">//优先调用当前类的父类加入到列表中</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将当前cls加入到loadable_classes列表中</span></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保父类的load方法优先于子类调用</p><h3 id="add-class-to-loadable-list"><a href="#add-class-to-loadable-list" class="headerlink" title="add_class_to_loadable_list"></a>add_class_to_loadable_list</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> add_class_to_loadable_list(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked(); <span class="comment">//递归锁</span></span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod(); <span class="comment">//获取cls的load方法</span></span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果当前数组已经存满，需要重新分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (<span class="keyword">struct</span> loadable_class *)</span><br><span class="line">            realloc(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用工作"><a href="#调用工作" class="headerlink" title="调用工作"></a>调用工作</h2><p>下次将重点分析下<code>call_load_methods()</code></p><h3 id="call-load-methods"><a href="#call-load-methods" class="headerlink" title="call_load_methods"></a>call_load_methods</h3><p>当在<code>load_images</code>方法内只调用一次<code>call_load_methods</code>,保证将所有含有load方法的类或分类全部调用load方法，按顺序先执行类方法，然后执行分类方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>; <span class="comment">//保证在load_images方法期间只执行一次该方法</span></span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush(); <span class="comment">//创建autoreleasePool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">//loadable_classes_used是全局静态变量，存储需要调用load方法的类数量</span></span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads(); <span class="comment">//分类加载load方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories); </span><br><span class="line"> </span><br><span class="line">    objc_autoreleasePoolPop(pool);      <span class="comment">//释放autoreleasePool</span></span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="call-class-loads"><a href="#call-class-loads" class="headerlink" title="call_class_loads"></a>call_class_loads</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> call_class_loads(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> loadable_class *classes = loadable_classes;</span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;  <span class="comment">//取出loadable_classes_used</span></span><br><span class="line">    loadable_classes = <span class="literal">nil</span>;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过遍历<code>for循环</code>取出所有已加载的类，取出对应的load方法地址<br>通过load方法的地址直接调用的load方法，而不是通过消息机制来调用的，所以不存在<em>方法覆盖</em>问题</p><h3 id="call-category-loads"><a href="#call-category-loads" class="headerlink" title="call_category_loads"></a>call_category_loads</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> call_category_loads(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, shift;</span><br><span class="line">    <span class="keyword">bool</span> new_categories_added = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> loadable_category *cats = loadable_categories;</span><br><span class="line">    <span class="keyword">int</span> used = loadable_categories_used;</span><br><span class="line">    <span class="keyword">int</span> allocated = loadable_categories_allocated;</span><br><span class="line">    loadable_categories = <span class="literal">nil</span>;</span><br><span class="line">    loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_categories_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        load_method_t load_method = (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123; </span><br><span class="line">            <span class="comment">//一般情况下都是类方法先于分类方法调用，但是万一存在分类先调用，此处保证如果类存在且可以加载，先调用类的方法如下</span></span><br><span class="line">            <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"LOAD: +[%s(%s) load]\n"</span>, </span><br><span class="line">                             cls-&gt;nameForLogging(), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            &#125;</span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compact detached list (order-preserving)</span></span><br><span class="line">    <span class="comment">//将已经执行完load方法的分类数量进行扣除</span></span><br><span class="line">    shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift++; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -= shift; <span class="comment">//减去相应加载完的分类数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy any new +load candidates from the new list to the detached list.</span></span><br><span class="line">    <span class="comment">//如果有新加载的类，则加入list中</span></span><br><span class="line">    new_categories_added = (loadable_categories_used &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">            cats = (<span class="keyword">struct</span> loadable_category *)</span><br><span class="line">                realloc(cats, allocated *</span><br><span class="line">                                  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the new list.</span></span><br><span class="line">    <span class="comment">//将新加载的类进行释放</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories) free(loadable_categories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reattach the (now augmented) detached list. </span></span><br><span class="line">    <span class="comment">// But if there's nothing left to load, destroy the list.</span></span><br><span class="line">    <span class="comment">//如果还有未加载完成的类，则赋值</span></span><br><span class="line">    <span class="comment">//如果都加载完，则清空列表</span></span><br><span class="line">    <span class="keyword">if</span> (used) &#123;</span><br><span class="line">        loadable_categories = cats;</span><br><span class="line">        loadable_categories_used = used;</span><br><span class="line">        loadable_categories_allocated = allocated;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats) free(cats);</span><br><span class="line">        loadable_categories = <span class="literal">nil</span>;</span><br><span class="line">        loadable_categories_used = <span class="number">0</span>;</span><br><span class="line">        loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loadable_categories_used != <span class="number">0</span>) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: %d categories still waiting for +load\n"</span>,</span><br><span class="line">                         loadable_categories_used);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_categories_added;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法调用栈如下<br>!(OC4_load_cate)(/images/OC4_load_cate.png)<br>流程上和加载类的<code>load</code>方法差不多，就不多说了</p><p>至此<code>call_load_methods</code>方法分析的差不多了</p><p>因此，<code>load</code>方法的调用时机可以总结如下</p><blockquote><p>在main方法调用之前，程序调用期间调用一次<br>父类优先子类调用<br>类优先分类</p></blockquote><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul><li>问题1<br>在调用分类的load方法源码中，存在部分理解问题<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有加载过的分类移除 `loadable_categories` 列表</span></span><br><span class="line">shift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cats[i].cat) &#123;</span><br><span class="line">        cats[i-shift] = cats[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shift++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">used -= shift;</span><br></pre></td></tr></table></figure></li></ul><p>在调用过程中，未进入过if条件，所以不知道是什么情况下进行移除操作的<br>假设cats列表存在4个分类<br>cats[0]、cats[1]、cats[2]、cats[3]<br>其中cats[0]、cats[2]的load方法已经加载过，所以相应的cat已经为nil<br>进行上面code执行结果</p><table><thead><tr><th>类</th><th style="text-align:left">条件</th><th style="text-align:center">结果赋值</th></tr></thead><tbody><tr><td>cats[0]</td><td style="text-align:left">加载过</td><td style="text-align:center">shifts=1</td></tr><tr><td>cats[1]</td><td style="text-align:left">未加载过</td><td style="text-align:center">cats[0]=cats[1]</td></tr><tr><td>cats[2]</td><td style="text-align:left">加载过</td><td style="text-align:center">shifts=2</td></tr><tr><td>cats[3]</td><td style="text-align:left">未加载过</td><td style="text-align:center">cats[0]=cats[2]</td></tr></tbody></table><p>经过调查，其实这里可以当做是一张表在操作<br>当未加载过的类，进行赋值操作如 <code>cats[0]=cats[1]</code> ，其实就是把cats[0]进行赋值，<br><code>cats[0]=cats[2]</code> 再次进行赋值，cat[2]的内容赋值给cats[0],之前的cats[1]就被移除了</p><ul><li>问题2<br>此处<code>loadable_categories_used</code>在最开始的时候已经取出赋值给<code>used</code>,然后重新赋为0<br>所以不明白为什么还会存在<code>loadable_categories_used &gt; 0</code>的情况<br>而且还重新开辟空间和赋值<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new_categories_added = (loadable_categories_used &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">            cats = (<span class="keyword">struct</span> loadable_category *)</span><br><span class="line">                realloc(cats, allocated *</span><br><span class="line">                                  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>在同一个镜像里面，<code>load_images</code>里面加入了递归锁<code>recursive_mutex_locker_t lock(loadMethodLock);</code><br>按理，前面<code>loadable_categories_used</code>已经清空了，但是存在一种可能，在<code>+laod</code>方法里面给类添加了分类及其<code>load</code><br>那么<code>loadable_categories_used</code>可能存在大于0的情况</p><h2 id="extennsion"><a href="#extennsion" class="headerlink" title="extennsion"></a>extennsion</h2><p>extension在源码中是找不到的，因为它存在于编译期，是类的一部分<br><em>extension一般用来隐藏类的私有信息</em><br><em>伴随源码产生</em>所以很多系统的类如<code>NSString</code>无法添加extension</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇研究以下问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;load方法调用时机和顺序问题&lt;/li&gt;
&lt;li&gt;多个分类中有load方法是怎么处理的&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="Objc" scheme="https://pattyxp.github.io/tags/Objc/"/>
    
  </entry>
  
  <entry>
    <title>Block的实现</title>
    <link href="https://pattyxp.github.io/2018/05/09/Block%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://pattyxp.github.io/2018/05/09/Block的实现/</id>
    <published>2018-05-09T02:16:02.000Z</published>
    <updated>2018-05-14T09:00:45.955Z</updated>
    
    <content type="html"><![CDATA[<p>在OC当中我们经常使用block，block的结构体如下<a href="http://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="noopener">摘自clang</a>:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_literal_1 &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa; <span class="comment">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor_1 &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;         <span class="comment">// NULL</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;         <span class="comment">// sizeof(struct Block_literal_1)</span></span><br><span class="line">        <span class="comment">// optional helper functions</span></span><br><span class="line">        <span class="keyword">void</span> (*copy_helper)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);     <span class="comment">// IFF (1&lt;&lt;25)</span></span><br><span class="line">        <span class="keyword">void</span> (*dispose_helper)(<span class="keyword">void</span> *src);             <span class="comment">// IFF (1&lt;&lt;25)</span></span><br><span class="line">        <span class="comment">// required ABI.2010.3.16</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *signature;                         <span class="comment">// IFF (1&lt;&lt;30)</span></span><br><span class="line">    &#125; *descriptor;</span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>对此可以看到 block主要由以下部分构成</p><ol><li>isa指针</li><li>flags 用于表示一些附加信息，如block copy之后需要判断使用</li><li>reserved 保留字段</li><li>invoke 函数指针，具体实现地址</li><li>Block_descriptor_1 结构体表示block的一些附加信息，如大小，copy，dispose函数指针以及方法签名等</li><li>imported variables 可能引入的外部变量(或变量的地址)</li></ol><p>block主要有以下三种类型<br>1._NSConcreteGlobalBlock 全局的静态 block，不会访问任何外部变量。<br>2._NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。<br>3._NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。</p><p>下面看下实现</p><h2 id="不引用外部变量"><a href="#不引用外部变量" class="headerlink" title="不引用外部变量"></a>不引用外部变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    block1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上c文件通过clang进行重写，得到如下精简代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*block1)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结下:</p><ul><li>isa 类型是<code>_NSConcreteStackBlock</code>,实际在打印的时候会发现类型是_NSConcreteGlobalBlock<br><img src="/images/block_globalBlock.png" alt="block_globalBlock"><br>这是因为 block 的存储区域，与定义在什么位置、是否引用外部变量、是否作为范围值、是被哪种类型的变量所接收等等相关</li><li><code>__main_block_impl_0</code> 是实际的函数指针，指向<code>__main_block_func_0</code></li><li><code>__main_block_func_0</code> 是函数具体实现地址</li></ul><h2 id="使用外部变量"><a href="#使用外部变量" class="headerlink" title="使用外部变量"></a>使用外部变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    &#125;;</span><br><span class="line">    block1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过clang重写之后<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main1_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main1_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  __main1_block_impl_0(<span class="keyword">void</span> *fp, struct __main1_block_desc_0 *desc, <span class="keyword">int</span> _a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main1_block_func_0(struct __main1_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> a = __cself-&gt;a; <span class="comment">// bound by copy  值拷贝</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main1_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main1_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main1_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (*block1)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main1_block_impl_0((<span class="keyword">void</span> *)__main1_block_func_0, &amp;__main1_block_desc_0_DATA, a));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以观察到:</p><ul><li>isa 指向<code>_NSConcreteStackBlock</code>，分配在栈上，实际打印发现是<code>_NSConcreteMallocBlock</code><br><img src="/images/block_mallocBlock.png" alt="block_mallocBlock"></li><li><code>__main1_block_impl_0</code> 中增加了一个变量 a，在 block 中引用的变量 a 实际是在申明 block 时，被复制到 <code>main_block_impl_0</code> 结构体中的那个变量a的瞬时值被copy到栈上，作为常量供Block使用。这样我们就能理解，在 block 内部修改变量 a 的内容，不会影响外部的实际变量 a</li><li><code>main_block_impl_0</code> 中由于增加了一个变量 a，所以结构体的大小变大了，该结构体大小被写在了 <code>main_block_desc_0</code> 中</li></ul><h2 id="修改上面的源码，在变量前面增加-block-关键字："><a href="#修改上面的源码，在变量前面增加-block-关键字：" class="headerlink" title="修改上面的源码，在变量前面增加__block 关键字："></a>修改上面的源码，在变量前面增加<code>__block</code> 关键字：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __block <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">        a = <span class="number">99</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    block1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"block之后的变量:%d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上c文件通过clang进行重写，得到如下精简代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_a_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_a_0 *a; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_a_0 *a = __cself-&gt;a; <span class="comment">// bound by ref  指针拷贝</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (a-&gt;__forwarding-&gt;a));</span><br><span class="line">  (a-&gt;__forwarding-&gt;a) = <span class="number">99</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;a, (<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_a_0 *)&amp;a, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_a_0), <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="keyword">void</span> (*block1)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, <span class="number">570425344</span>));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"block之后的变量:%d\n"</span>, (a.__forwarding-&gt;a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结下:</p><ul><li>增加新的结构体<code>__Block_byref_a_0</code>，存储了外部引用的变量a</li><li><code>__main_block_impl_0</code>引用的是<code>__Block_byref_a_0</code>结构体，用来改变外部变量a</li><li><code>__Block_byref_i_0</code>结构体带有isa,说明是一个对象</li><li><p>我们需要负责 Block_byref_i_0 结构体相关的内存管理，所以 main_block_desc_0 中增加了 copy 和 dispose 函数指针，对于在调用前后修改相应变量的引用计数。</p></li><li><p>为什么<strong>Block_byref_a_0结构体内使用指向其自身的指针</strong>forwarding<br>源码解析:<br><code>__main_block_func_0</code>使用的都是<code>(a-&gt;__forwarding-&gt;a)</code>，<br><strong>forwarding指针这里的作用就是针对堆的Block,原先栈上的`</strong>forwarding`指向自身结构体，当拷贝到堆上之后，换成指向_NSConcreteMallocBlock上复制之后的<strong>block,然后堆上的变量的</strong>forwarding再指向自己。这样不管<strong>block在堆上还是在栈上，都可以通过(a-&gt;</strong>forwarding-&gt;a)来访问到变量值。</p><p><img src="/images/block_forwarding.png" alt="block_forwarding"></p></li><li><p>NSConcreteStackBlock的例子<br>ARC下见到最多的是_NSConcreteMallocBlock，是因为我们会对Block有赋值操作<br>但是也存在<code>_NSConcreteStackBlock</code></p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> __block <span class="keyword">int</span> temp = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"*******%d %p"</span>,temp ++,&amp;temp);&#125;);</span><br></pre></td></tr></table></figure><p><img src="/images/block_stackBlock.png" alt="block_stackBlock"></p><h2 id="block-copy"><a href="#block-copy" class="headerlink" title="block_copy"></a>block_copy</h2><p>当block经过copy之后，系统会将block拷贝到堆上，此时block属于NSConcreteMallocBlock类型<br><a href="https://opensource.apple.com/source/clang/clang-137/src/projects/compiler-rt/BlocksRuntime/runtime.c" target="_blank" rel="noopener">具体源码在runtime.c</a></p><h2 id="block-的自动拷贝和手动拷贝"><a href="#block-的自动拷贝和手动拷贝" class="headerlink" title="block 的自动拷贝和手动拷贝"></a>block 的自动拷贝和手动拷贝</h2><p>那么 block 何时会 copy 到堆上呢？是显式，还是隐式？</p><ul><li>显式</li></ul><ol><li>在作为属性定义时，用 copy 和 strong 修饰；</li><li>手动调用 [block copy]；</li></ol><p>在开启ARC时，编译器通常会将创建在栈上的 block <strong>自动拷贝</strong>到堆上,除以下情况</p><blockquote><p>block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法；<br>方法/函数在内部已经实现了一份拷贝了 block 参数的代码，或者如果编译器自动拷贝，那么调用者就不需再手动拷贝，比如：</p></blockquote><ul><li>当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li><li>当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li><li>当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝;</li></ul><p>下面是自动拷贝的例子<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^blk_t)(<span class="keyword">int</span>);</span><br><span class="line">blk_t func(<span class="keyword">int</span> rate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ^(<span class="keyword">int</span> count)&#123;<span class="keyword">return</span> rate * count;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处的blk_t获取了局部变量,因此block创建在栈上<br>当func函数返回时，rate脱离作用范围，如果调用者使用时会出现问题。<br>那 ARC 开启的情况呢？运行这个 block 一切正常。和我们的预期结果不一样，ARC 到底给 block 施了什么魔法？</p><p>我们将上面的代码进行反编译<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _func(<span class="keyword">int</span> arg0) &#123;</span><br><span class="line">    rax = objc_retainBlock(__NSConcreteStackBlock);</span><br><span class="line">    rax = [rax autorelease];</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ___func_block_invoke(<span class="keyword">int</span> arg0, <span class="keyword">int</span> arg1) &#123;</span><br><span class="line">    rax = *(int32_t *)(arg0 + <span class="number">0x20</span>) * arg1;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中调用方法<code>objc_retainBlock</code><br>查看runtime源码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_retainBlock(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)_Block_copy(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处调用了<code>_Block_copy</code>，此处实现将block从栈上拷贝到堆上，保证了返回后的 block 仍然可以正确执行。<br>查看block源码发现内部还调用<code>_Block_object_assign</code>将对象赋值给block的结构体成员变量并持有该对象</p><h2 id="变量的copy"><a href="#变量的copy" class="headerlink" title="变量的copy"></a>变量的copy</h2><ul><li><p>block引用外部变量，默认是将变量进行copy，因此在block内部对变量的修改不会影响外部的使用<br><img src="/images/block的实现_外部变量.png" alt="block的实现_外部变量"></p></li><li><p><code>__block</code>引用外部变量，默认是将变量的地址进行copy<br><img src="/images/block的实现_外部变量2.png" alt="block的实现_外部变量2"></p></li></ul><h2 id="不看源码看结果（block截获局部变量）"><a href="#不看源码看结果（block截获局部变量）" class="headerlink" title="不看源码看结果（block截获局部变量）"></a>不看源码看结果（block截获局部变量）</h2><ul><li><p>普通版</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)block0</span><br><span class="line">&#123;</span><br><span class="line">    blk_t blk;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        blk = ^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">            [array addObject:obj];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"array count: = %zd"</span>,[array count]);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    blk([[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    blk([[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     array count: = 1</span></span><br><span class="line"><span class="comment">     array count: = 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>__weak</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)block1</span><br><span class="line">&#123;</span><br><span class="line">    blk_t blk;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="keyword">id</span> __<span class="keyword">weak</span> array2 = array;</span><br><span class="line">        blk = [^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">            [array2 addObject:obj];</span><br><span class="line">            <span class="comment">//如果打开这句话，两个数组都有值，array被blk持有，array2不为nil</span></span><br><span class="line"><span class="comment">//            NSLog(@"array count: = %zd",[array count]);</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"array2 count: = %zd"</span>,[array2 count]);</span><br><span class="line">        &#125;<span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    blk([[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    blk([[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     array2 count: = 0</span></span><br><span class="line"><span class="comment">     array2 count: = 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//array 在该变量作用域结束的同时被释放、废弃，nil被赋值在附有__weak修饰符的变量array2 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在上面方法的基础上添加 <code>__block</code>修饰array2 结果同理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)block2</span><br><span class="line">&#123;</span><br><span class="line">    blk_t blk;</span><br><span class="line">    &#123;</span><br><span class="line">        id array = [[NSMutableArray alloc] init];</span><br><span class="line">        __block id __weak array2 = array;</span><br><span class="line">        blk = [^(id obj)&#123;</span><br><span class="line">            [array2 addObject:obj];</span><br><span class="line">            NSLog(@&quot;array2 count: = %zd&quot;,[array2 count]);</span><br><span class="line">        &#125;copy];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    blk([[NSObject alloc] init]);</span><br><span class="line">    blk([[NSObject alloc] init]);</span><br><span class="line">    /*</span><br><span class="line">     array2 count: = 0</span><br><span class="line">     array2 count: = 0</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>__unsafe_unretained</code>修饰局部变量</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)block3</span><br><span class="line">&#123;</span><br><span class="line">    blk_t blk;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> array2 = array;</span><br><span class="line">        blk = [^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">            [array2 addObject:obj];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"array2 count: = %zd"</span>,[array2 count]);</span><br><span class="line">        &#125;<span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    blk([[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    blk(@<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     第一次调用blk()的时候，array2是数组，添加obj成功</span></span><br><span class="line"><span class="comment">     当第2次调用blk()的时候，array2是个野指针,不能添加数据，崩溃</span></span><br><span class="line"><span class="comment">     __unsafe_unretained修饰符的变量 与指针相同，和__strong或__weak修饰符不一样的处理，使用的时候需要注意不要通过野指针访问已被废弃的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用计数的变化</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">id</span> block_obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"****block_obj = [%@ , %p] "</span>,block_obj , &amp;block_obj);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"****obj = [%@ , %p]"</span> , obj , &amp;obj);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retain count:%zd\n"</span>,_objc_rootRetainCount(block_obj)); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retain count:%zd\n"</span>,_objc_rootRetainCount(obj)); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"***Block中****block_obj = [%@ , %p] "</span>,block_obj , &amp;block_obj);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"***Block中****obj = [%@ , %p]"</span> , obj , &amp;obj);</span><br><span class="line">&#125;;</span><br><span class="line">myBlock();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retain count:%zd\n"</span>,_objc_rootRetainCount(block_obj)); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retain count:%zd\n"</span>,_objc_rootRetainCount(obj)); <span class="comment">//3</span></span><br></pre></td></tr></table></figure></li></ul><p>可以看到两个对象的指针在block前后变化了，可以证实对象都被拷贝到了堆上<br><code>myBlock()</code>执行前后两个对象的<code>retainCount</code>的变化 :<br>obj经过从栈上拷贝到堆上之后 引用计数为1 -&gt;  3<br><code>__block</code>修饰的变量block_obj，引用计数没有发生变化 1 -&gt; 1</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>1.上面的普通版例子,block没有进行copy,理论上是处于栈上的，但array是有值的，说明block确实进行了copy赋值到堆上，为什么呢<br>解答:<br>在将block0通过Hopper Disassembler 工具将代码进行反编译，得到如下code<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> -[BlockViewController block0](<span class="keyword">void</span> * self, <span class="keyword">void</span> * _cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var_98 = objc_retainBlock(__NSConcreteStackBlock);</span><br><span class="line">    var_A0 = var_18;</span><br><span class="line">    __tsan_write8(var_18);</span><br><span class="line">    var_18 = var_98;</span><br><span class="line">    [var_90 release];</span><br><span class="line">    objc_storeStrong(var_88, <span class="number">0x0</span>);</span><br><span class="line">    objc_storeStrong(var_20, <span class="number">0x0</span>);</span><br><span class="line">    __tsan_read8(var_A0);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>var_98 = objc_retainBlock(__NSConcreteStackBlock);</code>，内部执行<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a heap based copy of a Block or simply add a reference to an existing one.</span></span><br><span class="line"><span class="comment">// This must be paired with Block_release to recover memory, even when running</span></span><br><span class="line"><span class="comment">// under Objective-C Garbage Collection.</span></span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *aBlock)</span><br></pre></td></tr></table></figure></p><p>将block从栈拷贝到了堆上，因此栈上的变量也被一起拷贝到了堆上,block进行clang重写之后得到block实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  id <span class="built_in">array</span>;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, id _array, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="built_in">array</span>(_array) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself, id obj) &#123;</span><br><span class="line">  id <span class="built_in">array</span> = __cself-&gt;<span class="built_in">array</span>; <span class="comment">// bound by copy</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="built_in">array</span>, (<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">blk_t</span> blk;</span><br><span class="line">        &#123;</span><br><span class="line">            id <span class="built_in">array</span> = ((NSMutableArray *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((NSMutableArray *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSMutableArray"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">            blk = ((<span class="keyword">void</span> (*)(id))&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, <span class="built_in">array</span>, <span class="number">570425344</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法里<code>__main_block_impl_0</code>传入的参数<code>array</code>是方法定义的<code>array(_array)</code>，传入array的指针而不是内存地址，所以没办法改变array本身<br>block 调用了 copy 方法，在 <code>_Block_object_assign</code> 中，将 array 赋值给 block 成员变量并持有。所以上面代码可以正常运行，打印出来的 array count 依次递增。</p><p>猜想一下array的retain值<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> blk_t blk;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"array retain count:%zd\n"</span>,_objc_rootRetainCount(array));<span class="comment">//1</span></span><br><span class="line">    blk = ^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">        [array addObject:obj];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"array retain count:%zd\n"</span>,_objc_rootRetainCount(array)); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.下面例子的blk结构体 存储了Person类的实例对象person, bound by copy ，但是一般来说bound by copy是代表的值引用，为什么在block内部对person的eat字段的改变可以改变到block外部的结果，感觉像是bound by ref<br>此处不知道怎么验证block内部的Person实例对象是和block外是一样的<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">person.eat = <span class="string">@"山珍海味"</span>;</span><br><span class="line">blk_t blk = [</span><br><span class="line">               ^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">                   person.eat = <span class="string">@"牛肉"</span>;</span><br><span class="line">               &#125;<span class="keyword">copy</span>];</span><br><span class="line">  </span><br><span class="line">blk(@<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person.eat);</span><br></pre></td></tr></table></figure></p><p>首先blk在执行<code>copy</code>将person对象从栈拷贝到了堆上，引起了对象的引用计数的变化</p><p>下面看下clang之后的c++源码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  Person *person; <span class="comment">//引用的外部变量</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, Person *_person, <span class="keyword">int</span> flags=<span class="number">0</span>) : person(_person) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself, id obj) &#123;</span><br><span class="line">  Person *person = __cself-&gt;person; <span class="comment">// bound by copy</span></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;person, (<span class="keyword">void</span>*)src-&gt;person, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;person, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        Person *person = ((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"Person"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(id, SEL, NSString *))(<span class="keyword">void</span> *)objc_msgSend)((id)person, sel_registerName(<span class="string">"setEat:"</span>), (NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main_0a2365_mi_0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">blk_t</span> blk = (<span class="keyword">blk_t</span>)((id (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((<span class="keyword">void</span> (*)(id))&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, person, <span class="number">570425344</span>)), sel_registerName(<span class="string">"copy"</span>));</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSNumber *(*)(Class, SEL, <span class="keyword">int</span>))(<span class="keyword">void</span> *)objc_msgSend)(objc_getClass(<span class="string">"NSNumber"</span>), sel_registerName(<span class="string">"numberWithInt:"</span>), <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main_0a2365_mi_2,((NSString *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)person, sel_registerName(<span class="string">"eat"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在main里面的blk闭包中的__main_block_impl_0结构体，初始化如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">blk_t</span> blk = (<span class="keyword">blk_t</span>)((id (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((<span class="keyword">void</span> (*)(id))&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, person, <span class="number">570425344</span>)), sel_registerName(<span class="string">"copy"</span>));</span><br><span class="line"></span><br><span class="line">impl.isa = &amp;_NSConcreteMallocBlock;</span><br><span class="line">impl.Flags = <span class="number">570425344</span>;</span><br><span class="line">impl.FuncPtr = __main_block_impl_0; </span><br><span class="line">Desc = &amp;__main_block_desc_0_DATA;</span><br><span class="line">*person = person;</span><br></pre></td></tr></table></figure></p><p>__main_block_impl_0结构体就是这样把自动变量捕获进来的</p><p><code>__main_block_copy_0</code> 和 <code>__main_block_dispose_0</code>函数实现将捕获的外部变量进行retain和dispose<br>BLOCK_FIELD_IS_OBJECT 标识符代表此处捕获的是OC对象<br>如果是BLOCK_FIELD_IS_BYREF  代表捕获的是__block自动变量</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在ARC环境下，block捕获了外部变量，都会对变量进行copy,<br><code>__block</code>修饰的变量,会被捕获到Block内部持有</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="noopener">https://blog.devtang.com/2013/07/28/a-look-inside-blocks/</a><br><a href="http://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="noopener">http://clang.llvm.org/docs/Block-ABI-Apple.html</a><br><a href="http://www.saitjr.com/ios/advance-block.html" target="_blank" rel="noopener">http://www.saitjr.com/ios/advance-block.html</a><br>《Pro Multithreading and Memory Management for iOS and OS X with ARC》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在OC当中我们经常使用block，block的结构体如下&lt;a href=&quot;http://clang.llvm.org/docs/Block-ABI-Apple.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘自clang&lt;/a&gt;:&lt;br&gt;&lt;fig
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactiveObjc-RACChannel</title>
    <link href="https://pattyxp.github.io/2018/04/02/ReactiveObjc-RACChannel/"/>
    <id>https://pattyxp.github.io/2018/04/02/ReactiveObjc-RACChannel/</id>
    <published>2018-04-02T06:10:56.000Z</published>
    <updated>2018-05-18T03:34:01.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RACChannel"><a href="#RACChannel" class="headerlink" title="RACChannel"></a>RACChannel</h2><p>在 RAC 的世界中，消息不仅仅会单向流动，也存在双向流动，对应到 OC，如viewModel的属性和View的属性相互影响,这就体现出 RACChannel的作用,从概念上讲，RACChannel可以看作是双向连接，由两个可控制的信号并行工作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACChannel</span>&lt;<span class="title">ValueType</span>&gt; : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACChannelTerminal&lt;ValueType&gt; *leadingTerminal;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACChannelTerminal&lt;ValueType&gt; *followingTerminal;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p> RACChannel 和 RACChannelTerminal 息息相关</p><h3 id="RACChannelTerminal"><a href="#RACChannelTerminal" class="headerlink" title="RACChannelTerminal"></a>RACChannelTerminal</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACChannelTerminal</span>&lt;<span class="title">ValueType</span>&gt; : <span class="title">RACSignal</span>&lt;<span class="title">ValueType</span>&gt; &lt;<span class="title">RACSubscriber</span>&gt;</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init __attribute__((unavailable(<span class="string">"Instantiate a RACChannel instead"</span>)));</span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">nullable</span> ValueType)value;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// The values for this terminal.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;ValueType&gt; *values;</span><br><span class="line"><span class="comment">/// A subscriber will will send values to the other terminal.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;RACSubscriber&gt; otherTerminal;</span><br></pre></td></tr></table></figure><p>RACChannelTerminal 既可以发送信号，也可以订阅信号</p><ul><li>初始化<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithValues:(RACSignal *)values otherTerminal:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)otherTerminal &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(values != <span class="literal">nil</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(otherTerminal != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_values = values;</span><br><span class="line">_otherTerminal = otherTerminal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>其中 values、otherTerminal 分别表示 RACChannelTerminal 的两个端点。在订阅者调用 -subscribeNext: 等方法发起订阅时，实际上订阅的是self.values 信号；如果向当前端点发送消息，会使用 self.otherTerminal 来发送消息，不是使用 self.values 的订阅者来发送消息</p><ul><li>RACSignal<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span>.values subscribe:subscriber]; <span class="comment">//实际被订阅的是values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>执行<code>RACReplaySubject</code>对象的<code>subscribe</code>方法,向订阅者发送values</p><ul><li>遵循<code>RACSubscriber</code> 协议<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">[<span class="keyword">self</span>.otherTerminal sendNext:value]; <span class="comment">//实际调用self.otherTerminal 发送消息</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h3 id="RACChannel-初始化"><a href="#RACChannel-初始化" class="headerlink" title="RACChannel 初始化"></a>RACChannel 初始化</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// We don't want any starting value from the leadingSubject, but we do want</span></span><br><span class="line"><span class="comment">// error and completion to be replayed.</span></span><br><span class="line">RACReplaySubject *leadingSubject = [[RACReplaySubject replaySubjectWithCapacity:<span class="number">0</span>] setNameWithFormat:<span class="string">@"leadingSubject"</span>];</span><br><span class="line">RACReplaySubject *followingSubject = [[RACReplaySubject replaySubjectWithCapacity:<span class="number">1</span>] setNameWithFormat:<span class="string">@"followingSubject"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate errors and completion to everything.</span></span><br><span class="line">[[leadingSubject ignoreValues] subscribe:followingSubject];</span><br><span class="line">[[followingSubject ignoreValues] subscribe:leadingSubject];</span><br><span class="line"></span><br><span class="line">_leadingTerminal = [[[RACChannelTerminal alloc] initWithValues:leadingSubject otherTerminal:followingSubject] setNameWithFormat:<span class="string">@"leadingTerminal"</span>];</span><br><span class="line">_followingTerminal = [[[RACChannelTerminal alloc] initWithValues:followingSubject otherTerminal:leadingSubject] setNameWithFormat:<span class="string">@"followingTerminal"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>RACReplaySubject 将之前发送的值都进行保存，订阅的时候会向当前的订阅者遍历调用之前接收到的values<br>根据传入的参数capacity，<br><code>leadingSubject</code>的capacity为0, 不需要订阅的时候就执行消息发送<br><code>followingSubject</code>的capacity为1,需要在订阅的时候执行最新一次接收的值，供外部订阅需要初始值</p></li><li><p>leadingSubject 和 followingSubject 相互订阅<br>默认都接收Completed和Error信号，防止任一信号结束另一个还在执行的问题</p></li></ul><h3 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h3><p>RACChannel 采用了双向绑定的思想，在使用过程中，一般通过它的子类 RACKVOChannel 实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACChannelTo(<span class="keyword">self</span>,nameA) = RACChannelTo(<span class="keyword">self</span>,nameB);</span><br><span class="line"><span class="keyword">self</span>.nameA = <span class="string">@"John"</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"nameA:%@-nameB:%@"</span>,<span class="keyword">self</span>.nameA,<span class="keyword">self</span>.nameB);</span><br></pre></td></tr></table></figure><ul><li><p>源码<br><code>RACChannelTo</code>是宏，<code>RACChannelTo(self,nameA)</code>展开</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RACKVOChannel alloc] initWithTarget:<span class="keyword">self</span> keyPath:<span class="string">@"nameA"</span> nilValue:<span class="literal">nil</span>][<span class="string">@"followingTerminal"</span>]</span><br></pre></td></tr></table></figure></li><li><p>作用<br>为nameA和nameB 分别创建了channelA和channelB<br>调用channelA[@”followingTerminal”] = channelB[@”followingTerminal”]</p></li></ul><p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameA:John-nameB:John</span><br></pre></td></tr></table></figure></p><ul><li>实现原理<br>覆写下面两个方法，实现双向绑定<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RACKVOChannel</span> (<span class="title">RACChannelTo</span>)</span></span><br><span class="line"></span><br><span class="line">- (RACChannelTerminal *)objectForKeyedSubscript:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(key != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">RACChannelTerminal *terminal = [<span class="keyword">self</span> valueForKey:key];</span><br><span class="line"><span class="built_in">NSCAssert</span>([terminal isKindOfClass:RACChannelTerminal.class], <span class="string">@"Key \"%@\" does not identify a channel terminal"</span>, key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> terminal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(RACChannelTerminal *)otherTerminal forKeyedSubscript:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(otherTerminal != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">RACChannelTerminal *selfTerminal = [<span class="keyword">self</span> objectForKeyedSubscript:key];</span><br><span class="line">[otherTerminal subscribe:selfTerminal];</span><br><span class="line">[[selfTerminal skip:<span class="number">1</span>] subscribe:otherTerminal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>内部实际是对 <code>followingTerminal</code>相互订阅,在反向绑定的时候就可以skip:1来节约性能</p><h2 id="RACChannel-扩展"><a href="#RACChannel-扩展" class="headerlink" title="RACChannel 扩展"></a>RACChannel 扩展</h2><p>这些函数都会返回一个对应的RACChannelTerminal,可以定制使用结合</p><ul><li>[NSUserDefaults rac_channelTerminalForKey:]</li><li>[UIDatePicker rac_newDateChannelWithNilValue:]</li><li>[UISegmentedControl rac_newSelectedSegmentIndexChannelWithNilValue:]</li><li>[UISlider rac_newValueChannelWithNilValue:]</li><li>[UITextField rac_newTextChannel:]</li></ul><h2 id="RAC相关的宏"><a href="#RAC相关的宏" class="headerlink" title="RAC相关的宏"></a>RAC相关的宏</h2><ul><li><code>RAC(TARGET, [KEYPATH, [NIL_VALUE]])</code></li></ul><p>EXAMPLES:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RAC(<span class="keyword">self</span>, objectProperty) = objectSignal;</span><br><span class="line">RAC(<span class="keyword">self</span>, stringProperty, <span class="string">@"foobar"</span>) = stringSignal;</span><br><span class="line">RAC(<span class="keyword">self</span>, integerProperty, @<span class="number">42</span>) = integerSignal;</span><br></pre></td></tr></table></figure></p><p>RAC()总是出现在等号左边，等号右边是一个RACSignal，表示的意义是将一个对象的一个属性和一个signal绑定，signal每产生一个value（id类型），都会自动执行：<code>[TARGET setValue:value ?: NIL_VALUE forKeyPath:KEYPATH];</code></p><ul><li><code>RACObserve(TARGET, KEYPATH)</code> :观察TARGET的KEYPATH属性，相当于KVO，产生一个RACSignal<br>EXAMPLES:<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *selfSignal = RACObserve(<span class="keyword">self</span>, arrayController.items);</span><br><span class="line"></span><br><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">   RACSignal *signal3 = [anotherSignal flattenMap:^(<span class="built_in">NSArrayController</span> *arrayController) &#123;</span><br><span class="line">       <span class="comment">// Avoids a retain cycle because of RACObserve implicitly referencing self.</span></span><br><span class="line">       @strongify(<span class="keyword">self</span>);</span><br><span class="line">       <span class="keyword">return</span> RACObserve(arrayController, items);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure></li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="noopener">http://blog.sunnyxx.com/2014/03/06/rac_1_macros/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RACChannel&quot;&gt;&lt;a href=&quot;#RACChannel&quot; class=&quot;headerlink&quot; title=&quot;RACChannel&quot;&gt;&lt;/a&gt;RACChannel&lt;/h2&gt;&lt;p&gt;在 RAC 的世界中，消息不仅仅会单向流动，也存在双向流动，对应到 OC，如
      
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="https://pattyxp.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveObjc-RACCommand</title>
    <link href="https://pattyxp.github.io/2018/03/26/ReactiveObjc-RACCommand/"/>
    <id>https://pattyxp.github.io/2018/03/26/ReactiveObjc-RACCommand/</id>
    <published>2018-03-26T02:57:28.000Z</published>
    <updated>2018-05-18T03:34:08.405Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文源码为 ReactiveObjc 3.1.0 版本</p><p>在ReactiveObjc 世界中，不仅仅存在RACSignal这样的信号，还存在一些绑定关系的操作集合，比如按钮的点击事件，按钮点击的时候，事物操作事先就定义好了，RACCommand 可以应用于此</p><h2 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACCommand</span>&lt;<span class="title">__contravariant</span> <span class="title">InputType</span>, <span class="title">__covariant</span> <span class="title">ValueType</span>&gt; : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;RACSignal&lt;ValueType&gt; *&gt; *executionSignals;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;<span class="built_in">NSNumber</span> *&gt; *executing;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;<span class="built_in">NSNumber</span> *&gt; *enabled;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;<span class="built_in">NSError</span> *&gt; *errors;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSignalBlock:(RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input))signalBlock;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEnabled:(<span class="keyword">nullable</span> RACSignal&lt;<span class="built_in">NSNumber</span> *&gt; *)enabledSignal signalBlock:(RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input))signalBlock;</span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)execute:(<span class="keyword">nullable</span> InputType)input;</span><br></pre></td></tr></table></figure><p>RACCommand 继承自NSObject，是一个对象，但是可以用于创建和订阅信号</p><p>对外声明包含四个属性</p><ul><li><p>executionSignals<br>属于高阶信号，需要进行降级操作,通常使用 flatten，switchToLatest，concat<br>如果在允许Concurrent并发的RACCommand中一般使用flatten。<br>在不允许Concurrent并发的RACCommand中一般使用switchToLatest</p></li><li><p>executing:当前RACCommand是否在执行</p></li><li><p>enabled:RACCommand是否可用</p></li><li><p>errors:RACCommand执行过程中产生的错误信号</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACCommand</span> () </span>&#123;</span><br><span class="line"><span class="comment">// Atomic backing variable for `allowsConcurrentExecution`.</span></span><br><span class="line"><span class="keyword">volatile</span> uint32_t _allowsConcurrentExecution;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A subject that sends added execution signals.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSubject *addedExecutionSignalsSubject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A subject that sends the new value of `allowsConcurrentExecution` whenever it changes.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSubject *allowsConcurrentExecutionSubject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `enabled`, but without a hop to the main thread.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Values from this signal may arrive on any thread.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal *immediateEnabled;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The signal block that the receiver was initialized with.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSignal * (^signalBlock)(<span class="keyword">id</span> input);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><ul><li>allowsConcurrentExecution :是否允许并发执行<br>定义类型是volatile</li></ul><p>在使用时 重写 get 和 set方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark Properties</span><br><span class="line"></span><br><span class="line">- (BOOL)allowsConcurrentExecution &#123;</span><br><span class="line">return _allowsConcurrentExecution != 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setAllowsConcurrentExecution:(BOOL)allowed &#123;</span><br><span class="line">if (allowed) &#123;</span><br><span class="line">OSAtomicOr32Barrier(1, &amp;_allowsConcurrentExecution); //原子运算，保证只执行一次</span><br><span class="line">&#125; else &#123;</span><br><span class="line">OSAtomicAnd32Barrier(0, &amp;_allowsConcurrentExecution);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[self.allowsConcurrentExecutionSubject sendNext:@(_allowsConcurrentExecution)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>RACCommand 对外暴露两个初始化方法和一个execute方法</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithSignalBlock:(RACSignal * (^)(id input))signalBlock &#123;</span><br><span class="line">    return [self initWithEnabled:nil signalBlock:signalBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用 initWithEnabled:signalBlock 方法，对 executionSignals，executing，enabled，errors的初始化<br>初始化方法比较复杂，内部创建了7个高阶信号，如果先简略信号的创建，实现如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithEnabled:(RACSignal *)enabledSignal signalBlock:(RACSignal&lt;<span class="keyword">id</span>&gt; * (^)(<span class="keyword">id</span> input))signalBlock &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_addedExecutionSignalsSubject = [RACSubject new];</span><br><span class="line">_signalBlock = [signalBlock <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">_executionSignals = ...;</span><br><span class="line">_errors = ...;</span><br><span class="line">RACSignal *immediateExecuting = ...;</span><br><span class="line">_executing = ...;</span><br><span class="line">RACSignal *moreExecutionsAllowed = ...;</span><br><span class="line">_immediateEnabled =...;</span><br><span class="line">_enabled = ...;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>immediateExecuting 表示当前是否有任务在执行<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *immediateExecuting = [[[[<span class="keyword">self</span>.addedExecutionSignalsSubject</span><br><span class="line">flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line"><span class="keyword">return</span> [[[signal</span><br><span class="line">catchTo:[RACSignal empty]]</span><br><span class="line">then:^&#123;</span><br><span class="line"><span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:@<span class="number">-1</span>];</span><br><span class="line">&#125;]</span><br><span class="line">startWith:@<span class="number">1</span>];</span><br><span class="line">&#125;]</span><br><span class="line">scanWithStart:@<span class="number">0</span> reduce:^(<span class="built_in">NSNumber</span> *running, <span class="built_in">NSNumber</span> *next) &#123;</span><br><span class="line"><span class="keyword">return</span> @(running.integerValue + next.integerValue);</span><br><span class="line">&#125;]</span><br><span class="line">map:^(<span class="built_in">NSNumber</span> *count) &#123;</span><br><span class="line"><span class="keyword">return</span> @(count.integerValue &gt; <span class="number">0</span>);</span><br><span class="line">&#125;]</span><br><span class="line">startWith:@NO];</span><br></pre></td></tr></table></figure></li></ul><p>1.flattenMap 将每一个信号的开始和结束的时间点转换成 1 和 -1 两个信号<br>    catchTo: 将捕获到的错误信号都返回 RACEmptySignal空信号,当信号发送完毕，执行then方法的block生成RACReturnSignal信号,发送-1.<br>    startWith 先发送1，然后执行原信号<br>2.scanWithStart 初始化值为0，累加原信号发出的所有的值<br>3.map 将大于0的信号转为 YES<br>4.startWith 在信号序列最前面加入 @NO，表示在最开始时，没有任何动作在执行。</p><p><a href="https://pattyxp.github.io/2018/03/24/ReactiveObjc-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C/">具体方法的实现分析查看</a></p><p>整个流程如下<a href="https://github.com/Draveness/analyze/blob/43d828b6f516a57e12eeff69913ff49cc94a0f36/contents/ReactiveObjC/RACCommand.md" target="_blank" rel="noopener">图片来源</a><br><img src="/images/ImmediateExecutingSignal.png" alt="ImmediateExecutingSignal"></p><ul><li>moreExecutionsAllowed 判断是否允许并发执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *moreExecutionsAllowed = [RACSignal</span><br><span class="line">if:[self.allowsConcurrentExecutionSubject startWith:@NO]</span><br><span class="line">then:[RACSignal return:@YES]</span><br><span class="line">else:[immediateExecuting not]];</span><br></pre></td></tr></table></figure></li></ul><p>如果允许并发执行，那么执行then操作，否则执行else操作<br>else操作是对 immediateExecuting 取反</p><ul><li>executionSignals<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_executionSignals = [[[self.addedExecutionSignalsSubject</span><br><span class="line">  map:^(RACSignal *signal) &#123;</span><br><span class="line">    return [signal catchTo:[RACSignal empty]];</span><br><span class="line">  &#125;]</span><br><span class="line">  deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">  setNameWithFormat:@&quot;%@ -executionSignals&quot;, self];</span><br></pre></td></tr></table></figure></li></ul><p>map 函数操作是对信号进行变换,当接收到错误信号会返回空信号<br>executionSignals 将返回的信号都派发到在主线程中。</p><p>catchTo方法<a href="https://pattyxp.github.io/2018/03/24/ReactiveObjc-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C/">此文有介绍</a></p><ul><li>executing信号 :判断是否正在执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_executing = [[[[[immediateExecuting</span><br><span class="line">deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">// This is useful before the first value arrives on the main thread.</span><br><span class="line">startWith:@NO]</span><br><span class="line">distinctUntilChanged]</span><br><span class="line">replayLast]</span><br><span class="line">setNameWithFormat:@&quot;%@ -executing&quot;, self];</span><br></pre></td></tr></table></figure></li></ul><p>信号在主线程执行，<br>内部调用distinctUntilChanged,初始值为NO，当值变化的时候，通过 replayLast方法 生成 <code>[RACReplaySubject replaySubjectWithCapacity:1]</code>保存最新值的信号，不关心过去的值<br>返回热信号 RACMulticastConnection</p><ul><li>enabled : 判断RACCommand对象是否能够执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_immediateEnabled = [[[[RACSignal</span><br><span class="line">combineLatest:@[ enabledSignal, moreExecutionsAllowed ]]</span><br><span class="line">and]</span><br><span class="line">takeUntil:self.rac_willDeallocSignal]</span><br><span class="line">replayLast];</span><br><span class="line"></span><br><span class="line">_enabled = [[[[[self.immediateEnabled</span><br><span class="line">take:1]</span><br><span class="line">concat:[[self.immediateEnabled skip:1] deliverOn:RACScheduler.mainThreadScheduler]]</span><br><span class="line">distinctUntilChanged]</span><br><span class="line">replayLast]</span><br><span class="line">setNameWithFormat:@&quot;%@ -enabled&quot;, self];</span><br></pre></td></tr></table></figure></li></ul><p>依赖于私有信号immediateEnabled<br>这里涉及到了combineLatest:的变换操作，<a href="https://pattyxp.github.io/2018/03/24/ReactiveObjc-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C/">这个操作在这里有介绍</a>。combineLatest:的作用就是把后面数组里面传入的每个信号，不管是谁发送出来一个信号，都会把数组里面所有信号的最新的值组合到一个RACTuple里面。immediateEnabled会把每个RACTuple里面的元素都进行逻辑and运算，这样immediateEnabled信号里面装的也都是BOOL值了。<br>当前 RACCommand 执行 dealloc 之后就不会执行<code>self.rac_willDeallocSignal</code>信号</p><p>_enabled 与 enabledSignal、moreExecutionsAllowed、rac_willDeallocSignal 都有关系</p><p>immediateEnabled 在每次原信号发送消息时都会重新计算<br>_enabled 有点差别,调用了<code>-distinctUntilChanged</code>方法，所以如果连续几次值相同就不会再次发送任何消息。<br>调用skip:方法，第一个值以后的每个值都发送在主线程上<br>-take:1和 -concat: 第一个值在一订阅的时候就发送出去了，同订阅者所在线程一致。</p><ul><li>errors 信号初始化<br>RACCommand 能将error信号进行收集统一处理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACMulticastConnection *errorsConnection = [[[self.addedExecutionSignalsSubject</span><br><span class="line">  flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line">    return [[signal</span><br><span class="line">      ignoreValues]</span><br><span class="line">      catch:^(NSError *error) &#123;</span><br><span class="line">        return [RACSignal return:error];</span><br><span class="line">      &#125;];</span><br><span class="line">  &#125;]</span><br><span class="line">  deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">  publish];</span><br><span class="line"></span><br><span class="line">_errors = [errorsConnection.signal setNameWithFormat:@&quot;%@ -errors&quot;, self];</span><br><span class="line">[errorsConnection connect];</span><br></pre></td></tr></table></figure></li></ul><p>内部调用 ignoreValues/catch 方法 进行信号转换<br>将addedExecutionSignalsSubject 内原信号的错误信息都返回 RACReturnSignal对象</p><ul><li>execute 执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)execute:(id)input &#123;</span><br><span class="line"></span><br><span class="line">//判断能够执行任务</span><br><span class="line">BOOL enabled = [[self.immediateEnabled first] boolValue];</span><br><span class="line">if (!enabled) &#123;</span><br><span class="line"></span><br><span class="line">NSError *error = [NSError errorWithDomain:RACCommandErrorDomain code:RACCommandErrorNotEnabled userInfo:@&#123;</span><br><span class="line">NSLocalizedDescriptionKey: NSLocalizedString(@&quot;The command is disabled and cannot be executed&quot;, nil),</span><br><span class="line">RACUnderlyingCommandErrorKey: self</span><br><span class="line">&#125;];</span><br><span class="line">//如果不能执行，直接返回 Error信号</span><br><span class="line">return [RACSignal error:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据初始化时候的signalBlock产生信号</span><br><span class="line">RACSignal *signal = self.signalBlock(input);</span><br><span class="line">NSCAssert(signal != nil, @&quot;nil signal returned from signal block for value: %@&quot;, input);</span><br><span class="line"></span><br><span class="line">//将冷信号转为热信号</span><br><span class="line">RACMulticastConnection *connection = [[signal</span><br><span class="line">subscribeOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">multicast:[RACReplaySubject subject]];</span><br><span class="line"></span><br><span class="line">//只有在此处对 addedExecutionSignalsSubject对象进行操作 ，生产信息</span><br><span class="line">[self.addedExecutionSignalsSubject sendNext:connection.signal];</span><br><span class="line"></span><br><span class="line">// 将 RACSignal 和 RACReplaySubject 进行连接</span><br><span class="line">[connection connect];</span><br><span class="line">return [connection.signal setNameWithFormat:@&quot;%@ -execute: %@&quot;, self, RACDescription(input)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 signalBlock 返回一个 RACSignal 之后，会将当前信号包装成一个 RACMulticastConnection，然后调用 -sendNext: 方法发送到 addedExecutionSignalsSubject 上，执行 -connect 方法订阅原有的信号，最后返回。</p><ul><li>事例</li></ul><p>通常 RACCommand 特别适合网络请求或者 UI相关操作上，可以结合MVVM模式进行使用，<a href="https://github.com/Draveness/analyze/blob/43d828b6f516a57e12eeff69913ff49cc94a0f36/contents/ReactiveObjC/RACCommand.md" target="_blank" rel="noopener">来源</a><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(<span class="built_in">NSNumber</span> * _Nullable input) &#123;</span><br><span class="line"><span class="comment">// block1</span></span><br><span class="line"><span class="keyword">return</span> [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line"><span class="comment">// block2</span></span><br><span class="line"><span class="built_in">NSInteger</span> integer = [input integerValue];</span><br><span class="line">[subscriber sendNext:@(integerValue)];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;];</span><br><span class="line">[[command.executionSignals switchToLatest] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line"><span class="comment">//block3</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"value:%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[command execute:@<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p><p>订阅 executionSignals和错误信号 来获取请求结果<br>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value:1</span><br></pre></td></tr></table></figure></p><p>分析下流程</p><ol><li>先创建 RACCommand 对象，将入参进行copy<code>[signalBlock copy]</code><br>  初始化内部的信号</li><li>执行<code>[[command.executionSignals switchToLatest]</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)switchToLatest &#123;</span><br><span class="line">// block4</span><br><span class="line">return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">// block5</span><br><span class="line">RACMulticastConnection *connection = [self publish]; //产生热信号</span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [[connection.signal</span><br><span class="line">flattenMap:^(RACSignal *x) &#123;  //对原信号进行变换</span><br><span class="line"></span><br><span class="line">NSCAssert(x == nil || [x isKindOfClass:RACSignal.class], @&quot;-switchToLatest requires that the source signal (%@) send signals. Instead we got: %@&quot;, self, x);</span><br><span class="line"></span><br><span class="line">return [x takeUntil:[connection.signal concat:[RACSignal never]]];</span><br><span class="line">&#125;]</span><br><span class="line">subscribe:subscriber];</span><br><span class="line"></span><br><span class="line">RACDisposable *connectionDisposable = [connection connect];</span><br><span class="line">return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line">[connectionDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -switchToLatest&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>此处执行 block4,产生新的信号，将block进行copy</li><li><p>对<code>[[command.executionSignals switchToLatest] subscribeNext]</code><br>  执行subscribeNext操作，此处将 switchToLatest产生的信号执行订阅操作，调用信号的 didSubscriber闭包, 此处执行 block5<br> 通过<code>flattenMap</code>对热信号的signal进行变换操作产生新的信号signal1</p><p> <code>[x takeUntil:[connection.signal concat:[RACSignal never]]];</code><br> 先执行<code>concat</code>方法产生新的信号signal2，<code>takeUntil</code>会一直订阅signal2，signal2如果没有收到新值会一直执行<code>sendNext</code>直到signal2有新值会取消订阅信号x，向订阅者发送<code>sendCompleted</code></p><p> 执行<code>[connection connect];</code><br>5.执行<code>execute</code>方法，<code>RACSignal *signal = self.signalBlock(input);</code>调用初始化command时候保存的闭包,此处执行 block1<br> 执行<code>[self.addedExecutionSignalsSubject sendNext:connection.signal];</code><br> 接着执行<code>[connection connect];</code></p></li><li>执行block2</li><li>执行block3</li></ol><ul><li>注意<br>1.如果此处在末尾添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[command execute:@2];</span><br><span class="line">[command execute:@3];</span><br></pre></td></tr></table></figure></li></ul><p>那么只能收到第一个打印结果<code>value:1</code><br>因为RACCommand 默认是非并发执行的，需要等待命令执行结束才能执行下一次操作，所以在<code>execute</code>方法内部，每次都会判断是否可以执行任务，第二次执行的时候进入if条件语句，返回 Error信号，不打印内容</p><p>2.如果此处在末尾添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[RACScheduler.mainThreadScheduler afterDelay:0.1</span><br><span class="line">                                    schedule:^&#123;</span><br><span class="line">                                        [command execute:@2];</span><br><span class="line">                                    &#125;];</span><br><span class="line">[RACScheduler.mainThreadScheduler afterDelay:0.2</span><br><span class="line">                                    schedule:^&#123;</span><br><span class="line">                                        [command execute:@3];</span><br><span class="line">                                    &#125;];</span><br></pre></td></tr></table></figure></p><p>可以收到打印结果<br>每次执行execute方法， executionSignals 中发送了新的信号时，switchToLatest 方法返回的信号都会订阅这个最新的信号，这里也就保证了每次都会打印出最新的信号中的值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RACCommand 将外部的变量 InputType 转换成了使用 RACSignal 包裹的 ValueType 对象。<br>从 -execute: 方法中获得输入InputType，最后以向信号发送消息的方式，向订阅者推送结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文源码为 ReactiveObjc 3.1.0 版本&lt;/p&gt;
&lt;p&gt;在ReactiveObjc 世界中
      
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="https://pattyxp.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveObjc 常用的变换操作</title>
    <link href="https://pattyxp.github.io/2018/03/24/ReactiveObjc-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C/"/>
    <id>https://pattyxp.github.io/2018/03/24/ReactiveObjc-常用的变换操作/</id>
    <published>2018-03-24T08:47:45.000Z</published>
    <updated>2018-05-18T03:34:29.329Z</updated>
    
    <content type="html"><![CDATA[<p>本文源码为 ReactiveObjc 3.1.0 版本</p><p>除了入门篇介绍的一些常用方法，本篇来介绍下过滤和组合相关的方法底层实现</p><ul><li>filter</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)filter:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^ <span class="keyword">id</span> (<span class="keyword">id</span> value) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (block(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -filter:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用flattenMap方法，在上篇已经介绍过了，此处略过。<br>如果满足筛选条件的即返回原信号的值，否则原信号的值被“吞”掉，返回空的信号 RACEmptySignal</p><ul><li>ignoreValues<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)ignoreValues &#123;</span><br><span class="line">    return [[self filter:^(id _) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -ignoreValues&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>ignoreValues 方法是对 filter 方法的封装，原信号的值都会被变换成empty空信号</p><ul><li>ignore:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)ignore:(id)value &#123;</span><br><span class="line">    return [[self filter:^ BOOL (id innerValue) &#123;</span><br><span class="line">        return innerValue != value &amp;&amp; ![innerValue isEqual:value];</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -ignore: %@&quot;, self.name, [value rac_description]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>对入参的value进行判断，当原信号和value不同的时候 返回原信号</p><ul><li>distinctUntilChanged<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)distinctUntilChanged &#123;</span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">        __block <span class="keyword">id</span> lastValue = <span class="literal">nil</span>;</span><br><span class="line">        __block <span class="built_in">BOOL</span> initial = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ^(<span class="keyword">id</span> x, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!initial &amp;&amp; (lastValue == x || [x isEqual:lastValue])) <span class="keyword">return</span> [<span class="keyword">class</span> empty];</span><br><span class="line"></span><br><span class="line">            initial = <span class="literal">NO</span>;</span><br><span class="line">            lastValue = x;</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:x];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -distinctUntilChanged"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>每次变换中都记录一下原信号上一次发送过来的值，并与这一次进行比较，如果是相同的值，返回empty信号。只有和原信号上一次发送的值不同，变换后的新信号才把这个值发送出来。</p><ul><li>take<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)take:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">__block <span class="built_in">NSUInteger</span> taken = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ^ <span class="keyword">id</span> (<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">if</span> (taken &lt; count) &#123;</span><br><span class="line">++taken;</span><br><span class="line"><span class="keyword">if</span> (taken == count) *stop = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -take: %lu"</span>, <span class="keyword">self</span>.name, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>take:实现也非常简单，借助bind函数来实现的。<br>入参的count是原信号取值的个数,在bind的闭包中,taken计数从0开始取原信号的值,当taken取到count个数的时候，就停止取值。</p><ul><li>takeLast<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)takeLast:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *valuesTaken = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:count];</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">[valuesTaken addObject:x ? : RACTupleNil.tupleNil];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (valuesTaken.count &gt; count) &#123;</span><br><span class="line">[valuesTaken removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> value <span class="keyword">in</span> valuesTaken) &#123;</span><br><span class="line">[subscriber sendNext:value == RACTupleNil.tupleNil ? <span class="literal">nil</span> : value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -takeLast: %lu"</span>, <span class="keyword">self</span>.name, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>和take相反，先将接受到的值都存储在可变数组valuesTaken上，当数组的数量超过入参count的值，就将之前的数据进行移除<br>订阅完成之后，通过for循环一次次的发送值<br>注:<br>1.如果值是空的RACTupleNil.tupleNil，就发送nil<br>2.如果原信号一直没有completed，那么takeLast:就一直没法发出任何信号来。</p><ul><li>takeUntilBlock<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)takeUntilBlock:(BOOL (^)(id x))predicate &#123;</span><br><span class="line">NSCParameterAssert(predicate != nil);</span><br><span class="line"></span><br><span class="line">Class class = self.class;</span><br><span class="line"></span><br><span class="line">return [[self bind:^&#123;</span><br><span class="line">return ^ id (id value, BOOL *stop) &#123;</span><br><span class="line">if (predicate(value)) return nil;</span><br><span class="line"></span><br><span class="line">return [class return:value];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -takeUntilBlock:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>内部也是借助bind方法实现，根据传入的predicate闭包作为筛选条件，如果predicate( )闭包满足条件，那么新信号置为nil,停止发送新信号.</p><ul><li>takeWhileBlock<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)takeWhileBlock:(BOOL (^)(id x))predicate &#123;</span><br><span class="line">NSCParameterAssert(predicate != nil);</span><br><span class="line"></span><br><span class="line">return [[self takeUntilBlock:^ BOOL (id x) &#123;</span><br><span class="line">return !predicate(x);</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -takeWhileBlock:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>内部调用takeUntilBlock，只是判断条件和之相反<br>如果满足条件，返回 非空的值，<br>如果不满足条件 返回 nil，停止发送新信号</p><ul><li>takeUntil<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)takeUntil:(RACSignal *)signalTrigger &#123;</span><br><span class="line">return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">void (^triggerCompletion)(void) = ^&#123;</span><br><span class="line">[disposable dispose];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RACDisposable *triggerDisposable = [signalTrigger subscribeNext:^(id _) &#123;</span><br><span class="line">triggerCompletion();</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">triggerCompletion();</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:triggerDisposable];</span><br><span class="line"></span><br><span class="line">if (!disposable.disposed) &#123;</span><br><span class="line">RACDisposable *selfDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[disposable dispose];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:selfDisposable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return disposable;</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -takeUntil: %@&quot;, self.name, signalTrigger];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>产生一个新信号，在新信号中 订阅原信号，只要原信号没有销毁就会一直执行 <code>sendNext</code> ,<br>当入参signalTrigger调用sendNext,那么就会触发triggerCompletion<br>取消原信号，向新产生的信号发送sendCompleted</p><ul><li>skip<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)skip:(NSUInteger)skipCount &#123;</span><br><span class="line">Class class = self.class;</span><br><span class="line"></span><br><span class="line">return [[self bind:^&#123;</span><br><span class="line">__block NSUInteger skipped = 0;</span><br><span class="line"></span><br><span class="line">return ^(id value, BOOL *stop) &#123;</span><br><span class="line">if (skipped &gt;= skipCount) return [class return:value];</span><br><span class="line"></span><br><span class="line">skipped++;</span><br><span class="line">return class.empty;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -skip: %lu&quot;, self.name, (unsigned long)skipCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>借助bind方法，判断执行的次数，如果满足skipCount次数，则发送原信号，否则发送空信号</p><p>skip方法和take方法是补全关系，take是取前几次，skip是跳过前面几次</p><ul><li>skipUntilBlock</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)skipUntilBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(predicate != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">__block <span class="built_in">BOOL</span> skipping = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ^ <span class="keyword">id</span> (<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">if</span> (skipping) &#123;</span><br><span class="line"><span class="keyword">if</span> (predicate(value)) &#123;</span><br><span class="line">skipping = <span class="literal">NO</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -skipUntilBlock:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>skipUntilBlock 和 takeUntilBlock 实现类似<br>以入参 predicate()闭包判断，如果满足条件，skipping = NO,原信号发送的每个值都原封不动的发送出去。<br>不满足条件的时候，即会一直skip原信号的值</p><ul><li>skipWhileBlock<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)skipWhileBlock:(BOOL (^)(id x))predicate &#123;</span><br><span class="line">NSCParameterAssert(predicate != nil);</span><br><span class="line"></span><br><span class="line">return [[self skipUntilBlock:^ BOOL (id x) &#123;</span><br><span class="line">return !predicate(x);</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -skipWhileBlock:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>skipWhileBlock 方法底层调用skipUntilBlock ,只是判断条件是 不满足predicate()闭包</p><ul><li>catch<br>高阶操作，是因为这里原信号发生错误之后，错误会升阶成一个信号。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)catch:(RACSignal * (^)(NSError *error))catchBlock &#123;</span><br><span class="line">NSCParameterAssert(catchBlock != NULL);</span><br><span class="line"></span><br><span class="line">return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACSerialDisposable *catchDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">RACSignal *signal = catchBlock(error);</span><br><span class="line">NSCAssert(signal != nil, @&quot;Expected non-nil signal from catch block on %@&quot;, self);</span><br><span class="line">catchDisposable.disposable = [signal subscribe:subscriber];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[catchDisposable dispose];</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -catch:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当对原信号进行订阅的时候，如果出现错误，会去执行catchBlock()闭包，入参为刚刚产生的error。catchBlock( )闭包产生的是一个新的RACSignal，并再次用之前的订阅者订阅该信号。</p><ul><li>catchTo<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)catchTo:(RACSignal *)signal &#123;</span><br><span class="line">    return [[self catch:^(NSError *error) &#123;</span><br><span class="line">        return signal;</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -catchTo: %@&quot;, self.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>底层调用catch方法,实际是对catch方法的封装,如果订阅发生错误，都返回入参signal</p><ul><li>then<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)then:(RACSignal * (^)(void))block &#123;</span><br><span class="line">    NSCParameterAssert(block != nil);</span><br><span class="line"></span><br><span class="line">    return [[[self</span><br><span class="line">        ignoreValues]</span><br><span class="line">        concat:[RACSignal defer:block]]</span><br><span class="line">        setNameWithFormat:@&quot;[%@] -then:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>将操作进行延迟到 原信号发送完毕之后，再执行block闭包</p><ul><li>defer<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)defer:(RACSignal * (^)(void))block &#123;</span><br><span class="line">    NSCParameterAssert(block != NULL);</span><br><span class="line"></span><br><span class="line">    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        return [block() subscribe:subscriber];</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;+defer:&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当defer返回的新信号被订阅的时候，才会执行入参block( )闭包，block产生信号，订阅者订阅block产生的信号</p><ul><li>startWith<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)startWith:(id)value &#123;</span><br><span class="line">return [[[self.class return:value]</span><br><span class="line">concat:self]</span><br><span class="line">setNameWithFormat:@&quot;[%@] -startWith: %@&quot;, self.name, RACDescription(value)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>先通过return方法产生 RACReturnSignal,发送产生value，然后这个信号发送完毕之后接上原信号。得到的新的信号就是在原信号前面新加了一个值。</p><ul><li>scanWithStart:reduceWithIndex<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)scanWithStart:(<span class="keyword">id</span>)startingValue reduceWithIndex:(<span class="keyword">id</span> (^)(<span class="keyword">id</span>, <span class="keyword">id</span>, <span class="built_in">NSUInteger</span>))reduceBlock &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(reduceBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">        __block <span class="keyword">id</span> running = startingValue;</span><br><span class="line">        __block <span class="built_in">NSUInteger</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            running = reduceBlock(running, value, index++);</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:running];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -scanWithStart: %@ reduceWithIndex:"</span>, <span class="keyword">self</span>.name, [startingValue rac_description]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>内部调用bind方法<br>原信号的每个信号都会由变换函数reduceBlock( )进行变换<br>初始值是入参startingValue,然后index进行自增</p><p>事例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">                      &#123;</span><br><span class="line">                          [subscriber sendNext:@1];</span><br><span class="line">                          [subscriber sendNext:@2];</span><br><span class="line">                          [subscriber sendNext:@4];</span><br><span class="line">                          return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                          &#125;];</span><br><span class="line">                      &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalB = [signalA scanWithStart:@(2) reduceWithIndex:^id(NSNumber * running, NSNumber * next, NSUInteger index) &#123;</span><br><span class="line">    return @(running.intValue * next.intValue + index);</span><br><span class="line">&#125;];</span><br><span class="line">[signalB subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2    // 2 * 1 + 0 = 2</span><br><span class="line">5    // 2 * 2 + 1 = 5</span><br><span class="line">22  // 5 * 4 + 2 = 22</span><br></pre></td></tr></table></figure></p><ul><li>scanWithStart:reduce<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)scanWithStart:(<span class="keyword">id</span>)startingValue reduce:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> running, <span class="keyword">id</span> next))reduceBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(reduceBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span></span><br><span class="line">scanWithStart:startingValue</span><br><span class="line">reduceWithIndex:^(<span class="keyword">id</span> running, <span class="keyword">id</span> next, <span class="built_in">NSUInteger</span> index) &#123;</span><br><span class="line"><span class="keyword">return</span> reduceBlock(running, next);</span><br><span class="line">&#125;]</span><br><span class="line">setNameWithFormat:<span class="string">@"[%@] -scanWithStart: %@ reduce:"</span>, <span class="keyword">self</span>.name, RACDescription(startingValue)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>内部是对 <code>scanWithStart:reduceWithIndex</code> 方法的简化,返回的是入参 reduceBlock ，不进行自增</p><ul><li><p>combineLatestWith<br>从名字就可以看到，是将两个信号进行组合<br>当只接收到一个信号的时候，return<br>当收到两个信号的时候，将两者进行打包<code>RACTuplePack(lastSelfValue, lastOtherValue)</code>,然后发送给订阅者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)combineLatestWith:(RACSignal *)signal &#123;</span><br><span class="line">NSCParameterAssert(signal != nil);</span><br><span class="line"></span><br><span class="line">return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">__block id lastSelfValue = nil;</span><br><span class="line">__block BOOL selfCompleted = NO;</span><br><span class="line"></span><br><span class="line">__block id lastOtherValue = nil;</span><br><span class="line">__block BOOL otherCompleted = NO;</span><br><span class="line"></span><br><span class="line">void (^sendNext)(void) = ^&#123;</span><br><span class="line">@synchronized (disposable) &#123;</span><br><span class="line">if (lastSelfValue == nil || lastOtherValue == nil) return;</span><br><span class="line">[subscriber sendNext:RACTuplePack(lastSelfValue, lastOtherValue)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RACDisposable *selfDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line">@synchronized (disposable) &#123;</span><br><span class="line">lastSelfValue = x ?: RACTupleNil.tupleNil;</span><br><span class="line">sendNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">@synchronized (disposable) &#123;</span><br><span class="line">selfCompleted = YES;</span><br><span class="line">if (otherCompleted) [subscriber sendCompleted];//只有两者都完成，才会发送完成信号</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">RACDisposable *otherDisposable = [signal subscribeNext:^(id x) &#123;</span><br><span class="line">@synchronized (disposable) &#123;</span><br><span class="line">lastOtherValue = x ?: RACTupleNil.tupleNil;</span><br><span class="line">sendNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">@synchronized (disposable) &#123;</span><br><span class="line">otherCompleted = YES;</span><br><span class="line">if (selfCompleted) [subscriber sendCompleted]; //只有两者都完成，才会发送完成信号</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:otherDisposable];</span><br><span class="line"></span><br><span class="line">return disposable;</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -combineLatestWith: %@&quot;, self.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>combineLatest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)combineLatest:(id&lt;NSFastEnumeration&gt;)signals &#123;</span><br><span class="line">return [[self join:signals block:^(RACSignal *left, RACSignal *right) &#123;</span><br><span class="line">return [left combineLatestWith:right];</span><br><span class="line">&#125;] setNameWithFormat:@&quot;+combineLatest: %@&quot;, signals];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>combineLatest:的实现就是把入参数组里面的每个信号都调用一次join: block:方法。传入的闭包是把两个信号combineLatestWith:一下。combineLatest:的实现就是2个操作的组合。</p><ul><li>join:block<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ (__kindof RACStream *)join:(id&lt;NSFastEnumeration&gt;)streams block:(RACStream * (^)(id, id))block &#123;</span><br><span class="line">RACStream *current = nil;</span><br><span class="line">  // 第一步</span><br><span class="line">for (RACStream *stream in streams) &#123;</span><br><span class="line">if (current == nil) &#123;</span><br><span class="line">current = [stream map:^(id x) &#123;</span><br><span class="line">return RACTuplePack(x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">current = block(current, stream);</span><br><span class="line">&#125;</span><br><span class="line">  // 第二步</span><br><span class="line">if (current == nil) return [self empty];</span><br><span class="line"></span><br><span class="line">return [current map:^(RACTuple *xs) &#123;</span><br><span class="line"></span><br><span class="line">NSMutableArray *values = [[NSMutableArray alloc] init];</span><br><span class="line">    //第三步</span><br><span class="line">while (xs != nil) &#123;</span><br><span class="line">[values insertObject:xs.last ?: RACTupleNil.tupleNil atIndex:0];</span><br><span class="line">xs = (xs.count &gt; 1 ? xs.first : nil);</span><br><span class="line">&#125;</span><br><span class="line">    //第四步</span><br><span class="line">return [RACTuple tupleWithObjectsFromArray:values];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>此方法将当前信号流遍历<br>1.先依次打包信号流，首先将第一个信号打包成元组，然后将第一个元组和第二个信号传入block执行，依次类推，知道所有的信号都打包了<br>block操作返回信号，类似于zip，将两个信号进行压缩，只有两个信号都执行完毕才会将最新的值打包出去<br>2.如果current为空，返回空信号<br>3.这一步是把之前第一步打包出来的结果，还原回原信号的过程。经过第一步的循环之后，current会是类似这个样子，(((1), 2), 3)，第三步就是为了把这种多重元组解出来，每个信号流都依次按照顺序放在数组里。注意观察current的特点，最外层的元组，是一个值和一个元组，所以从最外层的元组开始，一层一层往里“剥”。while循环每次都取最外层元组的last，即那个单独的值，插入到数组的第0号位置，然后取出first即是里面一层的元组。然后依次循环。由于每次都插入到数组0号的位置，类似于链表的头插法，最终数组里面的顺序肯定也保证是原信号的顺序<br>4.把还原成原信号顺序 的数组 包装成元组，返回给map操作的闭包<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)tupleWithObjectsFromArray:(<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> tupleWithObjectsFromArray:array convertNullsToNils:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)tupleWithObjectsFromArray:(<span class="built_in">NSArray</span> *)array convertNullsToNils:(<span class="built_in">BOOL</span>)convert &#123;</span><br><span class="line">    RACTuple *tuple = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (convert) &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *newArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:array.count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> array) &#123;</span><br><span class="line">            [newArray addObject:(object == <span class="built_in">NSNull</span>.null ? RACTupleNil.tupleNil : object)];</span><br><span class="line">        &#125;</span><br><span class="line">        tuple.backingArray = newArray;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tuple.backingArray = [array <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tuple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>入参convert为NO，将array进行copy 返回元组</p><ul><li>switchToLatest</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)switchToLatest &#123;</span><br><span class="line"><span class="comment">// block4</span></span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"><span class="comment">// block5</span></span><br><span class="line">RACMulticastConnection *connection = [<span class="keyword">self</span> publish]; <span class="comment">//产生热信号</span></span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [[connection.signal</span><br><span class="line">flattenMap:^(RACSignal *x) &#123;  <span class="comment">//对原信号进行变换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSCAssert</span>(x == <span class="literal">nil</span> || [x isKindOfClass:RACSignal.class], <span class="string">@"-switchToLatest requires that the source signal (%@) send signals. Instead we got: %@"</span>, <span class="keyword">self</span>, x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [x takeUntil:[connection.signal concat:[RACSignal never]]];</span><br><span class="line">&#125;]</span><br><span class="line">subscribe:subscriber];</span><br><span class="line"></span><br><span class="line">RACDisposable *connectionDisposable = [connection connect];</span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line">[connectionDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -switchToLatest"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switchToLatest只能用在高阶信号,通过<code>[self publish];</code>产生热信号<br><code>connection.signal</code> 是 RACSubject 类型, 通过<code>flattenMap</code>方法对信号进行变换<br><code>connection.signal</code>会先<code>concat:</code>一个never信号,</p><p>flattenMap:变换中x是一个信号，对x进行takeUntil:变换，效果就是下一个信号到来之前，x会一直发送信号，一旦下一个信号到来，x就会被取消订阅，开始订阅新的信号。</p><ul><li>zipWith 和 concat</li><li>reduceEach / flattenMap / map /<br><a href="https://pattyxp.github.io/2018/03/12/ReactiveObjc%E5%85%A5%E9%97%A8/">请看这篇文章</a></li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.jianshu.com/p/707ece08257e" target="_blank" rel="noopener">https://www.jianshu.com/p/707ece08257e</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文源码为 ReactiveObjc 3.1.0 版本&lt;/p&gt;
&lt;p&gt;除了入门篇介绍的一些常用方法，本篇来介绍下过滤和组合相关的方法底层实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filter&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="https://pattyxp.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>记录一次坑</title>
    <link href="https://pattyxp.github.io/2018/03/22/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%9D%91/"/>
    <id>https://pattyxp.github.io/2018/03/22/记录一次坑/</id>
    <published>2018-03-22T02:02:47.000Z</published>
    <updated>2018-06-05T08:57:47.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="坑一"><a href="#坑一" class="headerlink" title="坑一"></a>坑一</h2><p>这真是一次莫名其妙的经历<br>场景如下:<br>有一个页面，底下有个按钮，之前都测试的OK,莫名其妙的突然之间不管点击什么地方，都会走按钮的逻辑，检查发现按钮的点击区域没有扩大，甚至点击返回按钮都被触动按钮点击事件，同样的页面，如果没有显示这个按钮一切逻辑倒是正常的，找同事看了下，笑话说如果真的是这样的效果，能做到也不容易啊</p><p>后面发现可能是我电脑缓存的问题，于是把相关的库和工程的缓存都给清理了下，世界清静了 ~ ~ ~</p><h2 id="坑二"><a href="#坑二" class="headerlink" title="坑二"></a>坑二</h2><p>更新Alfred (3.6.1), 原先好好的锁屏功能<code>lock</code> 无法识别了，每次都打开QQ的联系人列表，一直没搞明白，后来查到是因为QQ的联系人列表快捷键冲突的问题导致的（哎，当时怎么没往那方面去思考呢~），修改QQ的联系人快捷键，直接废弃好了，反正感觉不常用，终于可以快捷键锁屏了,速度比之前版本快多了  ~ ~ ~ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;坑一&quot;&gt;&lt;a href=&quot;#坑一&quot; class=&quot;headerlink&quot; title=&quot;坑一&quot;&gt;&lt;/a&gt;坑一&lt;/h2&gt;&lt;p&gt;这真是一次莫名其妙的经历&lt;br&gt;场景如下:&lt;br&gt;有一个页面，底下有个按钮，之前都测试的OK,莫名其妙的突然之间不管点击什么地方，都会走按钮
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactiveObjc-RACSubject</title>
    <link href="https://pattyxp.github.io/2018/03/20/ReactiveObjc-RACSubject/"/>
    <id>https://pattyxp.github.io/2018/03/20/ReactiveObjc-RACSubject/</id>
    <published>2018-03-20T08:36:31.000Z</published>
    <updated>2018-05-18T03:34:24.110Z</updated>
    
    <content type="html"><![CDATA[<p>本文源码为 ReactiveObjc 3.1.0 版本</p><h2 id="RACSubject"><a href="#RACSubject" class="headerlink" title="RACSubject"></a>RACSubject</h2><p>RACSubject 继承自 RACSignal，主要用于将非 RAC 的对象桥接到 RAC ，属于可变信号</p><blockquote><p>A subject can be thought of as a signal that you can manually control by sending next, completed, and error.They’re most helpful in bridging the non-RAC world to RAC, since they let you<br>manually control the sending of events.</p></blockquote><p>RACSubject 与子类<br><img src="/images/RACSubject.png" alt="RACSubject与子类关系"></p><p>RACSubject 对外提供的接口只有两个，遵循<racsubscriber>协议<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACSubject</span>&lt;<span class="title">ValueType</span>&gt; : <span class="title">RACSignal</span>&lt;<span class="title">ValueType</span>&gt; &lt;<span class="title">RACSubscriber</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Returns a new subject.</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)subject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redeclaration of the RACSubscriber method. Made in order to specify a generic type.</span></span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">nullable</span> ValueType)value;</span><br></pre></td></tr></table></figure></racsubscriber></p><ul><li>举例子<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscriber 1</span></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1st Sub: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscriber 2</span></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2nd Sub: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscriber 3</span></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3rd Sub: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">3</span>];</span><br><span class="line">[subject sendCompleted];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 2018-01-17 14:14:56.437059+0800 ReactiveObjcTest[270:1821989] 1st Sub: 1</span></span><br><span class="line"><span class="comment"> 2018-01-17 14:14:56.437269+0800 ReactiveObjcTest[270:1821989] 1st Sub: 2</span></span><br><span class="line"><span class="comment"> 2018-01-17 14:14:56.437387+0800 ReactiveObjcTest[270:1821989] 2nd Sub: 2</span></span><br><span class="line"><span class="comment"> 2018-01-17 14:14:56.437594+0800 ReactiveObjcTest[270:1821989] 1st Sub: 3</span></span><br><span class="line"><span class="comment"> 2018-01-17 14:14:56.438327+0800 ReactiveObjcTest[270:1821989] 2nd Sub: 3</span></span><br><span class="line"><span class="comment"> 2018-01-17 14:14:56.438564+0800 ReactiveObjcTest[270:1821989] 3rd Sub: 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> RACSubject 是时间相关的，它在发送消息时只会向已订阅的订阅者推送消息。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul><p>当调用sendNext方法<br>内部遍历当前数组内的subscriber，发送消息，和父类的不同就是可以先订阅，再发送信息，能否接收到消息取决于订阅的时间<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">[<span class="keyword">self</span> enumerateSubscribersUsingBlock:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendNext:value];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="热信号-和-冷信号"><a href="#热信号-和-冷信号" class="headerlink" title="热信号 和 冷信号"></a>热信号 和 冷信号</h2><p>在 <a href="https://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-1.html" target="_blank" rel="noopener">细说ReactiveCocoa的冷信号与热信号（一）</a> 详细分析了冷热信号的特点：<br>&gt;<br>热信号是主动的，即使你没有订阅事件，它仍然会时刻推送。而冷信号是被动的，只有当你订阅的时候，它才会发送消息。<br>热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息。而冷信号只能一对一，当有不同的订阅者，消息会从新完整发送。</p><p>在RAC中，RACSignal 属于冷信号， 每个订阅者会收到所有的消息<br>RACSubject 属于热信号，消息的接收取决于订阅的时间</p><p>从上面的例子中，可以观察到，由于 subscribeNext 调用时机不同，收到的消息内容序列不一样</p><ul><li>调用 subscribeNext 方法, 产生 RACSubscriber</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSignal.m</span><br><span class="line">- (RACDisposable *)subscribeNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))nextBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(nextBlock != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:<span class="literal">NULL</span> completed:<span class="literal">NULL</span>];</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写 <code>subscribe</code> 方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(subscriber != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="keyword">self</span> disposable:disposable];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> *subscribers = <span class="keyword">self</span>.subscribers;</span><br><span class="line"><span class="keyword">@synchronized</span> (subscribers) &#123;</span><br><span class="line">[subscribers addObject:subscriber];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:[RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (subscribers) &#123;</span><br><span class="line"><span class="comment">// Since newer subscribers are generally shorter-lived, search</span></span><br><span class="line"><span class="comment">// starting from the end of the list.</span></span><br><span class="line"><span class="built_in">NSUInteger</span> index = [subscribers indexOfObjectWithOptions:<span class="built_in">NSEnumerationReverse</span> passingTest:^ <span class="built_in">BOOL</span> (<span class="keyword">id</span>&lt;RACSubscriber&gt; obj, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">return</span> obj == subscriber;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index != <span class="built_in">NSNotFound</span>) [subscribers removeObjectAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line">&#125;]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的作用</p><ul><li>产生 RACPassthroughSubscriber 实例</li><li>将生成的 subscriber 添加入 RACSubject 拥有的数组里</li><li>创建 disposable对象，在当前 subscriber 销毁时，将 自身从数组中移除</li></ul><ul><li>sendNext</li></ul><p>由于 RACSubject 遵循了<racsubscriber>协议<br>所以可以调用 sendNext 等一系列方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">[<span class="keyword">self</span> enumerateSubscribersUsingBlock:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendNext:value];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">[<span class="keyword">self</span>.disposable dispose];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> enumerateSubscribersUsingBlock:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendCompleted &#123;</span><br><span class="line">[<span class="keyword">self</span>.disposable dispose];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> enumerateSubscribersUsingBlock:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></racsubscriber></p><p>以上方法都是调用forin 遍历自身的subscribes数组，调用block<br>这里会向每个 subscriber 都调用block<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enumerateSubscribersUsingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))block &#123;</span><br><span class="line"><span class="built_in">NSArray</span> *subscribers;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>.subscribers) &#123;</span><br><span class="line">subscribers = [<span class="keyword">self</span>.subscribers <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber <span class="keyword">in</span> subscribers) &#123;</span><br><span class="line">block(subscriber);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上方法为了防止发生资源竞争，都采用 <code>@synchronized</code> 来进行加锁</p><p>关于 RACSubject 基本介绍到这里就差不多了</p><p>下面看下子类</p><h2 id="RACBehaviorSubject"><a href="#RACBehaviorSubject" class="headerlink" title="RACBehaviorSubject"></a>RACBehaviorSubject</h2><blockquote><p>A behavior subject sends the last value it received when it is subscribed to.</p></blockquote><p>订阅时会向 订阅者发送最新的消息</p><p>声明如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACBehaviorSubject</span>&lt;<span class="title">ValueType</span>&gt; : <span class="title">RACSubject</span>&lt;<span class="title">ValueType</span>&gt;</span></span><br><span class="line"><span class="comment">/// Creates a new behavior subject with a default value. If it hasn't received</span></span><br><span class="line"><span class="comment">/// any values when it gets subscribed to, it sends the default value.</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)behaviorSubjectWithDefaultValue:(<span class="keyword">nullable</span> ValueType)value;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><ul><li>初始化<br>提供一个类方法，创建一个带有默认值的 subject ，如果订阅后没有收到任何值就会返回默认值</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)behaviorSubjectWithDefaultValue:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">RACBehaviorSubject *subject = [<span class="keyword">self</span> subject];</span><br><span class="line">subject.currentValue = value;</span><br><span class="line"><span class="keyword">return</span> subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重写了 subscribe 方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">RACDisposable *subscriptionDisposable = [<span class="keyword">super</span> subscribe:subscriber]; <span class="comment">//将subscriber 添加入自身的数组</span></span><br><span class="line"></span><br><span class="line">RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">[subscriber sendNext:<span class="keyword">self</span>.currentValue]; <span class="comment">//发送最新的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line">[schedulingDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>重写了 sendNext 方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.currentValue = value;  <span class="comment">//设置 最新的值</span></span><br><span class="line">[<span class="keyword">super</span> sendNext:value];     <span class="comment">//向数组内每个订阅者都发送最新的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事例</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RACBehaviorSubject *subject = [RACBehaviorSubject behaviorSubjectWithDefaultValue:@<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  [subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"1st Sub: %@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  [subject sendNext:@<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  [subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"2nd Sub: %@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  [subject sendNext:@<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Subscriber 3</span></span><br><span class="line">  [subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"3rd Sub: %@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  [subject sendNext:@<span class="number">3</span>];</span><br><span class="line">  [subject sendCompleted];</span><br></pre></td></tr></table></figure><p>将上面例子的 RACSubject 替换为 RACBehaviorSubject<br>打印log如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1st Sub: 10</span><br><span class="line">1st Sub: 1</span><br><span class="line">2nd Sub: 1</span><br><span class="line">1st Sub: 2</span><br><span class="line">2nd Sub: 2</span><br><span class="line">3rd Sub: 2</span><br><span class="line">1st Sub: 3</span><br><span class="line">2nd Sub: 3</span><br><span class="line">3rd Sub: 3</span><br></pre></td></tr></table></figure></p><p>当第一个调用subscribeNext 方法时候，会向生成的RACSubscriber 对象发送当前最新的值，默认值为@10，[subscriber sendNext:self.currentValue];接收到之后执行nextBlock,<code>NSLog(@&quot;1st Sub: %@&quot;, x);</code> 后面流程都一致此处省略</p><h2 id="RACReplaySubject"><a href="#RACReplaySubject" class="headerlink" title="RACReplaySubject"></a>RACReplaySubject</h2><p>订阅时会向 订阅者发送以前所有的消息</p><p>对外声明一个类方法，创建带有给定容量的 subject<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACReplaySubject</span>&lt;<span class="title">ValueType</span>&gt; : <span class="title">RACSubject</span>&lt;<span class="title">ValueType</span>&gt;</span></span><br><span class="line"><span class="comment">/// Creates a new replay subject with the given capacity. A capacity of</span></span><br><span class="line"><span class="comment">/// RACReplaySubjectUnlimitedCapacity means values are never trimmed.</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)replaySubjectWithCapacity:(<span class="built_in">NSUInteger</span>)capacity;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACReplaySubject</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> capacity;</span><br><span class="line"><span class="comment">// These properties should only be modified while synchronized on self.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSMutableArray</span> *valuesReceived;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> hasCompleted;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> hasError;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>内部valuesReceived，存储了收到了value，使用 synchronized 避免线程竞争</p><ul><li>初始化方法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)replaySubjectWithCapacity:(<span class="built_in">NSUInteger</span>)capacity &#123;</span><br><span class="line"><span class="keyword">return</span> [(RACReplaySubject *)[<span class="keyword">self</span> alloc] initWithCapacity:capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCapacity:(<span class="built_in">NSUInteger</span>)capacity &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_capacity = capacity;</span><br><span class="line">_valuesReceived = (capacity == RACReplaySubjectUnlimitedCapacity ? [<span class="built_in">NSMutableArray</span> array] : [<span class="built_in">NSMutableArray</span> arrayWithCapacity:capacity]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>根据入参 capacity 来初始化 内部的属性可变数组 valuesReceived</p><p>下面是遵循协议的方法</p><ul><li>sendNext<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">[<span class="keyword">self</span>.valuesReceived addObject:value ?: RACTupleNil.tupleNil];</span><br><span class="line">[<span class="keyword">super</span> sendNext:value];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.capacity != RACReplaySubjectUnlimitedCapacity &amp;&amp; <span class="keyword">self</span>.valuesReceived.count &gt; <span class="keyword">self</span>.capacity) &#123;</span><br><span class="line">[<span class="keyword">self</span>.valuesReceived removeObjectsInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="keyword">self</span>.valuesReceived.count - <span class="keyword">self</span>.capacity)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>将参数 value 添加入数组 ，调用父类的方法，发送消息，向内部所以的订阅者都发送消息<br>如果数组的数量超过初始化时的限制，将之前数据移除</p><ul><li><code>[self.valuesReceived addObject:value ?: RACTupleNil.tupleNil];</code><br>当value为空，需要包装为 RACTupleNil</li></ul><ul><li><p>sendCompleted</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendCompleted &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.hasCompleted = <span class="literal">YES</span>;</span><br><span class="line">[<span class="keyword">super</span> sendCompleted];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sendError</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendError:(<span class="built_in">NSError</span> *)e &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.hasError = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">self</span>.error = e;</span><br><span class="line">[<span class="keyword">super</span> sendError:e];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>subscribe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">for (id value in self.valuesReceived) &#123;</span><br><span class="line">if (compoundDisposable.disposed) return;</span><br><span class="line"></span><br><span class="line">[subscriber sendNext:(value == RACTupleNil.tupleNil ? nil : value)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (compoundDisposable.disposed) return;</span><br><span class="line"></span><br><span class="line">if (self.hasCompleted) &#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125; else if (self.hasError) &#123;</span><br><span class="line">[subscriber sendError:self.error];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">RACDisposable *subscriptionDisposable = [super subscribe:subscriber];</span><br><span class="line">[compoundDisposable addDisposable:subscriptionDisposable];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[compoundDisposable addDisposable:schedulingDisposable];</span><br><span class="line"></span><br><span class="line">return compoundDisposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过for循环 向 当前的subscriber 对象发送数组 valuesReceived 内的每个元素， 如果当前收到发送完成信号或者失败信号，就调用sendCompleted或者sendError方法</li></ul></li><li><p>事例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RACReplaySubject *subject = [RACReplaySubject subject];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1st Subscriber: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2nd Subscriber: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3rd Subscriber: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">3</span>];</span><br><span class="line">[subject sendCompleted];</span><br></pre></td></tr></table></figure></li></ul><p>打印log<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1st Subscriber: 1</span><br><span class="line">2nd Subscriber: 1</span><br><span class="line">1st Subscriber: 2</span><br><span class="line">2nd Subscriber: 2</span><br><span class="line">3rd Subscriber: 1</span><br><span class="line">3rd Subscriber: 2</span><br><span class="line">1st Subscriber: 3</span><br><span class="line">2nd Subscriber: 3</span><br><span class="line">3rd Subscriber: 3</span><br></pre></td></tr></table></figure></p><p>当第一次调用subscribeNext 方法，会向当前生成的订阅对象RACSubscriber 发送所有的值，一开始数据为空，不会发送sendNext,将当前的subscriber对象 添加入subscribers数组<br>当第二次调用subscribeNext 方法, 会向当前生成的订阅对象RACSubscriber 发送所有的值，目前 valuesReceived内只有1，因此打印<code>NSLog(@&quot;2nd Subscriber: %@&quot;, x);</code>后续操作省略</p><h2 id="RACGroupedSignal"><a href="#RACGroupedSignal" class="headerlink" title="RACGroupedSignal"></a>RACGroupedSignal</h2><p>分组信号，用来实现 RACSignal 的分组功能</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A grouped signal is used by -[RACSignal groupBy:transform:].</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACGroupedSignal</span> : <span class="title">RACSubject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// The key shared by the group.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt; key;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)signalWithKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)key;</span><br></pre></td></tr></table></figure><ul><li><p>初始化<br>初始化含有key属性的 Subject</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)signalWithKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)key &#123;</span><br><span class="line">RACGroupedSignal *subject = [<span class="keyword">self</span> subject];</span><br><span class="line">subject.key = key;</span><br><span class="line"><span class="keyword">return</span> subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事例<br>配合groupBy:transform:方法返回 RACGroupedSignal对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">                         &#123;</span><br><span class="line">                             [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">                             [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">                             [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">                             [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">                             [subscriber sendNext:@<span class="number">5</span>];</span><br><span class="line">                             [subscriber sendCompleted];</span><br><span class="line">                             <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                                 <span class="built_in">NSLog</span>(<span class="string">@"signal dispose"</span>);</span><br><span class="line">                             &#125;];</span><br><span class="line">                         &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalGroup = [signalA groupBy:^<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;(<span class="built_in">NSNumber</span> *object) &#123;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">return</span> object.integerValue &gt; <span class="number">3</span> ? <span class="string">@"good"</span> : <span class="string">@"bad"</span>;</span><br><span class="line">           &#125; transform:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> * object) &#123;</span><br><span class="line">                         <span class="keyword">return</span> @(object.integerValue * <span class="number">10</span>);</span><br><span class="line">          &#125;];</span><br><span class="line">[[[signalGroup filter:^<span class="built_in">BOOL</span>(RACGroupedSignal *value) &#123;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">return</span> [(<span class="built_in">NSString</span> *)value.key isEqualToString:<span class="string">@"good"</span>];</span><br><span class="line">          &#125;] flatten]subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">                         <span class="built_in">NSLog</span>(<span class="string">@"subscribeNext: %@"</span>, x);</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure></li></ul><p>filter 方法用于过滤<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)filter:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^ <span class="keyword">id</span> (<span class="keyword">id</span> value) &#123;</span><br><span class="line"><span class="keyword">if</span> (block(value)) &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line">&#125;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -filter:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果满足过滤条件<code>block(value)</code>，就返回 <code>[class return:value]</code>RACReturnSignal，否则返回<code>class.empty</code> RACEmptySignal<br>RACReturnSignal.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RACReturnSignal *signal = [[self alloc] init];</span><br><span class="line">signal-&gt;_value = value;</span><br></pre></td></tr></table></figure></p><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>RACTuple 元组类,类似NSArray,用来包装值</p><ul><li>flattenMap （RACStream）</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)flattenMap:(RACStream * (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">        <span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="keyword">id</span> stream = block(value) ?: [<span class="keyword">class</span> empty];</span><br><span class="line">            <span class="built_in">NSCAssert</span>([stream isKindOfClass:RACStream.class], <span class="string">@"Value returned from -flattenMap: is not a stream: %@"</span>, stream);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> stream;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -flattenMap:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RACChannelTerminal-双向绑定"><a href="#RACChannelTerminal-双向绑定" class="headerlink" title="RACChannelTerminal 双向绑定"></a>RACChannelTerminal 双向绑定</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface RACChannelTerminal&lt;ValueType&gt; : RACSignal&lt;ValueType&gt; &lt;RACSubscriber&gt;</span><br><span class="line"></span><br><span class="line">- (instancetype)init __attribute__((unavailable(&quot;Instantiate a RACChannel instead&quot;)));</span><br><span class="line"></span><br><span class="line">// Redeclaration of the RACSubscriber method. Made in order to specify a generic type.</span><br><span class="line">- (void)sendNext:(nullable ValueType)value;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>它和RACSubject一样，既继承自RACSignal，同样又遵守RACSubscriber协议。虽然具有RACSubject的发送和接收信号的特性，但是它依旧是冷信号，因为它无法一对多，它发送信号还是只能一对一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self == nil) return nil;</span><br><span class="line"></span><br><span class="line">    RACReplaySubject *leadingSubject = [[RACReplaySubject replaySubjectWithCapacity:0] setNameWithFormat:@&quot;leadingSubject&quot;];</span><br><span class="line">    RACReplaySubject *followingSubject = [[RACReplaySubject replaySubjectWithCapacity:1] setNameWithFormat:@&quot;followingSubject&quot;];</span><br><span class="line"></span><br><span class="line">    [[leadingSubject ignoreValues] subscribe:followingSubject];</span><br><span class="line">    [[followingSubject ignoreValues] subscribe:leadingSubject];</span><br><span class="line"></span><br><span class="line">    _leadingTerminal = [[[RACChannelTerminal alloc] initWithValues:leadingSubject otherTerminal:followingSubject] setNameWithFormat:@&quot;leadingTerminal&quot;];</span><br><span class="line">    _followingTerminal = [[[RACChannelTerminal alloc] initWithValues:followingSubject otherTerminal:leadingSubject] setNameWithFormat:@&quot;followingTerminal&quot;];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入参 values 其实是 RACReplaySubject 对象，所以内部订阅<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">return [self.values subscribe:subscriber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>订阅 RACChannelTerminal 过程实际是订阅 RACReplaySubject 对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line">[self.otherTerminal sendNext:value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sendError:(NSError *)error &#123;</span><br><span class="line">[self.otherTerminal sendError:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sendCompleted &#123;</span><br><span class="line">[self.otherTerminal sendCompleted];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>self.otherTerminal也是RACReplaySubject类型的，RACChannelTerminal管道两边都是RACReplaySubject类型的信号。当RACChannelTerminal开始sendNext，sendError，sendCompleted是调用的管道另外一个RACReplaySubject进行这些对应操作。<br>通常应用场景是在MVVM设计模式的View 和 ViewModel 中</p><p>例如登录界面</p><h2 id="冷热信号的转换"><a href="#冷热信号的转换" class="headerlink" title="冷热信号的转换"></a>冷热信号的转换</h2><p>由于冷信号是一对一，有些情况的局限的，比如网络请求，<br>如果使用RACSignal ,那么每次订阅，都会执行一遍信号创建时候的block进行发送信号,操作太频繁反而会浪费资源，故此如果能够将多次订阅转为一次执行，就利用到了热信号，一对多的关系，将冷信号转为热信号,无论有多少个订阅者，无论订阅多少次，只发送一次，这里需要使用  RACMulticastConnection<br>在<a href="https://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-2.html" target="_blank" rel="noopener">细说ReactiveCocoa的冷信号与热信号（二）：为什么要区分冷热信号</a>一文有详细说明</p><h3 id="RACMulticastConnection"><a href="#RACMulticastConnection" class="headerlink" title="RACMulticastConnection"></a>RACMulticastConnection</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface RACMulticastConnection&lt;__covariant ValueType&gt; : NSObject</span><br><span class="line"></span><br><span class="line">/// The multicasted signal.</span><br><span class="line">@property (nonatomic, strong, readonly) RACSignal&lt;ValueType&gt; *signal;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)connect;</span><br><span class="line"></span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)autoconnect RAC_WARN_UNUSED_RESULT;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>对外只申明一个RACSignal类型的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface RACMulticastConnection () &#123;</span><br><span class="line">RACSubject *_signal;  //RACSubject 类型的信号</span><br><span class="line">int32_t volatile _hasConnected;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly, strong) RACSignal *sourceSignal; //原信号是 RACSignal类型</span><br><span class="line">@property (strong) RACSerialDisposable *serialDisposable;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>内部存储了RACSignal 原信号 和 RACSubject 类型的 signal</p><p>初始化方法是私有的，官方不建议使用此方法进行初始化，而是推荐使用 RACSignal的实例方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (RACMulticastConnection *)publish &#123;</span><br><span class="line">RACSubject *subject = [[RACSubject subject] setNameWithFormat:@&quot;[%@] -publish&quot;, self.name];</span><br><span class="line">RACMulticastConnection *connection = [self multicast:subject];</span><br><span class="line">return connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACMulticastConnection *)multicast:(RACSubject *)subject &#123;</span><br><span class="line">[subject setNameWithFormat:@&quot;[%@] -multicast: %@&quot;, self.name, subject.name];</span><br><span class="line">RACMulticastConnection *connection = [[RACMulticastConnection alloc] initWithSourceSignal:self subject:subject];</span><br><span class="line">return connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个方法都会返回 RACMulticastConnection 对象，self是当前的原信号<br>publish 方法 将 原信号进行广播， 是对 multicast 方法的封装<br>multicast 方法需要入参 RACSubject 类型的对象</p><ul><li><p>初始化 赋值操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithSourceSignal:(RACSignal *)source subject:(RACSubject *)subject &#123;</span><br><span class="line">NSCParameterAssert(source != nil);</span><br><span class="line">NSCParameterAssert(subject != nil);</span><br><span class="line"></span><br><span class="line">self = [super init];</span><br><span class="line"></span><br><span class="line">_sourceSignal = source;</span><br><span class="line">_serialDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">_signal = subject;</span><br><span class="line"></span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="comment">// block 1</span></span><br><span class="line">    [subscriber sendNext:@<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] publish];</span><br><span class="line"></span><br><span class="line">[connection.signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// block 2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"value: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[connection.signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"value: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[connection connect];</span><br></pre></td></tr></table></figure></li></ul><p>RACMulticastConnection 需要调用connect 方法去触发 订阅操作<br><a href="https://draveness.me/racconnection" target="_blank" rel="noopener">图片来源</a><br><img src="/images/RACMutiConnection.png" alt="RACMutiConnection"></p><ul><li>connect 连接方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)connect &#123;</span><br><span class="line">BOOL shouldConnect = OSAtomicCompareAndSwap32Barrier(0, 1, &amp;_hasConnected);</span><br><span class="line"></span><br><span class="line">if (shouldConnect) &#123;</span><br><span class="line">self.serialDisposable.disposable = [self.sourceSignal subscribe:_signal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return self.serialDisposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OSAtomicCompareAndSwap32Barrier，它是原子运算的操作符，主要用于Compare and swap，原型如下：</p><p><code>bool OSAtomicCompareAndSwap32Barrier( int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue );</code></p><p>关键字volatile只确保每次获取volatile变量时都是从内存加载变量，而不是使用寄存器里面的值，但是它不保证代码访问变量是正确的。</p><p>1.如果应该连接，执行<code>[self.sourceSignal subscribe:_signal];</code><br>此处 <code>self.suourceSignal</code> 属于 RACDynamicSignal 类型，<br>方法原型<code>- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber</code><br>2.执行 <code>subscribe</code>方法触发执行sourceSignal 信号创建时候的入参block<br>于是此处执行 <code>[subscriber sendNext:@10];</code> 发送消息<br>3.subscriber是初始化时候<code>subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</code> ，转发给RACPassthroughSubscriber 内部的innerSubscriber去执行<br>4.消息的订阅者是 _signal ，即 RACSubject, 于是向 RACSubject 对象发送 <code>sendNext</code><br>5.RACSubject 内部会去遍历自身的数组subscribers,逐一去发送消息<code>[subscriber sendNext:value];</code></p><p>打印<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReactiveObjcTest[<span class="number">15369</span>:<span class="number">1888001</span>] value: <span class="number">10</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-26</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">57.366415</span>+<span class="number">0800</span> ReactiveObjcTest[<span class="number">15369</span>:<span class="number">1888001</span>] value: <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>connect 方法通过 <code>subscribe</code>方法 将 RACSignal 和 RACSubject 进行连接<br>此外还有一个方法用于连接两者的关系</p><ul><li><p>autoconnect</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)autoconnect &#123;</span><br><span class="line">__block volatile int32_t subscriberCount = 0;</span><br><span class="line"></span><br><span class="line">return [[RACSignal</span><br><span class="line">createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">OSAtomicIncrement32Barrier(&amp;subscriberCount);</span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [self.signal subscribe:subscriber];</span><br><span class="line">RACDisposable *connectionDisposable = [self connect];</span><br><span class="line"></span><br><span class="line">return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line"></span><br><span class="line">if (OSAtomicDecrement32Barrier(&amp;subscriberCount) == 0) &#123;</span><br><span class="line">[connectionDisposable dispose];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;]</span><br><span class="line">setNameWithFormat:@&quot;[%@] -autoconnect&quot;, self.signal.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    // block 1</span><br><span class="line">    [subscriber sendNext:@10];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;] publish];</span><br><span class="line"></span><br><span class="line">[connection.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    // block 2</span><br><span class="line">    NSLog(@&quot;value: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[connection.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    // block 3</span><br><span class="line">    NSLog(@&quot;value: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *hotSignal = connection.autoconnect;</span><br><span class="line">[hotSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    // block4</span><br><span class="line">    NSLog(@&quot;value: %@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li></ul><p>具体步骤:<br>1.首先connection信号创建时候将block1进行copy<br>2.<code>[connection.signal subscribeNext]</code>执行将消息的订阅者存入RACSubject 对象的内部数组RACSubscribers<br>2.调用 autoconnect 时候创建新的信号hotSignal，先将block进行保存<br>3.<code>[hotSignal subscribeNext]</code> 执行的时候，调用hotsignal创建时候的block，那么会调用 autoconnect 方法内部的createSignal方法的block,执行<br><code>RACDisposable *subscriptionDisposable = [self.signal subscribe:subscriber];</code><br>signal对象是RACSubject类型，此方法将subscriber添加入 RACSubject 的内部数组里<br>4.执行<code>RACDisposable *connectionDisposable = [self connect];</code> 将建立 signal和 RACSubject 的关系</p><p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-03-26 17:54:44.798500+0800 ReactiveObjcTest[15468:1900659] value: 10</span><br><span class="line">2018-03-26 17:54:47.543048+0800 ReactiveObjcTest[15468:1900659] value: 10</span><br><span class="line">2018-03-26 17:54:48.918772+0800 ReactiveObjcTest[15468:1900659] value: 10</span><br></pre></td></tr></table></figure></p><p>在调用connect方法，前面已经执行一次<code>subscribe</code>方法,在 autoConnect 方法的返回信号对象第一次被订阅时，就会建立连接</p><p>除了调用<code>publish</code> 和 <code>multicast</code>方法之外，还有下面几个方法用于将 RACSignal 转换为 RACMulticastConnection</p><ul><li><ul><li>(RACSignal<valuetype> *)replay;</valuetype></li></ul></li><li><ul><li>(RACSignal<valuetype> *)replayLast;</valuetype></li></ul></li><li><ul><li>(RACSignal<valuetype> *)replayLazily;</valuetype></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RACSubject 继承自 RACSignal ，但是内部存储了一些遵循 RACSubscriber协议的对象，将原有的不可变信号转为可变信号，在实际情况下运用非常方便</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文源码为 ReactiveObjc 3.1.0 版本&lt;/p&gt;
&lt;h2 id=&quot;RACSubject&quot;&gt;&lt;a href=&quot;#RACSubject&quot; class=&quot;headerlink&quot; title=&quot;RACSubject&quot;&gt;&lt;/a&gt;RACSubject&lt;/h2&gt;&lt;p&gt;RAC
      
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="https://pattyxp.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveObjc-RACSequence</title>
    <link href="https://pattyxp.github.io/2018/03/15/ReactiveObjc-RACSequence/"/>
    <id>https://pattyxp.github.io/2018/03/15/ReactiveObjc-RACSequence/</id>
    <published>2018-03-15T07:12:30.000Z</published>
    <updated>2018-05-18T03:34:18.470Z</updated>
    
    <content type="html"><![CDATA[<p>本文源码为 ReactiveObjc 3.1.0 版本</p><h2 id="RACSequence"><a href="#RACSequence" class="headerlink" title="RACSequence"></a>RACSequence</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACSequence</span>&lt;<span class="title">__covariant</span> <span class="title">ValueType</span>&gt; : <span class="title">RACStream</span> &lt;<span class="title">NSCoding</span>, <span class="title">NSCopying</span>, <span class="title">NSFastEnumeration</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) ValueType head;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) RACSequence&lt;ValueType&gt; *tail;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;ValueType&gt; *array;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSEnumerator</span>&lt;ValueType&gt; *objectEnumerator;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;ValueType&gt; *eagerSequence;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;ValueType&gt; *lazySequence;</span><br></pre></td></tr></table></figure><p>RACSequence 主要由两部分组成， head 和 tail, head是一个 数字， tail 是 流RACSequence 的形式</p><p>先来了解下 RACSequence 相关的子类<br><img src="RACSequence子类结构图.png" alt="RACSequence子类结构图"></p><blockquote><p>此图来自 <img src="https://github.com/Draveness/analyze/blob/43d828b6f516a57e12eeff69913ff49cc94a0f36/contents/ReactiveObjC/RACSequence.md" alt="Draveness博客"></p></blockquote><p>这里，和RACSignal类似，获取 head 和 tail 的方法需要被子类重写<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)head &#123;</span><br><span class="line"><span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"%s must be overridden by subclasses"</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSequence *)tail &#123;</span><br><span class="line"><span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"%s must be overridden by subclasses"</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>empty<br>返回 RACEmptySequence 实例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSequence *)empty &#123;</span><br><span class="line"><span class="keyword">return</span> RACEmptySequence.empty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>return<br>返回 RACUnarySequence 实例，将传入的参数作为 head，tail 返回 nil</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSequence *)<span class="keyword">return</span>:(<span class="keyword">id</span>)value &#123;</span><br><span class="line"><span class="keyword">return</span> [RACUnarySequence <span class="keyword">return</span>:value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (RACUnarySequence *)<span class="keyword">return</span>:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">RACUnarySequence *sequence = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">sequence.head = value;</span><br><span class="line"><span class="keyword">return</span> [sequence setNameWithFormat:<span class="string">@"+return: %@"</span>, RACDescription(value)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark RACSequence</span></span><br><span class="line"></span><br><span class="line">- (RACSequence *)tail &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>bind</p></li></ul><p>调用内部 bind:passingThroughValuesFromSequence:方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (RACSequence *)bind:(RACSequenceBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">RACSequenceBindBlock bindBlock = block();</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:bindBlock passingThroughValuesFromSequence:<span class="literal">nil</span>] setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSequence *)bind:(RACSequenceBindBlock)bindBlock passingThroughValuesFromSequence:(RACSequence *)passthroughSequence &#123;</span><br><span class="line"></span><br><span class="line">__block RACSequence *valuesSeq = <span class="keyword">self</span>;</span><br><span class="line">__block RACSequence *current = passthroughSequence;</span><br><span class="line">__block <span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">RACSequence *sequence = [RACDynamicSequence sequenceWithLazyDependency:^ <span class="keyword">id</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (current.head == <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (stop) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> value = valuesSeq.head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (value == <span class="literal">nil</span>) &#123;</span><br><span class="line">stop = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">current = (<span class="keyword">id</span>)bindBlock(value, &amp;stop);</span><br><span class="line"><span class="keyword">if</span> (current == <span class="literal">nil</span>) &#123;</span><br><span class="line">stop = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">valuesSeq = valuesSeq.tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSCAssert</span>([current isKindOfClass:RACSequence.class], <span class="string">@"-bind: block returned an object that is not a sequence: %@"</span>, current);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125; headBlock:^(<span class="keyword">id</span> _) &#123;</span><br><span class="line"><span class="keyword">return</span> current.head;</span><br><span class="line">&#125; tailBlock:^ <span class="keyword">id</span> (<span class="keyword">id</span> _) &#123;</span><br><span class="line"><span class="keyword">if</span> (stop) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [valuesSeq bind:bindBlock passingThroughValuesFromSequence:current.tail];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">sequence.name = <span class="keyword">self</span>.name;</span><br><span class="line"><span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>内部创建 RACDynamicSequence 实例返回</p><p>创建RACDynamicSequence</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSequence *)sequenceWithLazyDependency:(<span class="keyword">id</span> (^)(<span class="keyword">void</span>))dependencyBlock headBlock:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> dependency))headBlock tailBlock:(RACSequence *(^)(<span class="keyword">id</span> dependency))tailBlock &#123;</span><br><span class="line">  ...</span><br><span class="line">RACDynamicSequence *seq = [[RACDynamicSequence alloc] init];</span><br><span class="line">seq.headBlock = [headBlock <span class="keyword">copy</span>];</span><br><span class="line">seq.tailBlock = [tailBlock <span class="keyword">copy</span>];</span><br><span class="line">seq.dependencyBlock = [dependencyBlock <span class="keyword">copy</span>];</span><br><span class="line">seq.hasDependency = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建好 RACDynamicSequence 之后，获取 head</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)head &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">id</span> untypedHeadBlock = <span class="keyword">self</span>.headBlock;</span><br><span class="line"><span class="keyword">if</span> (untypedHeadBlock == <span class="literal">nil</span>) <span class="keyword">return</span> _head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.hasDependency) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.dependencyBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">_dependency = <span class="keyword">self</span>.dependencyBlock();</span><br><span class="line"><span class="keyword">self</span>.dependencyBlock = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> (^headBlock)(<span class="keyword">id</span>) = untypedHeadBlock;</span><br><span class="line">_head = headBlock(_dependency);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">id</span> (^headBlock)(<span class="keyword">void</span>) = untypedHeadBlock;</span><br><span class="line">_head = headBlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.headBlock = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">return</span> _head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么这里获取head之后，将headBlock 、dependencyBlock 均清空了下次怎么办<br>解惑:<br>第一次获取head时候，如果已经获取到，headBlock 、dependencyBlock  清空<br>第二次获取head时候，headBlock 已经为空，所以直接返回第一次获取的结果，不需要再次赋值</p></blockquote><p>获取tail,和 head 获取方法同理<br>获取的 tail 依赖 tailBlock 和 dependencyBlock, 最后返回的tail 执行返回 RACSequence对象<br><code>return [valuesSeq bind:bindBlock passingThroughValuesFromSequence:current.tail];</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (RACSequence *)tail &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">id</span> untypedTailBlock = <span class="keyword">self</span>.tailBlock;</span><br><span class="line"><span class="keyword">if</span> (untypedTailBlock == <span class="literal">nil</span>) <span class="keyword">return</span> _tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.hasDependency) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.dependencyBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">_dependency = <span class="keyword">self</span>.dependencyBlock();</span><br><span class="line"><span class="keyword">self</span>.dependencyBlock = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RACSequence * (^tailBlock)(<span class="keyword">id</span>) = untypedTailBlock;</span><br><span class="line">_tail = tailBlock(_dependency);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">RACSequence * (^tailBlock)(<span class="keyword">void</span>) = untypedTailBlock;</span><br><span class="line">_tail = tailBlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_tail.name == <span class="literal">nil</span>) _tail.name = <span class="keyword">self</span>.name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.tailBlock = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">return</span> _tail;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面通过更具体的代码来了解bind方法使用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *sequence = [RACSequence sequenceWithHeadBlock:^<span class="keyword">id</span> _Nullable&#123;</span><br><span class="line">    <span class="keyword">return</span> @<span class="number">1</span>;</span><br><span class="line">&#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">    <span class="keyword">return</span>  [RACSequence sequenceWithHeadBlock:^<span class="keyword">id</span> _Nullable&#123;</span><br><span class="line">        <span class="keyword">return</span> @<span class="number">2</span>;</span><br><span class="line">    &#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">        <span class="keyword">return</span> [RACSequence <span class="keyword">return</span>:@<span class="number">3</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSequence *bindSequence = [sequence bind:^RACSequenceBindBlock _Nonnull&#123;</span><br><span class="line">    <span class="keyword">return</span> ^(<span class="built_in">NSNumber</span> *value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"RACSequenceBindBlock: %@"</span>, value);</span><br><span class="line">        value = @(value.integerValue * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> [RACSequence <span class="keyword">return</span>:value];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"BindSequence:  head=(%@) tail=(%@)"</span>, bindSequence.head, bindSequence.tail);</span><br></pre></td></tr></table></figure></p><p>log 获取的 head 有值，获取的 tail 是 RACSequence对象，值暂时都是unresolved<br><code>BindSequence:  head=(2) tail=(&lt;RACDynamicSequence: 0x600000098560&gt;{ name = , head = (unresolved), tail = (unresolved) })</code></p><p>上面的流程中，执行bind方法的block是惰性的， 只有在获取 RACSequence 对象的head以及tail的时候才会执行 LazyDependency,在 LazyDependency内部将value 执行bindBlock(value, &amp;stop),返回 RACUnarySequence 对象 最后通过head属性取出值</p><blockquote><p>注意:<br>在整个 ReactiveCocoa 中，所有的 RACSequence 对象在默认情况下都是惰性的，序列中的值只有在真正需要使用时才会被展开，在其他时间都是 unresolved。</p></blockquote><ul><li>lazySequence 和 eagerSequence</li></ul><p>打印下上面例子的这两个属性值<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *sequence = [RACSequence sequenceWithHeadBlock:^<span class="keyword">id</span> _Nullable&#123;</span><br><span class="line">       <span class="keyword">return</span> @<span class="number">1</span>;</span><br><span class="line">   &#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">       <span class="keyword">return</span>  [RACSequence sequenceWithHeadBlock:^<span class="keyword">id</span> _Nullable&#123;</span><br><span class="line">           <span class="keyword">return</span> @<span class="number">2</span>;</span><br><span class="line">       &#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">           <span class="keyword">return</span> [RACSequence <span class="keyword">return</span>:@<span class="number">3</span>];</span><br><span class="line">       &#125;];</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   RACSequence *bindSequence = [sequence bind:^RACSequenceBindBlock _Nonnull&#123;</span><br><span class="line">       <span class="keyword">return</span> ^(<span class="built_in">NSNumber</span> *value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"RACSequenceBindBlock: %@"</span>, value);</span><br><span class="line">           value = @(value.integerValue * <span class="number">2</span>);</span><br><span class="line">           <span class="keyword">return</span> [RACSequence <span class="keyword">return</span>:value];</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"BindSequence: lazySequence=(%@)"</span>, bindSequence.lazySequence);</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"BindSequence: eagerSequence=(%@)"</span>, bindSequence.eagerSequence);</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"BindSequence: lazySequence=(%@)"</span>, bindSequence.lazySequence);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BindSequence: lazySequence=(&lt;RACDynamicSequence: 0x6000000971b0&gt;&#123; name = , head = (unresolved), tail = (unresolved) &#125;)</span><br><span class="line">BindSequence: eagerSequence=(&lt;RACEagerSequence: 0x600000223ec0&gt;&#123; name = , array = (</span><br><span class="line">    2,</span><br><span class="line">    4,</span><br><span class="line">    6</span><br><span class="line">) &#125;)</span><br><span class="line">BindSequence: lazySequence=(&lt;RACDynamicSequence: 0x6000000971b0&gt;&#123; name = , head = 2, tail = &lt;RACDynamicSequence: 0x600000095040&gt;&#123; name = , head = 4, tail = &lt;RACDynamicSequence: 0x6040000939c0&gt;&#123; name = , head = 6, tail = (null) &#125; &#125; &#125;)</span><br></pre></td></tr></table></figure><p>可以看到 lazySequence 一开始还是unresolved ，调用 eagerSequence 之后，lazySequence 就不再是 unresolved</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (RACSequence *)lazySequence &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSequence *)eagerSequence &#123;</span><br><span class="line"><span class="keyword">return</span> [RACEagerSequence sequenceWithArray:<span class="keyword">self</span>.array offset:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RACArraySequence.m</span></span><br><span class="line">+ (RACSequence *)sequenceWithArray:(<span class="built_in">NSArray</span> *)array offset:(<span class="built_in">NSUInteger</span>)offset &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(offset &lt;= array.count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (offset == array.count) <span class="keyword">return</span> <span class="keyword">self</span>.empty;</span><br><span class="line"></span><br><span class="line">RACArraySequence *seq = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">seq-&gt;_backingArray = [array <span class="keyword">copy</span>];</span><br><span class="line">seq-&gt;_offset = offset;</span><br><span class="line"><span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eager从字面上也可以了解到，就是提前获取所有的数据</p><p>获取eagerSequence方法里面，有个参数<code>self.array</code><br>调用的是RACSequence的方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">[array addObject:obj];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [array <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印self<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">po self</span><br><span class="line">&lt;RACDynamicSequence: 0x604000095cc0&gt;&#123; name = , head = 2, tail =</span><br><span class="line">&lt;RACDynamicSequence: 0x600000282ee0&gt;&#123; name = , head = 4, tail =</span><br><span class="line">&lt;RACDynamicSequence: 0x600000282ad0&gt;&#123; name = , head = 6, tail = (null) &#125; &#125; &#125;</span><br></pre></td></tr></table></figure></p><p>好奇 array的obj是怎么来的，查看调用栈<br>RACSequence 有属性array，遵循协议 NSFastEnumeration ，因此执行forin的时候调用以下方法<br><code>- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id *)stackbuf count:(NSUInteger)len</code><br>该方法遍历获取 self ，通过<br><code>RACSequence *(^getSequence)(void) = ^{        return (__bridge RACSequence *)(void *)state-&gt;state;    };</code> 将当前对象内部的每一项state转化为sequence,然后获取head</p><ul><li>RACSequence 和 RACSignal</li></ul><p>两者存在区别，但是也可以相互转化</p><ul><li><p>RACSequence 转化为 RACSignal</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *sequence = @[@1,@2,@3].rac_sequence;</span><br><span class="line">RACSignal *signal = sequence.signal;</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;signal: %@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> signal: 1</span><br><span class="line"> signal: 2</span><br><span class="line"> signal: 3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>下面看下具体实现源码</p><p>内部是重新创建返回 RACSignal 通过递归调用 RACScheduler block方法，向 RACSubscriber 发送sendNext 直到结束</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  - (RACSignal *)signal &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> signalWithScheduler:[RACScheduler scheduler]] setNameWithFormat:<span class="string">@"[%@] -signal"</span>, <span class="keyword">self</span>.name];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> - (RACSignal *)signalWithScheduler:(RACScheduler *)scheduler &#123;</span><br><span class="line"> <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"> __block RACSequence *sequence = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> [scheduler scheduleRecursiveBlock:^(<span class="keyword">void</span> (^reschedule)(<span class="keyword">void</span>)) &#123;</span><br><span class="line"> <span class="keyword">if</span> (sequence.head == <span class="literal">nil</span>) &#123;</span><br><span class="line"> [subscriber sendCompleted];</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> [subscriber sendNext:sequence.head];</span><br><span class="line"> sequence = sequence.tail;</span><br><span class="line"> reschedule();</span><br><span class="line"> &#125;];</span><br><span class="line"> &#125;] setNameWithFormat:<span class="string">@"[%@] -signalWithScheduler: %@"</span>, <span class="keyword">self</span>.name, scheduler];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>RACSignal 转化为 RACSequence</p></li></ul><p>内部创建 RACArraySequence ，收集到发出的所有信号<br>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">      [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">      [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">      [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">      [subscriber sendCompleted];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, signal.toArray.rac_sequence);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   &lt;RACArraySequence: 0x600000222ca0&gt;&#123; name = , array = (</span></span><br><span class="line"><span class="comment">   1,</span></span><br><span class="line"><span class="comment">   2,</span></span><br><span class="line"><span class="comment">   3</span></span><br><span class="line"><span class="comment">   ) &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure></p><ul><li>Map 、 Filter 、 flattenMap</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array=@[@(<span class="number">2</span>),@(<span class="number">5</span>),@(<span class="number">7</span>),@(<span class="number">15</span>)];</span><br><span class="line">  RACSequence *sequences = [array rac_sequence];</span><br><span class="line">  <span class="keyword">id</span> mapData = [sequences map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">      <span class="keyword">return</span> @([value integerValue] * <span class="number">2</span>);</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"序列Map之后的数据:%@"</span>,[mapData array]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">id</span> filterData = [sequences filter:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">      <span class="keyword">return</span> [value integerValue]%<span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"序列Filter之后的数据:%@"</span>,[filterData array]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  RACSequence *flatmapData = [sequences flattenMap:^__kindof RACSequence * _Nullable(<span class="keyword">id</span>  _Nullable value) &#123;</span><br><span class="line">       <span class="keyword">if</span> ([value integerValue]%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> [RACSequence sequenceWithHeadBlock:^<span class="keyword">id</span> _Nullable&#123;</span><br><span class="line">               <span class="keyword">return</span> value;</span><br><span class="line">           &#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">           &#125;];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> [RACSequence empty];</span><br><span class="line">   &#125;];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"先map再filter之后的数据:%@"</span>, flatmapData.eagerSequence);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">序列Map之后的数据:(</span></span><br><span class="line"><span class="comment">    4,</span></span><br><span class="line"><span class="comment">    10,</span></span><br><span class="line"><span class="comment">    14,</span></span><br><span class="line"><span class="comment">    30</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">序列Filter之后的数据:(</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> &lt;RACEagerSequence: 0x6040002241c0&gt;&#123; name = , array = (</span></span><br><span class="line"><span class="comment"> 2</span></span><br><span class="line"><span class="comment"> ) &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><ul><li>初始化<br>内部实际返回 RACDynamicSequence 对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSequence *)sequenceWithHeadBlock:(id (^)(void))headBlock tailBlock:(RACSequence&lt;id&gt; *(^)(void))tailBlock &#123;</span><br><span class="line">return [[RACDynamicSequence sequenceWithHeadBlock:headBlock tailBlock:tailBlock] setNameWithFormat:@&quot;+sequenceWithHeadBlock:tailBlock:&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文源码为 ReactiveObjc 3.1.0 版本&lt;/p&gt;
&lt;h2 id=&quot;RACSequence&quot;&gt;&lt;a href=&quot;#RACSequence&quot; class=&quot;headerlink&quot; title=&quot;RACSequence&quot;&gt;&lt;/a&gt;RACSequence&lt;/h2&gt;&lt;f
      
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="https://pattyxp.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveObjc入门</title>
    <link href="https://pattyxp.github.io/2018/03/12/ReactiveObjc%E5%85%A5%E9%97%A8/"/>
    <id>https://pattyxp.github.io/2018/03/12/ReactiveObjc入门/</id>
    <published>2018-03-12T09:40:55.000Z</published>
    <updated>2018-05-18T03:34:37.346Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文源码为 ReactiveObjc 3.1.0 版本</p><p>ReactiveCocoa 开源已久，实现非常高效，对应OC中各种不同的设计模式，如代理响应，观察者模式，通知等模式的输入，都可以抽象为信号，让组件对自己的行为进行控制，简化控制器的负担。<br>本文作为系列开篇，先介绍最核心的 信号流 RACStream</p><p>RACStream 属于抽象类，两个子类分别是 RACSignal 和 RACSequence<br><img src="/images/RACStream大概.png" alt="RAC-stream"></p><p>两者虽然都继承自RACStream,拥有父类的很多共同的特性，但是差异在于 推驱动 和 拉驱动的方式</p><ul><li>RACSignal : 推驱动， 每次当信号中出现新的数据，主动发送给所有的订阅者</li><li>RACSequence : 拉驱动，每次出现新的数据，并不会通知当前的订阅对象，而是当订阅者再次需要使用 RACSequence 对象才会去获取最新的数据，由使用者自己去拉取新数据</li></ul><p>本文先介绍 RACSignal 相关的信息</p><h2 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h2><p>RACStream作为抽象类，在实现内部抛出异常</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (__kindof RACStream *)empty &#123;</span><br><span class="line"><span class="built_in">NSString</span> *reason = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ must be overridden by subclasses"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd)];</span><br><span class="line"><span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInternalInconsistencyException</span> reason:reason userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (__kindof RACStream *)bind:(RACStreamBindBlock (^)(<span class="keyword">void</span>))block;</span><br><span class="line">+ (__kindof RACStream *)<span class="keyword">return</span>:(<span class="keyword">id</span>)value;</span><br><span class="line">- (__kindof RACStream *)concat:(RACStream *)stream;</span><br><span class="line">- (__kindof RACStream *)zipWith:(RACStream *)stream;</span><br></pre></td></tr></table></figure><p>RACStream 需要子类实现这些方法，否则抛出异常<br>RACStream的分类Operations，定义了许多方法，只要子类实现以上的抽象方法，这些分类方法都能使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">id</span> stream = block(value) ?: [<span class="keyword">class</span> empty];</span><br><span class="line"><span class="built_in">NSCAssert</span>([stream isKindOfClass:RACStream.class], <span class="string">@"Value returned from -flattenMap: is not a stream: %@"</span>, stream);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> stream;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -flattenMap:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (__kindof RACStream *)flatten</span><br><span class="line">- (__kindof RACStream *)map:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> value))block</span><br><span class="line">- (__kindof RACStream *)mapReplace:(<span class="keyword">id</span>)object</span><br><span class="line">- (__kindof RACStream *)combinePreviousWithStart:(<span class="keyword">id</span>)start reduce:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> previous, <span class="keyword">id</span> next))reduceBlock</span><br><span class="line">- (__kindof RACStream *)filter:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> value))block</span><br><span class="line">- (__kindof RACStream *)ignore:(<span class="keyword">id</span>)value</span><br><span class="line">- (__kindof RACStream *)reduceEach:(RACReduceBlock)reduceBlock</span><br><span class="line">- (__kindof RACStream *)startWith:(<span class="keyword">id</span>)value</span><br><span class="line">- (__kindof RACStream *)skip:(<span class="built_in">NSUInteger</span>)skipCount</span><br><span class="line">- (__kindof RACStream *)take:(<span class="built_in">NSUInteger</span>)count</span><br><span class="line">+ (__kindof RACStream *)join:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)streams block:(RACStream * (^)(<span class="keyword">id</span>, <span class="keyword">id</span>))block</span><br><span class="line">+ (__kindof RACStream *)zip:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)streams</span><br><span class="line">+ (__kindof RACStream *)zip:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)streams reduce:(RACGenericReduceBlock)reduceBlock</span><br><span class="line">+ (__kindof RACStream *)concat:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)streams</span><br><span class="line">- (__kindof RACStream *)scanWithStart:(<span class="keyword">id</span>)startingValue reduce:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> running, <span class="keyword">id</span> next))reduceBlock</span><br><span class="line">- (__kindof RACStream *)scanWithStart:(<span class="keyword">id</span>)startingValue reduceWithIndex:(<span class="keyword">id</span> (^)(<span class="keyword">id</span>, <span class="keyword">id</span>, <span class="built_in">NSUInteger</span>))reduceBlock</span><br><span class="line">- (__kindof RACStream *)takeUntilBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate</span><br><span class="line">- (__kindof RACStream *)takeWhileBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate</span><br><span class="line">- (__kindof RACStream *)skipUntilBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate</span><br><span class="line">- (__kindof RACStream *)skipWhileBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate</span><br><span class="line">- (__kindof RACStream *)distinctUntilChanged</span><br></pre></td></tr></table></figure><p>RACSignal继承自RACStream<br>下面简单介绍部分常用的方法，在 RACSignal (RACStream)</p><ul><li>return<br>通过传入NSObject类型的value,返回RACSignal对象，完成了UIKit -&gt; ReactiveCocoa<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)<span class="keyword">return</span>:(<span class="keyword">id</span>)value &#123;</span><br><span class="line"><span class="keyword">return</span> [RACReturnSignal <span class="keyword">return</span>:value];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>RACSignal是一个类簇，return 方法虽然返回的是 RACSignal 但是内部实际返回 RACReturnSignal<br>同样的在创建实例时，可能会返回 RACDynamicSignal、RACEmptySignal、RACErrorSignal 和 RACReturnSignal 对象<br>如return方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACReturnSignal.m</span><br><span class="line">+ (RACSignal *)<span class="keyword">return</span>:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">RACReturnSignal *signal = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">signal-&gt;_value = value;</span><br><span class="line"></span><br><span class="line"><span class="meta">#ifdef DEBUG</span></span><br><span class="line">[signal setNameWithFormat:<span class="string">@"+return: %@"</span>, value];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="keyword">return</span> signal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面结合实例讲解下信号订阅的过程<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposble * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"signal %@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><ul><li><p>createSignal 创建信号<br>createSignal 实际返回RACDynamicSignal对象，将block存储在唯一的属性_didSubscribe上</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)createSignal:(RACDisposble * (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line">RACDynamicSignal *signal = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">signal-&gt;_didSubscribe = [didSubscribe <span class="keyword">copy</span>];</span><br><span class="line"><span class="keyword">return</span> [signal setNameWithFormat:<span class="string">@"+createSignal:"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>subscribeNext<br>信号创建之后，调用subscribeNext 返回RACDisposble ，还生成一个 RACSubscriber 对象，向这个对象发送消息 -sendNext: 时，就向所有的订阅者发送消息。</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposble *)subscribeNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))nextBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(nextBlock != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:<span class="literal">NULL</span> completed:<span class="literal">NULL</span>];</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>创建RACSubscriber 消息的订阅者</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)subscriberWithNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))next error:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *error))error completed:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completed &#123;</span><br><span class="line">RACSubscriber *subscriber = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line"></span><br><span class="line">subscriber-&gt;_next = [next <span class="keyword">copy</span>];</span><br><span class="line">subscriber-&gt;_error = [error <span class="keyword">copy</span>];</span><br><span class="line">subscriber-&gt;_completed = [completed <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>subscribe<br>创建的RACSubscriber实例需要订阅,subscribe:方法需要被RACSignal的子类实现，如 RACDynamicSignal</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">RACSignal.m</span><br><span class="line">- (RACDisposble *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"><span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"This method must be overridden by subclasses"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RACDynamicSignal.m</span><br><span class="line">- (RACDisposble *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(subscriber != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将subscriber，signal，disposable绑定</span></span><br><span class="line">subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="keyword">self</span> disposable:disposable];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.didSubscribe != <span class="literal">NULL</span>) &#123; <span class="comment">//self.didSubscribe是初始化RACSignal时候赋值block</span></span><br><span class="line">RACDisposble *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">      <span class="comment">//schedule即执行block()，也就是下面的内容</span></span><br><span class="line">RACDisposble *innerDisposable = <span class="keyword">self</span>.didSubscribe(subscriber);<span class="comment">//将订阅者传进去执行结果</span></span><br><span class="line">[disposable addDisposable:innerDisposable];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:schedulingDisposable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>subscribe方法作用:<br>1.创建RACCompoundDisposable<br>2.创建RACPassthroughSubscriber 一个私有的类，只有一个实例初始化方法，内部分别持有属性innerSubscriber消息的订阅者，signal信号，disposable订阅者的销毁对象,遵循RACSubscriber协议，内部会执行sendNext，sendError，sendCompleted方法，实际会将消息转发给真正的订阅者innerSubscriber</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACPassthroughSubscriber</span> : <span class="title">NSObject</span> &lt;<span class="title">RACSubscriber</span>&gt;</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSubscriber:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber signal:(RACSignal *)signal disposable:(RACCompoundDisposable *)disposable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;RACSubscriber&gt; innerSubscriber;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">unsafe_unretained</span>, <span class="keyword">readonly</span>) RACSignal *signal;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACCompoundDisposable *disposable;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">self</span>.innerSubscriber sendNext:value];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>3.RACScheduler.subscriptionScheduler是一个全局的变量<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (RACScheduler *)subscriptionScheduler &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="keyword">static</span> RACScheduler *subscriptionScheduler;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">subscriptionScheduler = [[RACSubscriptionScheduler alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> subscriptionScheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建RACDynamicSignal的时候，存储了didSubscribe，接着执行 schedule 的block方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RACScheduler.currentScheduler == <span class="literal">nil</span>) <span class="keyword">return</span> [<span class="keyword">self</span>.backgroundScheduler schedule:block];</span><br><span class="line"></span><br><span class="line">block();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着执行block()也就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RACDisposble *innerDisposable = self.didSubscribe(subscriber);//将订阅者传进去执行结果</span><br><span class="line">[disposable addDisposable:innerDisposable];</span><br></pre></td></tr></table></figure></p><ul><li><p>调用self.didSubscribe(subscriber)对订阅者发送消息，执行了闭包block<br><code>[subscriber sendNext:@4];</code></p></li><li><p>sendNext</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark RACSubscriber</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">void</span> (^nextBlock)(<span class="keyword">id</span>) = [<span class="keyword">self</span>.next <span class="keyword">copy</span>];</span><br><span class="line"><span class="keyword">if</span> (nextBlock == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">nextBlock(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>sendNext操作，就是将subscribeNext初始化传进来的block进行copy,然后调用参数执行block,所以将参数x传递进来<br>执行下面这句话<br><code>NSLog(@&quot;signal %@&quot;,x);</code><br>忽略Error和RACDisposble，至此一个信号的创建和订阅完毕</p><h3 id="RACSignal-使用原理"><a href="#RACSignal-使用原理" class="headerlink" title="RACSignal 使用原理"></a>RACSignal 使用原理</h3><p>先订阅，然后发送信息，订阅者接收到消息<br>创建信号-&gt;subscribeNext -&gt;产生Subscriber-&gt; 执行信号创建时候存储的block-&gt; sendNext -&gt; subscriber接收消息</p><ul><li>RACSignal调用subscribeNext方法，新建一个RACSubscriber。</li><li>新建的RACSubscriber会copy，nextBlock，errorBlock，completedBlock存在自己的属性变量中。</li><li>RACSignal的子类RACDynamicSignal调用subscribe方法。</li><li>新建RACCompoundDisposable和RACPassthroughSubscriber对象。RACPassthroughSubscriber分别保存对RACSignal/RACSubscriber/RACCompoundDisposable的引用，注意对RACSignal的引用是unsafe_unretained的。</li><li>RACDynamicSignal调用didSubscribe闭包。先调用RACPassthroughSubscriber的相应的sendNext/sendError/sendCompleted方法。</li><li>RACPassthroughSubscriber再去调用self.innerSubscriber，即RACSubscriber的nextBlock/errorBlock/completedBlock。注意这里调用同样是先copy一份，再调用闭包执行。</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>将原来的RACSignal通过传入的block，生成新的RACSignal</p><p>bind方法比较看着长，但是内部实现可以理解为，将RACSignal进行解包出NSObject，然后将NSObject传入RACSignalBindBlock，生成新的 RACSignal 返回<br>如果不考虑RACDisposble和error，可以将bind简化<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">            <span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line">            [bindingBlock(x, &amp;stop) subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">                [subscriber sendNext:x];</span><br><span class="line">            &#125;];</span><br><span class="line">       &#125;];</span><br><span class="line">    &#125;]setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面结合实例讲解下bind的使用<br>为了方便讲解，下面将block方法进行编码进行源码解析<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposble * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line"> <span class="comment">//block1</span></span><br><span class="line">    [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *blockSignal = [signal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line"><span class="comment">//block2</span></span><br><span class="line">    <span class="keyword">return</span>  ^(<span class="built_in">NSNumber</span> *value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="comment">//block3</span></span><br><span class="line">        value = @(value.integerValue * value.integerValue);</span><br><span class="line">        <span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:value];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[blockSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line"><span class="comment">//block4</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"blockSignal %@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    <span class="comment">//block5</span></span><br><span class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line">        <span class="comment">//block6</span></span><br><span class="line">        __block <span class="keyword">volatile</span> int32_t signalCount = <span class="number">1</span>;   <span class="comment">// indicates self</span></span><br><span class="line"></span><br><span class="line">        RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (^completeSignal)(RACDisposable *) = ^(RACDisposable *finishedDisposable) &#123;</span><br><span class="line">            <span class="comment">//block7</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (^addSignal)(RACSignal *) = ^(RACSignal *signal) &#123;</span><br><span class="line">            <span class="comment">//block8</span></span><br><span class="line">            RACDisposable *disposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">            <span class="comment">//block 9</span></span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">            [compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">            RACDisposable *bindingDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// block 10</span></span><br><span class="line">                <span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line">                <span class="keyword">id</span> signal = bindingBlock(x, &amp;stop);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (signal != <span class="literal">nil</span>) addSignal(signal);</span><br><span class="line">                    <span class="keyword">if</span> (signal == <span class="literal">nil</span> || stop) &#123;</span><br><span class="line">                        [selfDisposable dispose];</span><br><span class="line">                        completeSignal(selfDisposable);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                [compoundDisposable dispose];</span><br><span class="line">                [subscriber sendError:error];</span><br><span class="line">            &#125; completed:^&#123;</span><br><span class="line">                <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                    completeSignal(selfDisposable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line"></span><br><span class="line">            selfDisposable.disposable = bindingDisposable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> compoundDisposable;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//RACSignalBindBlock:接受 NSObject 对象返回 RACSignal 对象<br><code>typedef RACSignal * _Nullable (^RACSignalBindBlock)(ValueType _Nullable value, BOOL *stop);</code></p><p>1.首先，根据RACSignal的创建方法，didSubscribe先保存block1 进行copy<br>2.调用bind方法，先执行bind5<br>3.创建新信号，didSubscribe将block6 进行copy<br>4.执行bindSignal的sunscribeNext方法，也就执行self.didSubscribe(subscriber),执行block6<br>5.block6内第一步先执行 <code>RACSignalBindBlock bindingBlock = block();</code> ，也就是执行block2,返回RACSignalBindBlock<br>6.执行<code>[self subscribeNext:{...}]</code> 此处self是bind方法的调用者即signal，于是订阅signal发出的信号,执行subscribe,执行signal信号的didSubscribe，于是此处执行block1<br>7.block1调用sendNext，于是执行subscriber的nextBlock，此处执行block10<br>8.block10中会先调用bindingBlock，这个是之前调用block2的返回值，这个RACStreamBindBlock对象里面保存的是block3,所以开始调用block3<br>9.block3 的入参，是signal中sendNext中发出来的value的值，这里对value进行操作变化，返回新的信号signal’<br>10.如果返回的signal’为空，则会调用completeSignal，即调用block7。block7中会发送sendCompleted。如果返回的signal’不为空，则会调用addSignal，即调用block8。block8内，对入参新信号signal’进行订阅。signal’是bind函数的返回值，实际调用<code>[RACSignal return:value];</code>返回的是 RACReturnSignal，当subscribeNext新信号，立即就会执行block，发出sendNext，执行block9<br>11.block9内部执行<code>[subscriber sendNext:x];</code>此处的subscriber是bind方法的入参，也就是新的bindSignal的订阅者，执行sendNext操作会执行bindSignal的nextBlock即block4<br>12.block9 中执行完sendNext，还会调用sendCompleted,completeSignal(signal, selfDisposable)执行completeSignal，即block7。<br>13.执行完block7，就完成了一次从signal 发送信号sendNext的全过程。</p><p>以上流程就是bind方法的全部执行过程</p><p>打印输出<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blockSignal <span class="number">1</span></span><br><span class="line">blockSignal <span class="number">4</span></span><br><span class="line">blockSignal <span class="number">9</span></span><br><span class="line">blockSignal <span class="number">16</span></span><br></pre></td></tr></table></figure></p><p>整个过程大致如下:</p><ul><li>订阅原信号中的值；</li><li>将原信号发出的值传入 RACSignalBindBlock 进行转换；</li><li>如果 RACSignalBindBlock 返回一个信号，就会订阅该信号并将信号中的所有值传给订阅者 subscriber；</li><li>如果 RACSignalBindBlock 请求终止信号就会向原信号发出 -sendCompleted 消息；</li><li>当所有信号都完成时，会向订阅者发送 -sendCompleted；</li><li>无论何时，如果信号发出错误，都会向订阅者发送 -sendError: 消息。</li></ul><p>信号的订阅发送，可以按需定制<br><img src="/images/RAC-发送订阅.png" alt="RAC-发送订阅"></p><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>事例<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:</span><br><span class="line">                         ^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//block1</span></span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"signal dispose"</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signal2 = [RACSignal createSignal:</span><br><span class="line"> ^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//block2</span></span><br><span class="line">[subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">[subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"signals dispose"</span>);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">    RACSignal *concatSignal = [signal1 concat:signal2];</span><br><span class="line"></span><br><span class="line">    [concatSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="comment">//block3</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p><p>下面看下concat内部操作<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)concat:(RACSignal *)signal &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACCompoundDisposable *compoundDisposable = [[RACCompoundDisposable alloc] init];</span><br><span class="line"><span class="comment">//block4</span></span><br><span class="line"></span><br><span class="line">RACDisposable *sourceDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="comment">//block5</span></span><br><span class="line">[subscriber sendNext:x]; <span class="comment">//收到signal1的信号</span></span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="comment">//block6</span></span><br><span class="line">RACDisposable *concattedDisposable = [signal subscribe:subscriber];</span><br><span class="line"><span class="comment">//signal2调用subscribe</span></span><br><span class="line">  <span class="comment">//内部执行`self.didSubscribe(subscriber)`</span></span><br><span class="line">[compoundDisposable addDisposable:concattedDisposable];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[compoundDisposable addDisposable:sourceDisposable];</span><br><span class="line"><span class="keyword">return</span> compoundDisposable;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -concat: %@"</span>, <span class="keyword">self</span>.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>内部调用createSignal产生新的信号concatSignal<br>signal1和signal2分别将各种的block存储在didSubscriber<br>concatSignal将block也存储在didSubscriber<br>1.首先concatSignal执行 <code>subscribeNext</code>，执行concatSignal的didSubscribe，于是执行block4<br>2.block4内部执行<code>self subscribeNext</code>此处self是方法调用者signal1,于是调用signal1的didSubscribe，signal1执行<code>sendNext</code>，然后执行nextBlock也就是block5<code>[subscriber sendNext:x];</code>，执行block3<br>3.当signal1调用sendCompleted，执行block6 调用 <code>[signal subscribe:subscriber];</code> 此处signal实际是signal2<br>4.执行signal2的 didsubscribe ，于是调用block2，内部执行<code>[subscriber sendNext:@2];</code>此处的subscriber是入参，也就是concatSignal的订阅者，所以再次调用block3直到sendCompleted或者sendError</p><p>注:<br>concat是有序的组合，第一个信号完成之后才发送第二个信号</p><p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-03-24 11:20:28.468644+0800 ReactiveObjcTest[83027:1136301] value = 1</span><br><span class="line">2018-03-24 11:25:14.451727+0800 ReactiveObjcTest[83027:1136301] value = 2</span><br><span class="line">2018-03-24 11:25:15.716178+0800 ReactiveObjcTest[83027:1136301] value = 3</span><br><span class="line">2018-03-24 11:25:15.716384+0800 ReactiveObjcTest[83027:1136301] signals dispose</span><br><span class="line">2018-03-24 11:25:15.716775+0800 ReactiveObjcTest[83027:1136301] signal dispose</span><br></pre></td></tr></table></figure></p><h3 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h3><p>将上面例子代码修改方法为<code>zipwith</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *concatSignal = [signal1 zipWith:signal2];</span><br><span class="line"></span><br><span class="line">[concatSignal subscribeNext:^(id x) &#123;</span><br><span class="line">NSLog(@&quot;value = %@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>zipwith源码分析<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)zipWith:(RACSignal *)signal &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">__block <span class="built_in">BOOL</span> selfCompleted = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *selfValues = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">__block <span class="built_in">BOOL</span> otherCompleted = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *otherValues = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^sendCompletedIfNecessary)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line"><span class="built_in">BOOL</span> selfEmpty = (selfCompleted &amp;&amp; selfValues.count == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">BOOL</span> otherEmpty = (otherCompleted &amp;&amp; otherValues.count == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 如果任意一个信号完成并且数组里面空了，就整个信号算完成</span></span><br><span class="line"><span class="keyword">if</span> (selfEmpty || otherEmpty) [subscriber sendCompleted];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^sendNext)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line"><span class="keyword">if</span> (selfValues.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (otherValues.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据进行拼接 然后移除</span></span><br><span class="line">RACTuple *tuple = RACTuplePack(selfValues[<span class="number">0</span>], otherValues[<span class="number">0</span>]);</span><br><span class="line">[selfValues removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">[otherValues removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="comment">//将拼接的数据进行发送</span></span><br><span class="line">[subscriber sendNext:tuple];</span><br><span class="line">sendCompletedIfNecessary();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅第一个信号</span></span><br><span class="line">RACDisposable *selfDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">[selfValues addObject:x ?: RACTupleNil.tupleNil];</span><br><span class="line">sendNext(); <span class="comment">//将值发送出去</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">selfCompleted = <span class="literal">YES</span>;</span><br><span class="line">sendCompletedIfNecessary();</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅第二个信号</span></span><br><span class="line">RACDisposable *otherDisposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">[otherValues addObject:x ?: RACTupleNil.tupleNil];</span><br><span class="line">sendNext(); <span class="comment">//将值发送出去</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">otherCompleted = <span class="literal">YES</span>;</span><br><span class="line">sendCompletedIfNecessary();</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[selfDisposable dispose];</span><br><span class="line">[otherDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -zipWith: %@"</span>, <span class="keyword">self</span>.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>zipWith里面有两个数组，分别会存储两个信号的值。</p><p>先执行第一个信号的didsubscribe,signal1执行<code>sendNext</code>,订阅之后将value装入selfValues，然后发送出去，<br>在 sendNext block中，会执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (selfValues.count == 0) return;</span><br><span class="line">if (otherValues.count == 0) return;</span><br></pre></td></tr></table></figure></p><p>此时otherValues为空，return，不会将消息发送出去<br>当第二个信号的值紧接着发出来了，第二个信号每发送一次值，也会存储到第二个数组中，然后再调用sendNext()，不会再return了，因为两个数组里面都有值了，两个数组的第0号位置都有一个值了,然后打包成元组RACTuple发送出去。并清空两个数组0号位置存储的值。<br>然后判断是否发送完成，如果任一信号完成且数组的内容为空，则订阅完成</p><p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-03-24 11:54:04.033897+0800 ReactiveObjcTest[83279:1168707] value = &lt;RACTwoTuple: 0x604000010f00&gt; (</span><br><span class="line">    1,</span><br><span class="line">    2</span><br><span class="line">)</span><br><span class="line">2018-03-24 11:54:06.402037+0800 ReactiveObjcTest[83279:1168707] signals dispose</span><br></pre></td></tr></table></figure></p><p>注:<br>如果value为空，会被拼接为<code>RACTupleNil.tupleNil</code></p><h2 id="RACDisposble-信号的清理"><a href="#RACDisposble-信号的清理" class="headerlink" title="RACDisposble 信号的清理"></a>RACDisposble 信号的清理</h2><p>在创建信号的时候，会返回一个 RACDisposble ，用于在订阅结束进行必要的清理</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACDisposable</span> () </span>&#123;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">volatile</span> _disposeBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACDisposable 最核心的就是 <code>_disposeBlock</code> ，内部的方法都是围绕它进行处理</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)disposableWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_disposeBlock = (<span class="keyword">void</span> *)<span class="built_in">CFBridgingRetain</span>([block <span class="keyword">copy</span>]);</span><br><span class="line">OSMemoryBarrier();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_disposeBlock = (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>;</span><br><span class="line">OSMemoryBarrier();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>void (^)(void)类型的block作为参数传入，会转化为CoreFoundation中的类型，赋值disposeBlock</p><p>下面是相关主要的子类RACSerialDisposable 和 RACCompoundDisposable</p><ul><li><p>RACSerialDisposable<br>线程安全，使用 pthread_mutex_t 保证<br>保证只含有一个RACDisposble</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  - (<span class="built_in">BOOL</span>)isDisposed &#123;</span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">BOOL</span> disposed = _disposed;</span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> disposed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RACCompoundDisposable<br>管理多个 RACDisposable 对象的释放</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACCompoundDisposable</span> () </span>&#123;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t _mutex;</span><br><span class="line">RACDisposable *_inlineDisposables[RACCompoundDisposableInlineCount];</span><br><span class="line"><span class="built_in">CFMutableArrayRef</span> _disposables;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDisposables:(<span class="built_in">NSArray</span> *)otherDisposables &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">self</span> init];</span><br><span class="line"></span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line">[otherDisposables enumerateObjectsUsingBlock:^(RACDisposable *disposable, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">self</span>-&gt;_inlineDisposables[index] = disposable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop after this iteration if we've reached the end of the inlined</span></span><br><span class="line"><span class="comment">// array.</span></span><br><span class="line"><span class="keyword">if</span> (index == RACCompoundDisposableInlineCount - <span class="number">1</span>) *stop = <span class="literal">YES</span>;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (otherDisposables.count &gt; RACCompoundDisposableInlineCount) &#123;</span><br><span class="line">_disposables = RACCreateDisposablesArray();</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRange</span> range = <span class="built_in">CFRangeMake</span>(RACCompoundDisposableInlineCount, (<span class="built_in">CFIndex</span>)otherDisposables.count - RACCompoundDisposableInlineCount);</span><br><span class="line"><span class="built_in">CFArrayAppendArray</span>(_disposables, (__bridge <span class="built_in">CFArrayRef</span>)otherDisposables, range);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对象持有的 RACDisposable 不超过 RACCompoundDisposableInlineCount(2) 时，都会存储在 <code>_inlineDisposables</code> 数组中，而更多的实例都会存储在 <code>_disposables</code> 中：</p><p>值得注意的还有一个 addDisposable 方法<br>方法线程安全，如果_inlineDisposables数组内没有存满，先优先存储在inlineDisposbles数组，如果存满，往_disposables拼接数据<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDisposable:(RACDisposable *)disposable &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(disposable != <span class="keyword">self</span>);</span><br><span class="line"><span class="keyword">if</span> (disposable == <span class="literal">nil</span> || disposable.disposed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> shouldDispose = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_disposed) &#123;</span><br><span class="line">shouldDispose = <span class="literal">YES</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; RACCompoundDisposableInlineCount; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (_inlineDisposables[i] == <span class="literal">nil</span>) &#123;</span><br><span class="line">_inlineDisposables[i] = disposable;</span><br><span class="line"><span class="keyword">goto</span> foundSlot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_disposables == <span class="literal">NULL</span>) _disposables = RACCreateDisposablesArray();</span><br><span class="line"><span class="built_in">CFArrayAppendValue</span>(_disposables, (__bridge <span class="keyword">void</span> *)disposable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RACCOMPOUNDDISPOSABLE_ADDED_ENABLED()) &#123;</span><br><span class="line">RACCOMPOUNDDISPOSABLE_ADDED(<span class="keyword">self</span>.description.UTF8String, disposable.description.UTF8String, <span class="built_in">CFArrayGetCount</span>(_disposables) + RACCompoundDisposableInlineCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line">foundSlot:;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shouldDispose) [disposable dispose];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="订阅的销毁"><a href="#订阅的销毁" class="headerlink" title="订阅的销毁"></a>订阅的销毁</h2><p>在了解了相关RACDisposble之后，再来看下bind方法中关于这方面发处理,以下是缩略版<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line"></span><br><span class="line">        __block <span class="keyword">volatile</span> int32_t signalCount = <span class="number">1</span>;   <span class="comment">// indicates self</span></span><br><span class="line"></span><br><span class="line">        RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (^completeSignal)(RACDisposable *) = ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (^addSignal)(RACSignal *) = ...</span><br><span class="line"></span><br><span class="line">        RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">        [compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">        RACDisposable *bindingDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (compoundDisposable.disposed) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">id</span> signal = bindingBlock(x, &amp;stop);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (signal != <span class="literal">nil</span>) addSignal(signal);</span><br><span class="line">            <span class="keyword">if</span> (signal == <span class="literal">nil</span> || stop) &#123;</span><br><span class="line">                [selfDisposable dispose];</span><br><span class="line">                completeSignal(selfDisposable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125; completed:^&#123;</span><br><span class="line">            completeSignal(selfDisposable);</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        selfDisposable.disposable = bindingDisposable;</span><br><span class="line">        <span class="keyword">return</span> compoundDisposable;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简化后，可以观察到，信号的清理交给了 RACCompoundDisposable 实例，向 RACCompoundDisposable添加了 RACSerialDisposable ，将信号订阅后返回的 RACDisposable 交给了 RACSerialDisposable</p><p>completeSignal 和  addSignal 负责新信号创建之后的清理<br>当订阅新信号，产生的 RACSerialDisposable 添加进 RACCompoundDisposable 实例<br>当信号完成，compoundDisposable进行清理工作</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^completeSignal)(RACDisposable *) = ^(RACDisposable *finishedDisposable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (OSAtomicDecrement32Barrier(&amp;signalCount) == <span class="number">0</span>) &#123;</span><br><span class="line">      [subscriber sendCompleted];</span><br><span class="line">      [compoundDisposable dispose];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      [compoundDisposable removeDisposable:finishedDisposable];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (^addSignal)(RACSignal *) = ^(RACSignal *signal) &#123;</span><br><span class="line">    OSAtomicIncrement32Barrier(&amp;signalCount);</span><br><span class="line"></span><br><span class="line">    RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">    [compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">    RACDisposable *disposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">      [subscriber sendNext:x];</span><br><span class="line">    &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">      [compoundDisposable dispose];</span><br><span class="line">      [subscriber sendError:error];</span><br><span class="line">    &#125; completed:^&#123;</span><br><span class="line">      <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        completeSignal(selfDisposable);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    selfDisposable.disposable = disposable;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="举栗子"><a href="#举栗子" class="headerlink" title="举栗子"></a>举栗子</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Origin Signal Dispose"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *blockSignal = [signal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">    <span class="keyword">return</span>  ^(<span class="built_in">NSNumber</span> *value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        value = @(value.integerValue * value.integerValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;value.integerValue; i++) &#123;</span><br><span class="line">                [subscriber sendNext:value];</span><br><span class="line">            &#125;</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"Binding Signal Dispose"</span>);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[blockSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"signal %@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">打印log</span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] signal <span class="number">1</span></span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] Binding Signal Dispose</span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] signal <span class="number">4</span></span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] signal <span class="number">4</span></span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] signal <span class="number">4</span></span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] signal <span class="number">4</span></span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] Binding Signal Dispose</span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] Origin Signal Dispose</span><br></pre></td></tr></table></figure><h2 id="RACStream-相关的方法"><a href="#RACStream-相关的方法" class="headerlink" title="RACStream 相关的方法"></a>RACStream 相关的方法</h2><ul><li>Map  一般用来信号变换</li></ul><p>事例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">//block1</span><br><span class="line"> [subscriber sendNext:@1];</span><br><span class="line"> [subscriber sendCompleted];</span><br><span class="line"> return nil;</span><br><span class="line"> &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *mapSignal = [signal1 map:^id _Nullable(id  _Nullable value) &#123;</span><br><span class="line">//block2</span><br><span class="line"> return @([value integerValue] * 10);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[mapSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">//block3</span><br><span class="line">  NSLog(@&quot;value = %@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>map 源码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)map:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"><span class="comment">//block4</span></span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^(<span class="keyword">id</span> value) &#123;</span><br><span class="line"><span class="comment">// block5</span></span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:block(value)];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -map:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>self.class 实际返回signal的class，signal是RACDynamicSignal类型<br>map方法内部实际调用<code>flattenMap</code>方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"><span class="comment">//block6</span></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line"><span class="comment">//block7</span></span><br><span class="line"><span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="comment">//block8</span></span><br><span class="line"><span class="keyword">id</span> stream = block(value) ?: [<span class="keyword">class</span> empty];</span><br><span class="line"><span class="built_in">NSCAssert</span>([stream isKindOfClass:RACStream.class], <span class="string">@"Value returned from -flattenMap: is not a stream: %@"</span>, stream);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> stream;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -flattenMap:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flattenMap 内部调用的bind方法</p><ul><li>signal1创建，将block存入didSubscribe</li><li>执行map方法，此处先执行 block4, block内部调用 flattenMap 方法，于是执行 block6</li><li>block6 内部执行bind方法，于是创建新的信号作为返回结果 mapSignal</li><li>bind方法内部执行<code>RACSignalBindBlock bindingBlock = block();</code> 也就是将 block7 进行储存</li><li>然后调用bind方法内部的<code>[self subscribeNext:]</code>，对self进行订阅，self是map方法的调用者，也就是signal1，执行signal1的didSubscribe，</li><li>signal1调用<code>sendNext</code>执行，然后执行 bind方法内部<code>id signal = bindingBlock(x, &amp;stop);</code>，也就是执行bind方法的入参闭包，此处执行block7</li><li>接着执行block8,执行<code>id stream = block(value) ?: [class empty];</code> 此处执行block(value)，也就是flattenMap方法的入参闭包也就是block5</li><li>block5执行<code>return [class return:block(value)];</code>此处的block闭包是执行map方法的block闭包，也就是block2<br><code>[class return:value]</code>内部返回 RACReturnSignal ，当返回结果有值，则返回，否则返回<code>[class empty]</code>，也就是RACEmptySignal</li><li>返回信号不为nil，执行bind方法内部的<code>[signal subscribeNext:]</code> 对返回的信号进行订阅，由于返回的信号是RACReturnSignal类型，订阅之后直接调用subscribe方法执行sendNext，也就是订阅到执行block3</li></ul><p>map 就是将信号的值进行变换产生新的信号，将变换后的值进行发送出去，让调用者接收到新值</p><p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-03-24 15:42:28.407001+0800 ReactiveObjcTest[96645:1260165] value = 10</span><br></pre></td></tr></table></figure></p><ul><li>mapReplace<br>不管signal1 发送什么值，都替换成@“A”。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalB = [signal1 mapReplace:@&quot;A&quot;];</span><br></pre></td></tr></table></figure></li></ul><p>mapReplace 源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)mapReplace:(id)object &#123;</span><br><span class="line">    return [[self map:^(id _) &#123;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -mapReplace: %@&quot;, self.name, [object rac_description]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mapReplace 内部调用map方法，只是返回的是参数object 固定的</p><ul><li>reduceEach<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal2 = [signal1 reduceEach:^id(NSNumber *num1 , NSNumber *num2)&#123;</span><br><span class="line"> return @([num1 intValue] + [num2 intValue]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li></ul><p>reduceEach 源码分析<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)reduceEach:(<span class="keyword">id</span> (^)())reduceBlock &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(reduceBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    __<span class="keyword">weak</span> RACStream *stream __attribute__((unused)) = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> map:^(RACTuple *t) &#123;</span><br><span class="line">        <span class="built_in">NSCAssert</span>([t isKindOfClass:RACTuple.class], <span class="string">@"Value from stream %@ is not a tuple: %@"</span>, stream, t);</span><br><span class="line">        <span class="keyword">return</span> [RACBlockTrampoline invokeBlock:reduceBlock withArguments:t];</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -reduceEach:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处先断言入参block是否为空，然后弱引用当前对象self<br>内部调用map方法，内部断言入参是否是合法的</p><p>RACBlockTrampoline<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACBlockTrampoline</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="keyword">id</span> block;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBlock:(<span class="keyword">id</span>)block &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_block = [block <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)invokeBlock:(<span class="keyword">id</span>)block withArguments:(RACTuple *)arguments &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">RACBlockTrampoline *trampoline = [[<span class="keyword">self</span> alloc] initWithBlock:block];</span><br><span class="line"><span class="keyword">return</span> [trampoline invokeWithArguments:arguments];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)invokeWithArguments:(RACTuple *)arguments &#123;</span><br><span class="line">SEL selector = [<span class="keyword">self</span> selectorForArgumentCount:arguments.count];</span><br><span class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:[<span class="keyword">self</span> methodSignatureForSelector:selector]];</span><br><span class="line">invocation.selector = selector;</span><br><span class="line">invocation.target = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; arguments.count; i++) &#123;</span><br><span class="line"><span class="keyword">id</span> arg = arguments[i];</span><br><span class="line"><span class="built_in">NSInteger</span> argIndex = (<span class="built_in">NSInteger</span>)(i + <span class="number">2</span>);</span><br><span class="line">[invocation setArgument:&amp;arg atIndex:argIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[invocation invoke];</span><br><span class="line"></span><br><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> returnVal;</span><br><span class="line">[invocation getReturnValue:&amp;returnVal];</span><br><span class="line"><span class="keyword">return</span> returnVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>内部持有 block，初始化的时候是给block赋值，动态的构造一个NSInvocation并执行<br>将结果进行返回，也是map闭包里面的返回值</p><p>事例<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        RACTuple *tuple = [RACTuple tupleWithObjects:<span class="string">@"1"</span>,<span class="string">@"2"</span>, <span class="literal">nil</span>];</span><br><span class="line">        [subscriber sendNext:tuple];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signal2 = [signal1 reduceEach:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *num1 , <span class="built_in">NSNumber</span> *num2)&#123;</span><br><span class="line">      <span class="keyword">return</span> @([num1 intValue] + [num2 intValue]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal2 subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"value %@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>reduceEach 内部还是调用 map 方法,当signal1的发出的值包裹的数据是RACTuple类型时，才可以使用该操作,入参是block，参数可以任意</p><p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-03-24 16:24:39.880757+0800 ReactiveObjcTest[97285:1354826] value 3</span><br></pre></td></tr></table></figure></p><p>剩下的方法这里先不介绍了,可自行查阅<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">- (RACSignal *)not;</span><br><span class="line">- (RACSignal *)and;</span><br><span class="line">- (RACSignal *)or;</span><br><span class="line">- (RACSignal *)reduceApply;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，<em>系统总是重新从它所在的内存读取数据</em>，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a = i;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span></span><br><span class="line"><span class="keyword">int</span> b = i;</span><br></pre></td></tr></table></figure><p>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取<br>volatile 可以保证对特殊地址的稳定访问</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RACSignal 相关的类及代码较简洁，方法也不是很复杂，但是之前并没有深入学习，理解还是需要分析的。<br>结合实际事例，查看调用栈分析情况容易入手，<br>使用上看着也方便，但是内部创建了多个实例对象，信号、订阅者、信号清理机制等，弄清楚流程就简单了</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://github.com/Draveness/analyze/blob/master/contents/ReactiveObjC/RACSignal.md" target="_blank" rel="noopener">https://github.com/Draveness/analyze/blob/master/contents/ReactiveObjC/RACSignal.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文源码为 ReactiveObjc 3.1.0 版本&lt;/p&gt;
&lt;p&gt;ReactiveCocoa 开源已
      
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="https://pattyxp.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>AFNetworking源码分析</title>
    <link href="https://pattyxp.github.io/2018/02/27/AFNetworking%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://pattyxp.github.io/2018/02/27/AFNetworking源码分析/</id>
    <published>2018-02-27T08:43:30.000Z</published>
    <updated>2018-03-01T07:38:29.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AFNetworking结构"><a href="#AFNetworking结构" class="headerlink" title="AFNetworking结构"></a>AFNetworking结构</h2><p>主要分为五部分内容</p><ul><li>网络通信NSURLSession (核心)</li><li>网络状态监听Reachability</li><li>网络安全Security</li><li>网络信息序列化Serialization</li><li>UIKit扩展</li></ul><h2 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h2><p>AFNetworking 基于NSURLSession 封装了 AFURLSessionManager 和 AFHTTPSessionManager<br>AFHTTPSessionManager继承自 AFURLSessionManager 主要提供对外的接口API<br>AFURLSessionManager 才是核心关键</p><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>先来看下AFHTTPSessionManager 网络请求，以POST为例，调用父类方法获取task，然后调用resume<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)POST:(NSString *)URLString</span><br><span class="line">                    parameters:(id)parameters</span><br><span class="line">                      progress:(void (^)(NSProgress * _Nonnull))uploadProgress</span><br><span class="line">                       success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success</span><br><span class="line">                       failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;POST&quot; URLString:URLString parameters:parameters uploadProgress:uploadProgress downloadProgress:nil success:success failure:failure];</span><br><span class="line"></span><br><span class="line">    [dataTask resume];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在父类方法中，将参数和请求URL转化为Request，然后生成dataTask做网络请求</span><br><span class="line"></span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</span><br><span class="line">                                       URLString:(NSString *)URLString</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</span><br><span class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</span><br><span class="line">&#123;</span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    dataTask = [self dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="请求参数解析类"><a href="#请求参数解析类" class="headerlink" title="请求参数解析类"></a>请求参数解析类</h2><p>详解如何将参数转化为Request<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableURLRequest *)requestWithMethod:(NSString *)method</span><br><span class="line">                                 URLString:(NSString *)URLString</span><br><span class="line">                                parameters:(id)parameters</span><br><span class="line">                                     error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line"></span><br><span class="line">    NSParameterAssert(url);</span><br><span class="line"></span><br><span class="line">    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];</span><br><span class="line">    mutableRequest.HTTPMethod = method;</span><br><span class="line"></span><br><span class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主要作用</p><ul><li>生成 NSMutableURLRequest</li><li>设置 Request的 HTTPMethod</li><li>AFHTTPRequestSerializerObservedKeyPaths内包含 NSMutableURLRequest的部分属性<ul><li>BOOL allowsCellularAccess;</li><li>NSURLRequestCachePolicy cachePolicy;cachePolicy</li><li>BOOL HTTPShouldHandleCookies</li><li>BOOL HTTPShouldUsePipelining</li><li>NSURLRequestNetworkServiceType networkServiceType</li><li>NSTimeInterval timeoutInterval<br>当检测到这几个属性有变化，重新赋值给mutableRequest</li></ul></li><li>将parameter进行编码添加入request</li></ul><h2 id="parameter编码"><a href="#parameter编码" class="headerlink" title="parameter编码"></a>parameter编码</h2><p>请求参数进行编码，根据请求Method区分参数是拼接在URL后面 setURL，还是设置请求体setHTTPBody<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</span><br><span class="line">                               withParameters:(id)parameters</span><br><span class="line">                                        error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</span><br><span class="line">    ...</span><br><span class="line">    NSString *query = nil;</span><br><span class="line">    ...</span><br><span class="line">    //将参数进行拼接</span><br><span class="line">    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">    ...</span><br><span class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;  // 如果是 GET 等，拼接参数重置 URL</span><br><span class="line">        if (query &amp;&amp; query.length &gt; 0) &#123;</span><br><span class="line">            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // #2864: an empty string is a valid x-www-form-urlencoded payload</span><br><span class="line">        if (!query) &#123;</span><br><span class="line">            query = @&quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</span><br><span class="line">            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];   //setHTTPHeaderField</span><br><span class="line">        &#125;</span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];// setHTTPBody</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/parameter转换.png" alt="parameter转换"></p><p>参数转码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">NSString * AFQueryStringFromParameters(NSDictionary *parameters) &#123;</span><br><span class="line">    NSMutableArray *mutablePairs = [NSMutableArray array];</span><br><span class="line">    //将参数转化为字典</span><br><span class="line">    for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class="line">    &#125;</span><br><span class="line">    //拼接</span><br><span class="line">    return [mutablePairs componentsJoinedByString:@&quot;&amp;&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSArray * AFQueryStringPairsFromDictionary(NSDictionary *dictionary) &#123;</span><br><span class="line">    return AFQueryStringPairsFromKeyAndValue(nil, dictionary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) &#123;</span><br><span class="line">    NSMutableArray *mutableQueryStringComponents = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">    //将参数的key对description进行排序，使用compare方法比较</span><br><span class="line">    //&#123; net,bar,base&#125; -&gt; &#123; bar,base,net&#125;</span><br><span class="line">    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;description&quot; ascending:YES selector:@selector(compare:)];</span><br><span class="line"></span><br><span class="line">    //对value是dict，array，set类型处理，直到为其他类型，生成AFQueryStringPair插入数组</span><br><span class="line">    if ([value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">        NSDictionary *dictionary = value;</span><br><span class="line">        for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            id nestedValue = dictionary[nestedKey];</span><br><span class="line">            if (nestedValue) &#123;</span><br><span class="line">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@&quot;%@[%@]&quot;, key, nestedKey] : nestedKey), nestedValue)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if ([value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">        NSArray *array = value;</span><br><span class="line">        for (id nestedValue in array) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@&quot;%@[]&quot;, key], nestedValue)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if ([value isKindOfClass:[NSSet class]]) &#123;</span><br><span class="line">        NSSet *set = value;</span><br><span class="line">        for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参数转码举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@&#123;</span><br><span class="line">     @&quot;name&quot; : @&quot;bang&quot;,</span><br><span class="line">     @&quot;phone&quot;: @&#123;@&quot;mobile&quot;: @&quot;xx&quot;, @&quot;home&quot;: @&quot;xx&quot;&#125;,</span><br><span class="line">     @&quot;families&quot;: @[@&quot;father&quot;, @&quot;mother&quot;],</span><br><span class="line">     @&quot;nums&quot;: [NSSet setWithObjects:@&quot;1&quot;, @&quot;2&quot;, nil]</span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line">@[</span><br><span class="line">     field: @&quot;name&quot;, value: @&quot;bang&quot;,</span><br><span class="line">     field: @&quot;phone[mobile]&quot;, value: @&quot;xx&quot;,</span><br><span class="line">     field: @&quot;phone[home]&quot;, value: @&quot;xx&quot;,</span><br><span class="line">     field: @&quot;families[]&quot;, value: @&quot;father&quot;,</span><br><span class="line">     field: @&quot;families[]&quot;, value: @&quot;mother&quot;,</span><br><span class="line">     field: @&quot;nums&quot;, value: @&quot;1&quot;,</span><br><span class="line">     field: @&quot;nums&quot;, value: @&quot;2&quot;,</span><br><span class="line">]</span><br><span class="line">-&gt;</span><br><span class="line">name=bang&amp;phone[mobile]=xx&amp;phone[home]=xx&amp;families[]=father&amp;families[]=mother&amp;nums=1&amp;num=2</span><br></pre></td></tr></table></figure></p><p>至此，request已经设置好，下面就是如何生成 NSURLSessionDataTask</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">dataTask = [self dataTaskWithRequest:request ...]</span><br><span class="line"></span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line"></span><br><span class="line">    //为了解决iOS 8以下 创建task并发创建多个task但因同步问题导致task的identifier不唯一，所以串行处理</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [self.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug 1140.11</span><br><span class="line"></span><br><span class="line">static void url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123;</span><br><span class="line">        // Fix of bug</span><br><span class="line">        // Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span><br><span class="line">        // Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span><br><span class="line">        dispatch_sync(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个task都对应一个delegate,便于之后数据处理以及回调<br>根据dataTask唯一的taskIdentifier和AFURLSessionManagerTaskDelegate相对应，存储在字典中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class="line">    delegate.manager = self;  //设置manager</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</span><br><span class="line">    [self setDelegate:delegate forTask:dataTask]; //绑定delegate和dataTask</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(NSURLSessionTask *)task</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    //保证线程安全</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    //将AFdelegate存入以task的identifier为key的字典中</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    //监听task任务开始和暂停的通知</span><br><span class="line">    [self addNotificationObserverForTask:task];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//监听task任务开始和暂停的通知</span><br><span class="line">- (void)addNotificationObserverForTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上方法创建了AFURLSessionManagerTaskDelegate 将其和dataTask对应存储到manager的字典中，<br>同时还监听任务开始和挂起的通知，<br>差不多准备工作完毕，在AFHTTPSessionManager中拿到了返回的task，调用了resume启动任务</p><p>网络开始请求数据，初始化的时候，设置AFURLSessionManager 为session的代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br></pre></td></tr></table></figure></p><p>于是会进行下面的回调<br><img src="/images/AFNet-代理方法整理..png" alt="AFNet-代理方法整理"></p><p>AFURLSessionManager 包含许多自定义的block，可以在回调方法中处理接收到数据<br>其中六个方法会回调到AF自定义的delegate,负责把每个task对应的数据回调出去<br><img src="/images/AFNet-AFDelegate.jpeg" alt="AFNet-AFDelegate"></p><p>以task 请求baidu为例<br>首先会收到回调receiveData<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];</span><br><span class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line"></span><br><span class="line">    if (self.dataTaskDidReceiveData) &#123;</span><br><span class="line">        self.dataTaskDidReceiveData(session, dataTask, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    self.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive;</span><br><span class="line">    self.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived;</span><br><span class="line"></span><br><span class="line">    [self.mutableData appendData:data]; //拼接data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果请求完成，进入下面操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    // delegate may be nil when completing a task in the background</span><br><span class="line">    if (delegate) &#123;</span><br><span class="line">        //把代理转发给我们绑定的AFURLSessionManagerTaskDelegate</span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line"></span><br><span class="line">        [self removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //执行 completeblock</span><br><span class="line">    if (self.taskDidComplete) &#123;</span><br><span class="line">        self.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">  /*</span><br><span class="line">  @interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;</span><br><span class="line"></span><br><span class="line">  @property (nonatomic, weak) AFURLSessionManager *manager;</span><br><span class="line"></span><br><span class="line">  AFURLSessionManagerTaskDelegate 弱持有manager，所以下面强引用manager</span><br><span class="line">  不会存在循环引用问题</span><br><span class="line">  */</span><br><span class="line">    __strong AFURLSessionManager *manager = self.manager;</span><br><span class="line"></span><br><span class="line">    __block id responseObject = nil;</span><br><span class="line"></span><br><span class="line">    //下面对userInfo进行拼接</span><br><span class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    if (self.mutableData) &#123;</span><br><span class="line">        data = [self.mutableData copy]; //任务完成了，将数据拷贝后，不需要mutableData，清空释放内存</span><br><span class="line">        self.mutableData = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</span><br><span class="line">    &#125; else if (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (error) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">        //在自定义的completionGroup或者completionQueue进行回调操作</span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (self.completionHandler) &#123;</span><br><span class="line">                self.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line">            //在主线程发出任务完成通知</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            NSError *serializationError = nil;</span><br><span class="line"></span><br><span class="line">            //根据定义的responseSerializer 解析数据</span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            //如果是下载文件，解析数据为下载路径</span><br><span class="line">            if (self.downloadFileURL) &#123;</span><br><span class="line">                responseObject = self.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                if (self.completionHandler) &#123;</span><br><span class="line">                    self.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h2><p>自定义block，通过对外声明set方法，重写block的set方法，清晰了解block的参数和返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@interface AFURLSessionManager ()</span><br><span class="line">@property (readwrite, nonatomic, strong) NSURLSessionConfiguration *sessionConfiguration;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSOperationQueue *operationQueue;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSURLSession *session;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;</span><br><span class="line">@property (readonly, nonatomic, copy) NSString *taskDescriptionForSessionTasks;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSLock *lock;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidCompleteBlock taskDidComplete;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>下面了解下各个block的使用</p><ul><li><p>AFURLSessionDidBecomeInvalidBlock</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当session失效，该代理方法被调用</span><br><span class="line">当调用finishTasksAndInvalidate使session失效，但是允许现有任务运行完成之后调用该代理</span><br><span class="line">当调用invalidateAndCancel,session会立即调用该代理</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didBecomeInvalidWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">  if (self.sessionDidBecomeInvalid) &#123;</span><br><span class="line">      self.sessionDidBecomeInvalid(session, error);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AFURLSessionDidReceiveAuthenticationChallengeBlock</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  该方法主要用于对https的认证</span><br><span class="line">*/</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    // 挑战处理类型</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    // 使用指定证书</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line"></span><br><span class="line">    if (self.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      /*</span><br><span class="line">       此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust</span><br><span class="line">      也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。</span><br><span class="line">      而这个证书就需要使用credentialForTrust:来创建一个NSURLCredential对象</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">          // 基于客户端的安全策略来决定是否信任该服务器</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line"></span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                if (credential) &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengeUseCredential; //使用证书</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;//取消挑战</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //完成挑战</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AFURLSessionDidFinishEventsForBackgroundURLSessionBlock</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当session中所有已经入队的消息被发送出去后，会调用该代理方法</span><br><span class="line"></span><br><span class="line">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session &#123;</span><br><span class="line">    if (self.didFinishEventsForBackgroundURLSession) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            self.didFinishEventsForBackgroundURLSession(session);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>AFURLSessionTaskWillPerformHTTPRedirectionBlock<br>//当服务器重定向的时候调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">willPerformHTTPRedirection:(NSHTTPURLResponse *)response</span><br><span class="line">        newRequest:(NSURLRequest *)request</span><br><span class="line"> completionHandler:(void (^)(NSURLRequest *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLRequest *redirectRequest = request;</span><br><span class="line"></span><br><span class="line">    //如果存在自定义重定向block，返回新的重定向Request</span><br><span class="line">    if (self.taskWillPerformHTTPRedirection) &#123;</span><br><span class="line">        redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用request重新请求</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(redirectRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AFURLSessionTaskDidReceiveAuthenticationChallengeBlock</p></li></ul><p>和上面认证https方法类似，只是多了参数task,可以根据每个task去自定义需要的https认证方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line"></span><br><span class="line">    if (self.taskDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>AFURLSessionTaskNeedNewBodyStreamBlock</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line"> needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSInputStream *inputStream = nil;</span><br><span class="line"></span><br><span class="line">    if (self.taskNeedNewBodyStream) &#123;</span><br><span class="line">        inputStream = self.taskNeedNewBodyStream(session, task);</span><br><span class="line">    &#125; else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) &#123;</span><br><span class="line">        inputStream = [task.originalRequest.HTTPBodyStream copy];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.jianshu.com/p/856f0e26279d" target="_blank" rel="noopener">https://www.jianshu.com/p/856f0e26279d</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AFNetworking结构&quot;&gt;&lt;a href=&quot;#AFNetworking结构&quot; class=&quot;headerlink&quot; title=&quot;AFNetworking结构&quot;&gt;&lt;/a&gt;AFNetworking结构&lt;/h2&gt;&lt;p&gt;主要分为五部分内容&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="源码" scheme="https://pattyxp.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>内存分配</title>
    <link href="https://pattyxp.github.io/2018/02/27/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://pattyxp.github.io/2018/02/27/内存分配/</id>
    <published>2018-02-27T07:07:05.000Z</published>
    <updated>2018-02-27T08:16:00.199Z</updated>
    
    <content type="html"><![CDATA[<p>本文分析内存使用Xcode自带的Instruments分析工具Alloctions<br>运行profile下的Alloctions，可以看到有一栏统计All Heap &amp; Anonymous VM使用的内存<br>All Heap:堆上分配的内存情况<br>Anonymous VM:虚拟内存分配</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>当应用向系统申请分配内存时，系统不会返回需要的物理内存地址，而是返回虚拟内存地址。当开始真正使用申请到的虚拟内存的时候，系统才将虚拟内存映射到具体的物理内存上。</p><h2 id="内存页"><a href="#内存页" class="headerlink" title="内存页"></a>内存页</h2><p>系统将内存页分为三种状态。</p><p>活跃内存页（active pages）- 这种内存页已经被映射到物理内存中，而且近期被访问过，处于活跃状态。<br>非活跃内存页（inactive pages）- 这种内存页已经被映射到物理内存中，但是近期没有被访问过。<br>可用的内存页（free pages）- 没有关联到虚拟内存页的物理内存页集合。</p><p>当可用的内存页降低到一定的阀值时，系统就会采取低内存应对措施，在OSX中，系统会将非活跃内存页交换到硬盘上，而在iOS中，则会触发Memory Warning，如果你的App没有处理低内存警告并且还在后台占用太多内存，则有可能被杀掉。</p><h2 id="VM-Region-Size"><a href="#VM-Region-Size" class="headerlink" title="VM Region Size"></a>VM Region Size</h2><p><img src="/images/内存分配-1.png" alt="内存分配"><br>上图是mac OS应用的 VM Tracker分析图，可以看到VM Tree Region有4种size</p><ul><li>Dirty Size</li><li>Swapped Size:交换到硬盘上的大小 仅OSX系统适用</li><li>Resident Size:实际使用物理内存的大小</li><li>Virtual Size:虚拟内存大小</li></ul><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>我们常使用以下几种方式来分配内存</p><ul><li>NSObject的 alloc 方法</li><li>c函数的 malloc 方法<br>malloc有一个缺陷，必须配合memset将内存区中所有的值设置为0。这样就导致了一个问题:malloc出一块内存区域时，系统并没有分配物理内存。然而调用memset后，系统将会把malloc出的所有虚拟内存关联到物理内存上<br>因此系统建议使用calloc方法,calloc返回的内存区域会自动清零，而且只有使用时才会关联到物理内存并清零。</li></ul><p>以OC当中创建实例对象为例，最终调用方法_class_createInstanceFromZone<br>方法内部调用calloc来分配内存，下图显示调用栈的情况<br><img src="/images/内存分配-alloc.png" alt="内存分配-alloc"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              bool cxxConstruct = true,</span><br><span class="line">                              size_t *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    if (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">        obj = (id)calloc(1, size);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (zone) &#123;</span><br><span class="line">            obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj = (id)calloc(1, size);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://juejin.im/post/5a5e13c45188257327399e19" target="_blank" rel="noopener">https://juejin.im/post/5a5e13c45188257327399e19</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文分析内存使用Xcode自带的Instruments分析工具Alloctions&lt;br&gt;运行profile下的Alloctions，可以看到有一栏统计All Heap &amp;amp; Anonymous VM使用的内存&lt;br&gt;All Heap:堆上分配的内存情况&lt;br&gt;Ano
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Aspects源码解析</title>
    <link href="https://pattyxp.github.io/2018/02/23/Aspects%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://pattyxp.github.io/2018/02/23/Aspects源码解析/</id>
    <published>2018-02-23T07:37:15.000Z</published>
    <updated>2018-05-10T02:38:41.051Z</updated>
    
    <content type="html"><![CDATA[<p>本文源码解析来自官方1.4.2版本</p><h2 id="AspectInfo"><a href="#AspectInfo" class="headerlink" title="AspectInfo"></a>AspectInfo</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AspectInfo</span> : <span class="title">NSObject</span> &lt;<span class="title">AspectInfo</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">unsafe_unretained</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> instance;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *arguments;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSInvocation</span> *originalInvocation;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="AspectIdentifier"><a href="#AspectIdentifier" class="headerlink" title="AspectIdentifier"></a>AspectIdentifier</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AspectIdentifier</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SEL selector;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> block;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMethodSignature</span> *blockSignature;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> object;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AspectOptions options;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="AspectsContainer"><a href="#AspectsContainer" class="headerlink" title="AspectsContainer"></a>AspectsContainer</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AspectsContainer</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)removeAspect:(<span class="keyword">id</span>)aspect;</span><br><span class="line">- (<span class="built_in">BOOL</span>)hasAspects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *beforeAspects;</span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *insteadAspects;</span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *afterAspects;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="AspectTracker"><a href="#AspectTracker" class="headerlink" title="AspectTracker"></a>AspectTracker</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AspectTracker</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Class trackedClass;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *trackedClassName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span> *selectorNames;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *selectorNamesToSubclassTrackers;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithTrackedClass:(Class)trackedClass;</span><br><span class="line">- (<span class="keyword">void</span>)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(<span class="built_in">NSString</span> *)selectorName;</span><br><span class="line">- (<span class="keyword">void</span>)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(<span class="built_in">NSString</span> *)selectorName;</span><br><span class="line">- (<span class="built_in">BOOL</span>)subclassHasHookedSelectorName:(<span class="built_in">NSString</span> *)selectorName;</span><br><span class="line">- (<span class="built_in">NSSet</span> *)subclassTrackersHookingSelectorName:(<span class="built_in">NSString</span> *)selectorName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>调试，首先调用aspect_add方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> aspect_add(<span class="keyword">id</span> <span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="keyword">id</span> block, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(block);</span><br><span class="line"></span><br><span class="line">    __block AspectIdentifier *identifier = <span class="literal">nil</span>;</span><br><span class="line">    aspect_performLocked(^&#123;</span><br><span class="line">        <span class="keyword">if</span> (aspect_isSelectorAllowedAndTrack(<span class="keyword">self</span>, selector, options, error)) &#123;</span><br><span class="line">            AspectsContainer *aspectContainer = aspect_getContainerForObject(<span class="keyword">self</span>, selector);</span><br><span class="line">            identifier = [AspectIdentifier identifierWithSelector:selector object:<span class="keyword">self</span> options:options block:block error:error];  <span class="comment">//生成AspectIdentifier</span></span><br><span class="line">            <span class="keyword">if</span> (identifier) &#123;</span><br><span class="line">                [aspectContainer addAspect:identifier withOptions:options];</span><br><span class="line">                <span class="comment">//区分options向aspectContainer的数组添加aspect</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Modify the class to allow message interception.</span></span><br><span class="line">                aspect_prepareClassAndHookSelector(<span class="keyword">self</span>, selector, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> identifier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> AspectsContainer *aspect_getContainerForObject(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</span><br><span class="line">    SEL aliasSelector = aspect_aliasForSelector(selector);<span class="comment">//拼接生成新selector</span></span><br><span class="line">    AspectsContainer *aspectContainer = objc_getAssociatedObject(<span class="keyword">self</span>, aliasSelector);</span><br><span class="line">    <span class="keyword">if</span> (!aspectContainer) &#123;</span><br><span class="line">        aspectContainer = [AspectsContainer new];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, aliasSelector, aspectContainer, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前对象如果不存在aliasSelector,给当前对象绑定属性aliasSelector</span></span><br><span class="line">    <span class="keyword">return</span> aspectContainer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>aspect_performLocked 使用OSSpinLock</li><li>aspect_isSelectorAllowedAndTrack 过滤当前aspect的selector是否为合法的selector</li><li>生成AspectIdentifier,根据block生成block签名,根据options加入AspectContainer的相应数组</li><li>aspect_prepareClassAndHookSelector hook方法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_prepareClassAndHookSelector(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line">    Class klass = aspect_hookClass(<span class="keyword">self</span>, error);</span><br><span class="line">    Method targetMethod = class_getInstanceMethod(klass, selector);</span><br><span class="line">    IMP targetMethodIMP = method_getImplementation(targetMethod);</span><br><span class="line">    <span class="keyword">if</span> (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *typeEncoding = method_getTypeEncoding(targetMethod);</span><br><span class="line">        SEL aliasSelector = aspect_aliasForSelector(selector);</span><br><span class="line">        <span class="keyword">if</span> (![klass instancesRespondToSelector:aliasSelector]) &#123;</span><br><span class="line">            __unused <span class="built_in">BOOL</span> addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);</span><br><span class="line">            <span class="built_in">NSCAssert</span>(addedAlias, <span class="string">@"Original implementation for %@ is already copied to %@ on %@"</span>, <span class="built_in">NSStringFromSelector</span>(selector), <span class="built_in">NSStringFromSelector</span>(aliasSelector), klass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We use forwardInvocation to hook in.</span></span><br><span class="line">        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(<span class="keyword">self</span>, selector), typeEncoding);</span><br><span class="line">        AspectLog(<span class="string">@"Aspects: Installed hook for -[%@ %@]."</span>, klass, <span class="built_in">NSStringFromSelector</span>(selector));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>aspect_prepareClassAndHookSelector 方法主要操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - Hook Class</span><br><span class="line"></span><br><span class="line">static Class aspect_hookClass(NSObject *self, NSError **error) &#123;</span><br><span class="line">    NSCParameterAssert(self);</span><br><span class="line">Class statedClass = self.class;</span><br><span class="line">Class baseClass = object_getClass(self);</span><br><span class="line">NSString *className = NSStringFromClass(baseClass);</span><br><span class="line"></span><br><span class="line">if ([className hasSuffix:AspectsSubclassSuffix]) &#123;</span><br><span class="line">return baseClass;</span><br><span class="line">&#125;else if (class_isMetaClass(baseClass)) &#123;</span><br><span class="line">        return aspect_swizzleClassInPlace((Class)self);</span><br><span class="line">        // Probably a KVO&apos;ed class. Swizzle in place. Also swizzle meta classes in place.</span><br><span class="line">    &#125;else if (statedClass != baseClass) &#123;</span><br><span class="line">        return aspect_swizzleClassInPlace(baseClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  //生成子类subclass</span><br><span class="line">const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;</span><br><span class="line">Class subclass = objc_getClass(subclassName);</span><br><span class="line"></span><br><span class="line">if (subclass == nil) &#123;</span><br><span class="line">subclass = objc_allocateClassPair(baseClass, subclassName, 0);//Allocate subclass</span><br><span class="line">if (subclass == nil) &#123;</span><br><span class="line">            NSString *errrorDesc = [NSString stringWithFormat:@&quot;objc_allocateClassPair failed to allocate class %s.&quot;, subclassName];</span><br><span class="line">            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">aspect_swizzleForwardInvocation(subclass);//替换子类forwardInvocation方法</span><br><span class="line">aspect_hookedGetClass(subclass, statedClass);//替换子类class方法为原类statedClass</span><br><span class="line">aspect_hookedGetClass(object_getClass(subclass), statedClass);//替换子类的元类的class方法为原类statedClass</span><br><span class="line">objc_registerClassPair(subclass);//注册子类</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object_setClass(self, subclass);//替换当前对象的isa为subclass obj-&gt;changeIsa(cls)</span><br><span class="line">return subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先 对当前self进行hook class<br>此处self为AspectsViewController类型的对象，hook后为AspectsViewController<em>Aspects</em></li><li>给子类也就是hook后的类AspectsViewController<em>Aspects</em>添加方法，name为aspect_aliasForSelector(selector),方法实现method_getImplementation(原selector的method实现)</li><li><p>替换子类的原selector实现为aspect_getMsgForwardIMP(self, selector)</p></li><li><p>aspect_getMsgForwardIMP 作用<br>返回IMP,用于当消息转发的时候use forwardInvocation to hook</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> IMP aspect_getMsgForwardIMP(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector) &#123;</span><br><span class="line">    IMP msgForwardIMP = _objc_msgForward;</span><br><span class="line"><span class="meta">#if !defined(__arm64__)</span></span><br><span class="line"></span><br><span class="line">    Method method = class_getInstanceMethod(<span class="keyword">self</span>.class, selector);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *encoding = method_getTypeEncoding(method);</span><br><span class="line">    <span class="built_in">BOOL</span> methodReturnsStructValue = encoding[<span class="number">0</span>] == _C_STRUCT_B;</span><br><span class="line">    <span class="keyword">if</span> (methodReturnsStructValue) &#123;</span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            <span class="built_in">NSUInteger</span> valueSize = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">NSGetSizeAndAlignment</span>(encoding, &amp;valueSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (valueSize == <span class="number">1</span> || valueSize == <span class="number">2</span> || valueSize == <span class="number">4</span> || valueSize == <span class="number">8</span>) &#123;</span><br><span class="line">                methodReturnsStructValue = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">@catch</span> (__unused <span class="built_in">NSException</span> *e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (methodReturnsStructValue) &#123;</span><br><span class="line">        msgForwardIMP = (IMP)_objc_msgForward_stret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">return</span> msgForwardIMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>至此，准备工作已经结束，下面进行调试工作<br>当点击按钮的时候，查看到左边的函数调用栈，消息转发进入<strong>ASPECTS_ARE_BEING_CALLED</strong>这里是关键<br>之前说过，当前class已经被修改isa为子类，子类的selector方法被hook了IMP，消息进入转发流程<br><img src="/images/Aspects_hook原selector.png" alt="hook原selector"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the swizzled forwardInvocation: method.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ASPECTS_ARE_BEING_CALLED__(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSInvocation</span> *invocation) &#123;</span><br><span class="line">    ...</span><br><span class="line">    SEL originalSelector = invocation.selector;</span><br><span class="line">  SEL aliasSelector = aspect_aliasForSelector(invocation.selector);</span><br><span class="line">    invocation.selector = aliasSelector;</span><br><span class="line">    AspectsContainer *objectContainer = objc_getAssociatedObject(<span class="keyword">self</span>, aliasSelector);</span><br><span class="line">    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(<span class="keyword">self</span>), aliasSelector);</span><br><span class="line">    AspectInfo *info = [[AspectInfo alloc] initWithInstance:<span class="keyword">self</span> invocation:invocation];</span><br><span class="line">    <span class="built_in">NSArray</span> *aspectsToRemove = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before hooks.</span></span><br><span class="line">    aspect_invoke(classContainer.beforeAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.beforeAspects, info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类执行 aliasSelector ，也就是原selector对应的method</span></span><br><span class="line">    <span class="comment">// Instead hooks.</span></span><br><span class="line">    <span class="built_in">BOOL</span> respondsToAlias = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123;</span><br><span class="line">        aspect_invoke(classContainer.insteadAspects, info);</span><br><span class="line">        aspect_invoke(objectContainer.insteadAspects, info);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        Class klass = object_getClass(invocation.target);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123;</span><br><span class="line">                [invocation invoke];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行block的方法</span></span><br><span class="line">    <span class="comment">// After hooks.</span></span><br><span class="line">    aspect_invoke(classContainer.afterAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.afterAspects, info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有实现alias方法，执行原来的selector</span></span><br><span class="line">    <span class="keyword">if</span> (!respondsToAlias) &#123;</span><br><span class="line">        invocation.selector = originalSelector;</span><br><span class="line">        SEL originalForwardInvocationSEL = <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName);</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:originalForwardInvocationSEL]) &#123;</span><br><span class="line">            ((<span class="keyword">void</span>( *)(<span class="keyword">id</span>, SEL, <span class="built_in">NSInvocation</span> *))objc_msgSend)(<span class="keyword">self</span>, originalForwardInvocationSEL, invocation);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span> doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove any hooks that are queued for deregistration.</span></span><br><span class="line">    [aspectsToRemove makeObjectsPerformSelector:<span class="keyword">@selector</span>(remove)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏aspect_invoke<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#define aspect_invoke(aspects, info) \</span><br><span class="line">for (AspectIdentifier *aspect in aspects) &#123;\</span><br><span class="line">    [aspect invokeWithInfo:info];\</span><br><span class="line">    if (aspect.options &amp; AspectOptionAutomaticRemoval) &#123; \</span><br><span class="line">        aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用AspectIdentifier的实例方法</span><br><span class="line">- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info &#123;</span><br><span class="line">    NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:self.blockSignature];</span><br><span class="line">    NSInvocation *originalInvocation = info.originalInvocation;</span><br><span class="line">    NSUInteger numberOfArguments = self.blockSignature.numberOfArguments;</span><br><span class="line"></span><br><span class="line">    // Be extra paranoid. We already check that on hook registration.</span><br><span class="line">    if (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123;</span><br><span class="line">        AspectLogError(@&quot;Block has too many arguments. Not calling %@&quot;, info);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The `self` of the block will be the AspectInfo. Optional.</span><br><span class="line">    if (numberOfArguments &gt; 1) &#123;</span><br><span class="line">        [blockInvocation setArgument:&amp;info atIndex:1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  void *argBuf = NULL;</span><br><span class="line">    for (NSUInteger idx = 2; idx &lt; numberOfArguments; idx++) &#123;</span><br><span class="line">        const char *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">NSUInteger argSize;</span><br><span class="line">NSGetSizeAndAlignment(type, &amp;argSize, NULL);</span><br><span class="line"></span><br><span class="line">if (!(argBuf = reallocf(argBuf, argSize))) &#123;</span><br><span class="line">            AspectLogError(@&quot;Failed to allocate memory for block invocation.&quot;);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[originalInvocation getArgument:argBuf atIndex:idx];</span><br><span class="line">[blockInvocation setArgument:argBuf atIndex:idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [blockInvocation invokeWithTarget:self.block]; //执行blockInvocation</span><br><span class="line"></span><br><span class="line">    if (argBuf != NULL) &#123;</span><br><span class="line">        free(argBuf);</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此流程调用分析结束</p><h2 id="Aspects原理"><a href="#Aspects原理" class="headerlink" title="Aspects原理"></a>Aspects原理</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    IMP imp = class_getMethodImplementation(<span class="keyword">self</span>-&gt;isa, SEL op);</span><br><span class="line">    imp(<span class="keyword">self</span>, op, ...); <span class="comment">//调用这个函数，伪代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找IMP</span></span><br><span class="line">IMP class_getMethodImplementation(Class cls, SEL sel) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls || !sel) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (!imp) <span class="keyword">return</span> _objc_msgForward; <span class="comment">//_objc_msgForward 用于消息转发</span></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息的发送最终走到objc_msgSend<br>消息转发流程图:<br><img src="/images/Aspects_SEL invoke流程图.png" alt="Aspects_SEL invoke流程图"></p><p>Aspects 正是利用其中最灵活的forwardInvocation进行封装的<br>对于待 hook 的 selector，将其指向 objc_msgForward /objc_msgForward_stret ,<br>同时生成一个新的 aliasSelector 指向原来的 IMP，<br>并且 hook 住 forwardInvocation 函数，使他指向自己的实现。按照上面的思路，当被 hook 的 selector 被执行的时候，首先根据 selector 找到了 objc_msgForward /objc_msgForward_stret ,而这个会触发消息转发，从而进入 forwardInvocation。同时由于 forwardInvocation 的指向也被修改了，因此会转入新的 forwardInvocation 函数，在里面执行需要嵌入的附加代码，完成之后，再转回原来的 IMP。</p><h2 id="Aspects-执行流程"><a href="#Aspects-执行流程" class="headerlink" title="Aspects 执行流程"></a>Aspects 执行流程</h2><p>这里以实例对象为例,运行官方demo,对象方法的hook，首先需要先添加待hook的方法，aspect_add<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) &#123;</span><br><span class="line">    ...</span><br><span class="line">    __block AspectIdentifier *identifier = nil;</span><br><span class="line">    aspect_performLocked(^&#123;</span><br><span class="line">        if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) &#123;//1判断能否hook</span><br><span class="line">            ... //2 记录数据结构</span><br><span class="line">            aspect_prepareClassAndHookSelector(self, selector, error);//3 swizzling</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>aspect_isSelectorAllowedAndTrack判断方法能否被hook,对于forwardInvocation、dealloc等方法在黑名单之中</li><li>对于元类，需要保证类的方法只在继承链中被hook一次,,先从当前类开始查找方法是否已经被hook,否则从父类中查找,找到了说明能被hook且被hook过一次</li><li><p>以下源码 从当前类开始，添加所有继承链上的AspectTracker的selectorNames或者subclassTracker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AspectTracker *tracker = nil;</span><br><span class="line">AspectTracker *subclassTracker = nil;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">       tracker = swizzledClassesDict[currentClass];</span><br><span class="line">       if (!tracker) &#123;</span><br><span class="line">           tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass]; //初始化</span><br><span class="line">           swizzledClassesDict[(id&lt;NSCopying&gt;)currentClass] = tracker; //赋值操作</span><br><span class="line">      &#125;</span><br><span class="line">      if (subclassTracker) &#123;</span><br><span class="line">           [tracker addSubclassTracker:subclassTracker hookingSelectorName:selectorName];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">           [tracker.selectorNames addObject:selectorName];</span><br><span class="line">      &#125;</span><br><span class="line">      // All superclasses get marked as having a subclass that is modified.</span><br><span class="line">      subclassTracker = tracker;</span><br><span class="line">&#125;while ((currentClass = class_getSuperclass(currentClass)));</span><br></pre></td></tr></table></figure></li><li><p>aspect_prepareClassAndHookSelector 最重要的就是hook ForwardInvocation方法<br>刚注册子类的时候，子类没有forwardInvocation方法，aspect_swizzleForwardInvocation内class_addMethod不会执行，所以不会生成  NSSelectorFromString(AspectsForwardInvocationSelectorName)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void aspect_swizzleForwardInvocation(Class klass) &#123;</span><br><span class="line">    NSCParameterAssert(klass);</span><br><span class="line">    // If there is no method, replace will act like class_addMethod.</span><br><span class="line">    IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, &quot;v@:@&quot;);</span><br><span class="line">    if (originalImplementation) &#123;</span><br><span class="line">        class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, &quot;v@:@&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    AspectLog(@&quot;Aspects: %@ is now aspect aware.&quot;, NSStringFromClass(klass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>aspect_hookClass之后，添加aliasSelector，方法指向原selector的实现，原selector指向转发IMP</p></li><li>方法转发<strong>ASPECTS_ARE_BEING_CALLED</strong> 最终执行到这个方法,依次处理before/instead/after逻辑以及调用原来的逻辑，如果不存在hook方法，能响应原始函数则执行原始函数，否则报错</li></ul><h2 id="加深了解"><a href="#加深了解" class="headerlink" title="加深了解"></a>加深了解</h2><ul><li>block转化为NSInvocation<br>消息转发的时候，需要调用NSInvocation,hook的时候缓存的是block,因此需要将block转化为NSInvocation，<br>AspectIdentifier 内含有NSMethodSignature  <code>*blockSignature,包括执行 block 所需要用到的具体信息如方法签名、参数等</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static NSMethodSignature *aspect_blockMethodSignature(id block, NSError **error) &#123;</span><br><span class="line">    AspectBlockRef layout = (__bridge void *)block;</span><br><span class="line">if (!(layout-&gt;flags &amp; AspectBlockFlagsHasSignature)) &#123;</span><br><span class="line">        NSString *description = [NSString stringWithFormat:@&quot;The block %@ doesn&apos;t contain a type signature.&quot;, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">void *desc = layout-&gt;descriptor;</span><br><span class="line">desc += 2 * sizeof(unsigned long int);</span><br><span class="line">if (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) &#123;</span><br><span class="line">desc += 2 * sizeof(void *);</span><br><span class="line">    &#125;</span><br><span class="line">if (!desc) &#123;</span><br><span class="line">        NSString *description = [NSString stringWithFormat:@&quot;The block %@ doesn&apos;t has a type signature.&quot;, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">const char *signature = (*(const char **)desc);</span><br><span class="line">return [NSMethodSignature signatureWithObjCTypes:signature];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>NSInvocation的创建, 需要signature, argument.<br>signature可以从block中转换过来, 而参数则可以从原来的AspectInfo对象中取出来做转换<br>从Block获得编码的Signature，可以转化为方法签名<br>在源码block签名方法中打上断点，可以查看block具体结构体<br><img src="/images/Aspects_block_signature.png" alt="Aspects_block_signature"></p><p><code>void *desc = layout-&gt;descriptor</code> 这个指针就是用于获取block的签名, 根据clang的源码, 签名位于descriptor结构体的第三个变量, 所以将指针移动两个单位.<br>flag用于判断block的具体类型BLOCK_HAS_COPY_DISPOSE, 代表这个block是否有捕获外部参数, 如果有捕获则descriptor中会多插入两个变量, 所以需要将desc指针再移动两个单位</p></li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>以下code实践将block转化为NSInvocation执行<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_literal_1 &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa; <span class="comment">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor_1 &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;         <span class="comment">// NULL</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;         <span class="comment">// sizeof(struct Block_literal_1)</span></span><br><span class="line">        <span class="comment">// optional helper functions</span></span><br><span class="line">        <span class="keyword">void</span> (*copy_helper)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);     <span class="comment">// IFF (1&lt;&lt;25)</span></span><br><span class="line">        <span class="keyword">void</span> (*dispose_helper)(<span class="keyword">void</span> *src);             <span class="comment">// IFF (1&lt;&lt;25)</span></span><br><span class="line">        <span class="comment">// required ABI.2010.3.16</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *signature;                         <span class="comment">// IFF (1&lt;&lt;30)</span></span><br><span class="line">    &#125; *descriptor;</span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMethodSignature</span> *blockSignature(<span class="keyword">id</span> blockObj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> Block_literal_1 *block = (__bridge <span class="keyword">void</span> *)blockObj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> signatureFlag = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    assert(block-&gt;flags &amp; signatureFlag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *desc = block-&gt;descriptor;</span><br><span class="line">    desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>); <span class="comment">//signature</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> copyDisposeFlag = <span class="number">1</span> &lt;&lt; <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">if</span> (block-&gt;flags &amp; copyDisposeFlag) &#123;</span><br><span class="line">        desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *signature = (*(<span class="keyword">const</span> <span class="keyword">char</span> **)desc);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:signature];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testBlockInvocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span>* (^myblock) (<span class="built_in">NSString</span>* , <span class="built_in">NSString</span>* ) = ^(<span class="built_in">NSString</span>* a, <span class="built_in">NSString</span>* b)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"a:%@,b:%@"</span>,a,b);</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"a:%@,b:%@"</span>,a,b];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *result = myblock(<span class="string">@"Tom"</span>,<span class="string">@"Jerry"</span>);</span><br><span class="line">    <span class="built_in">XCTAssertTrue</span>([result isEqualToString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"a:Tom,b:Jerry"</span>]], <span class="string">@"result Must be a:Tom,b:Jerry"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *sig = blockSignature(myblock);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:sig];</span><br><span class="line">    invocation.target = myblock;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *args = @[<span class="string">@"Patty"</span>,<span class="string">@"Cat"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; args.count ; ++i)&#123;</span><br><span class="line">        <span class="built_in">NSString</span> *object = args[i];</span><br><span class="line">        [invocation setArgument:&amp;object atIndex:i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    [invocation setTarget:myblock];</span><br><span class="line">    [invocation invoke];</span><br><span class="line">    <span class="comment">// 获取返回值</span></span><br><span class="line">    <span class="keyword">id</span> returnValue = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (sig.methodReturnLength) &#123;</span><br><span class="line">        <span class="comment">//获取返回值</span></span><br><span class="line">        [invocation getReturnValue:&amp;returnValue];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取返回值的类型</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *returnType = [sig methodReturnType];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"返回值的类型 %s"</span>,returnType);</span><br><span class="line">    <span class="built_in">XCTAssertTrue</span>([returnValue isEqualToString:<span class="string">@"a:Patty,b:Cat"</span>], <span class="string">@"result Must be a:Patty,b:Cat"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果如下<br>a:Tom,b:Jerry<br>a:Patty,b:Cat<br>返回值的类型 @”NSString”</p><ul><li>注意NSInvocation的返回值<br>首先当被调用函数是以new，copy,mutableCopy和alloc开头的特殊函数时，函数返回的的对象持有引用计数，所以我们设置returnValue的类型是__strong，这样在这个returnValue的作用域结束时，会进行release，内存处理正常。</li></ul><p>当被调用函数是普通函数时，函数内部最后执行了autorelease导致引用计数为0时。所以我们一定要设置returnValue的类型为<br><code>__autoreleasing id returnValue;</code><br>因为如果设置为__strong，则会在returnValue的作用域结束时，对这个引用计数为0的对象再进行一次release，导致内存问题。</p><h2 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h2><ul><li>respondsToSelector<br>之前小组分析讨论的时候，存在疑点，现在贴出来研究下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (![self respondsToSelector:selector] &amp;&amp; ![self.class instancesRespondToSelector:selector]) &#123;</span><br><span class="line">    NSString *errorDesc = [NSString stringWithFormat:@&quot;Unable to find selector -[%@ %@].&quot;, NSStringFromClass(self.class), selectorName];</span><br><span class="line">    AspectError(AspectErrorDoesNotRespondToSelector, errorDesc);</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>此处<code>[self respondsToSelector:selector]</code> 和 <code>[self.class instancesRespondToSelector:selector]</code><br>一时没有搞清楚为什么需要写两遍，两者在什么情况下才会不一样</p><p>respondsToSelector : 调用者可以是类(实例)，用来判断是否包含类方法(实例方法)</p><p>instancesRespondToSelector: 调用者必须是类，用来判断该类的实例是否包含实例方法</p><p>此处当self是实例情况下，两者是一样的<br>当self是类，就不一样了</p><ul><li>objc_msgForward 和 objc_msgForward_stret</li></ul><p>在Aspects.m的方法<code>aspect_getMsgForwardIMP</code>内部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> IMP msgForwardIMP = _objc_msgForward;</span><br><span class="line"> ...</span><br><span class="line"> Method method = class_getInstanceMethod(self.class, selector);</span><br><span class="line"> const char *encoding = method_getTypeEncoding(method);</span><br><span class="line"> BOOL methodReturnsStructValue = encoding[0] == _C_STRUCT_B;</span><br><span class="line"> ...</span><br><span class="line"> if (methodReturnsStructValue) &#123;</span><br><span class="line">      msgForwardIMP = (IMP)_objc_msgForward_stret;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>此处是获取方法对应的IMP的类型<br>可见，当方法返回值是结构体类型，对应的IMP是<code>_objc_msgForward_stret</code><br>当方法返回值是普通的数据类型或者对象等，是<code>_objc_msgForward</code></p><h2 id="阅读链接"><a href="#阅读链接" class="headerlink" title="阅读链接"></a>阅读链接</h2><p><a href="https://wereadteam.github.io/2016/06/30/Aspects/" target="_blank" rel="noopener">https://wereadteam.github.io/2016/06/30/Aspects/</a><br><a href="http://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="noopener">http://clang.llvm.org/docs/Block-ABI-Apple.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文源码解析来自官方1.4.2版本&lt;/p&gt;
&lt;h2 id=&quot;AspectInfo&quot;&gt;&lt;a href=&quot;#AspectInfo&quot; class=&quot;headerlink&quot; title=&quot;AspectInfo&quot;&gt;&lt;/a&gt;AspectInfo&lt;/h2&gt;&lt;figure class=&quot;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Objc-autoreleasePool</title>
    <link href="https://pattyxp.github.io/2018/02/13/Objc-autoreleasePool/"/>
    <id>https://pattyxp.github.io/2018/02/13/Objc-autoreleasePool/</id>
    <published>2018-02-13T02:55:28.000Z</published>
    <updated>2018-05-18T09:29:06.441Z</updated>
    
    <content type="html"><![CDATA[<p>本篇开始学习OC的内存管理，先来说说autoreleasepool相关的原理<br>一般来说，线程和autoreleasepool是对应存在的，主线程，默认含有自动释放池</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        for (int i=0; i&lt;100; i++) &#123;</span><br><span class="line">            @autoreleasepool&#123;</span><br><span class="line">                SampleClass *sample = [[SampleClass alloc] init];</span><br><span class="line">                [sample startAction];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的for循环内，断点执行，可以看到方法执行函数调用栈<br><img src="/images/autoreleasepool1.png" alt="函数调用栈"></p><p>@autoreleasepool 通过反编译之后得到的是<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line"><span class="comment">// do whatever you want</span></span><br><span class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br></pre></td></tr></table></figure></p><h2 id="push操作"><a href="#push操作" class="headerlink" title="push操作"></a>push操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#   define POOL_BOUNDARY nil  （哨兵对象）</span><br><span class="line"></span><br><span class="line">void *</span><br><span class="line">objc_autoreleasePoolPush(void)</span><br><span class="line">&#123;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void *push()</span><br><span class="line">   &#123;</span><br><span class="line">       id *dest;</span><br><span class="line">       if (DebugPoolAllocation) &#123;</span><br><span class="line">           // Each autorelease pool starts on a new pool page.</span><br><span class="line">           dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           dest = autoreleaseFast(POOL_BOUNDARY); //执行</span><br><span class="line">       &#125;</span><br><span class="line">       assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">       return dest;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //在每个autoreleasepool初始化的时候，都会先放入一个哨兵对象</span><br><span class="line">   static inline id *autoreleaseFast(id obj)</span><br><span class="line">   &#123;</span><br><span class="line">       AutoreleasePoolPage *page = hotPage();</span><br><span class="line">       if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">           return page-&gt;add(obj);</span><br><span class="line">       &#125; else if (page) &#123;</span><br><span class="line">           return autoreleaseFullPage(obj, page);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return autoreleaseNoPage(obj);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>一般所指的hot page ，即最新添加的 autoreleased 对象所在的那个 page</li></ul><p>autoreleaseFast 函数的作用可以分为三种情况</p><ul><li>判断当前是否存在page，存在<ul><li>page存储满,autoreleaseFullPage初始化新的页</li><li>page有空间，page-&gt;add(obj)</li></ul></li><li>不存在page，创建 autoreleaseNoPage创建一个hotPage<br>最后的都会调用 page-&gt;add(obj) 将对象添加到自动释放池中。</li></ul><h2 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h2><p>autoreleasepool 没有单独的内存结构，它是以autoreleasepoolPage为结点的双向链表来实现的<br>每个自动释放池，都是由一系列的autoreleasepoolPage组成的，每个autoreleasepoolPage大小都是4096字节<br>其中有 56 bit 用于存储 AutoreleasePoolPage 的成员变量，剩下的都是用来存储加入到自动释放池中的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage</span><br><span class="line">&#123;</span><br><span class="line">    static pthread_key_t const key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    static uint8_t const SCRIBBLE = 0xA3;  // 0xA3A3A3A3 after releasing</span><br><span class="line">    static size_t const SIZE = PAGE_MAX_SIZE;  // size and alignment, power of 2</span><br><span class="line">    static size_t const COUNT = SIZE / sizeof(id);</span><br><span class="line">    ...</span><br><span class="line">    magic_t const magic;</span><br><span class="line">    id *next;</span><br><span class="line">    pthread_t const thread;</span><br><span class="line">    AutoreleasePoolPage * const parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    uint32_t const depth;</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><p>下面是空AutoreleasePoolPage的内存结构图:<br><img src="/images/空AutoreleasePoolPage.png" alt="空AutoreleasePoolPage"></p><ul><li>magic 用来校验 AutoreleasePoolPage 的结构是否完整；</li><li>next 指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 begin() ；<br>thread 指向当前线程；</li><li>parent 指向父结点，第一个结点的 parent 值为 nil ；</li><li>child 指向子结点，最后一个结点的 child 值为 nil ；</li><li>depth 代表深度，从 0 开始，往后递增 1；</li><li>hiwat 代表 high water mark 。</li><li>当 next == begin() 时，表示 AutoreleasePoolPage 为空；</li><li>当 next == end() 时，表示 AutoreleasePoolPage 已满。</li></ul><p>根据断点调试，进入 page-&gt;add(obj)</p><ul><li>将当前page的next指针处存入obj对象，next指针指向下一个位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id *add(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!full());</span><br><span class="line">    unprotect();</span><br><span class="line">    id *ret = next;  // faster than `return next-1` because of aliasing</span><br><span class="line">    *next++ = obj;</span><br><span class="line">    protect();</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>可见push方法返回的结果是哨兵对象（插入对象之前next指针）的地址</p><h2 id="Pop操作"><a href="#Pop操作" class="headerlink" title="Pop操作"></a>Pop操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void pop(void *token)</span><br><span class="line">   &#123;</span><br><span class="line">       AutoreleasePoolPage *page;</span><br><span class="line">       id *stop;</span><br><span class="line"></span><br><span class="line">       if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">          ...</span><br><span class="line">          setHotPage(nil);</span><br><span class="line">          ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       page = pageForPointer(token); //取出对应的page 通过对4096取模</span><br><span class="line">       stop = (id *)token;</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       page-&gt;releaseUntil(stop); //释放token之后所有的对象</span><br><span class="line"></span><br><span class="line">       // memory: delete empty children</span><br><span class="line">       if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">           // special case: delete everything during page-per-pool debugging</span><br><span class="line">           AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">           page-&gt;kill();</span><br><span class="line">           setHotPage(parent);</span><br><span class="line">       &#125; else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">           // special case: delete everything for pop(top)</span><br><span class="line">           // when debugging missing autorelease pools</span><br><span class="line">           page-&gt;kill();</span><br><span class="line">           setHotPage(nil);</span><br><span class="line">       &#125;</span><br><span class="line">       else if (page-&gt;child) &#123;</span><br><span class="line">           // hysteresis: keep one empty child if page is more than half full</span><br><span class="line">           if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">               page-&gt;child-&gt;kill();</span><br><span class="line">           &#125;</span><br><span class="line">           else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">               page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void releaseUntil(id *stop)</span><br><span class="line">   &#123;</span><br><span class="line">     while (this-&gt;next != stop) &#123;</span><br><span class="line"></span><br><span class="line">           AutoreleasePoolPage *page = hotPage();</span><br><span class="line"></span><br><span class="line">           while (page-&gt;empty()) &#123;</span><br><span class="line">               page = page-&gt;parent;</span><br><span class="line">               setHotPage(page);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           page-&gt;unprotect();</span><br><span class="line">           id obj = *--page-&gt;next; //取出next指向的内容</span><br><span class="line">           memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));//将next区域清为0xA3</span><br><span class="line">           page-&gt;protect();</span><br><span class="line"></span><br><span class="line">           if (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">               objc_release(obj); //释放obj对象</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       setHotPage(this);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过循环遍历当前page以及父page，<br>内存地址在 stop 之后的所有 autoreleased 对象都会被 release ,直到 stop 所在 page 的 next 指向 stop 为止。</p><h2 id="autorelease操作"><a href="#autorelease操作" class="headerlink" title="autorelease操作"></a>autorelease操作</h2><p>通过 NSObject.mm 源文件，找到以下方法的实现</p><ul><li>(id)autorelease {<br>  return ((id)self)-&gt;rootAutorelease();<br>}<br>通过查看 ((id)self)-&gt;rootAutorelease() 的方法调用，我们发现最终调用的就是 AutoreleasePoolPage 的 autorelease 函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">inline id objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;</span><br><span class="line"></span><br><span class="line">    return rootAutorelease2();</span><br><span class="line">&#125;</span><br><span class="line">id objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line">    return AutoreleasePoolPage::autorelease((id)this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/对象release堆栈图.png" alt="对象release堆栈图"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static inline id autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line">    assert(!obj-&gt;isTaggedPointer());</span><br><span class="line">    id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    assert(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到autorelease操作和push非常相似<br>push插入的是POOL_BOUNDARY 即nil<br>autorelease插入具体需要释放的对象</p><h2 id="release-操作"><a href="#release-操作" class="headerlink" title="release 操作"></a>release 操作</h2><p>源码来啦<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>)release &#123;</span><br><span class="line">    ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRelease();</span><br><span class="line">&#125;</span><br><span class="line">objc_object::rootRelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRelease(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终是对obj的retainCount执行减1操作，如果obj的retainCount为0，直接dealloc</p><p>在isa篇其实知道，OC对象都有isa 表示其所属的类，isa_t结构体中有两个字段表示对象的引用计数<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  isa_t() &#123; &#125;</span><br><span class="line">  isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  Class cls;</span><br><span class="line">  uintptr_t bits;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">    uintptr_t nonpointer        : <span class="number">1</span>;</span><br><span class="line">    uintptr_t has_assoc         : <span class="number">1</span>;</span><br><span class="line">    uintptr_t has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">    uintptr_t shiftcls          : <span class="number">44</span>; </span><br><span class="line">    uintptr_t magic             : <span class="number">6</span>;</span><br><span class="line">    uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">    uintptr_t deallocating      : <span class="number">1</span>;  </span><br><span class="line">    uintptr_t has_sidetable_rc  : <span class="number">1</span>; <span class="comment">// 相关</span></span><br><span class="line">    uintptr_t extra_rc          : <span class="number">8</span>; <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>has_sidetable_rc</code>和<code>extra_rc</code>用来表示引用计数相关<br>在上面的<code>rootRelease</code>方法用到了相关方面<br>当对象的引用计数超过了<code>extra_rc</code>能存储的位数，需要将<code>has_sidetable_rc</code>置为1，同时剩下的引用计数存在sideTable相关的表中，此处可以看下对象的存储retain相关，就知道为什么了<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">id</span> </span><br><span class="line">objc_object::<span class="keyword">retain</span>()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123; <span class="comment">//如果没有自定义retain方法</span></span><br><span class="line">        <span class="keyword">return</span> rootRetain();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_retain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终调用以下方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">objc_object::rootRetain(<span class="keyword">bool</span> tryRetain, <span class="keyword">bool</span> handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>; <span class="comment">//如果优化 ，直接return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits); <span class="comment">//取出对象的isa</span></span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123; </span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">if</span> (tryRetain) <span class="keyword">return</span> sidetable_tryRetain() ? (<span class="keyword">id</span>)<span class="keyword">this</span> : <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> sidetable_retain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don't check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++  此处执行extra_rc+1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123; <span class="comment">//如果溢出，说明需要进行另存</span></span><br><span class="line">            <span class="comment">// newisa.extra_rc++ overflowed</span></span><br><span class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                <span class="keyword">return</span> rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Leave half of the retain counts inline and </span></span><br><span class="line">            <span class="comment">// prepare to copy the other half to the side table. //另一半存到sidetable</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            transcribeToSideTable = <span class="literal">true</span>;</span><br><span class="line">            newisa.extra_rc = RC_HALF;  <span class="comment">//extra_rc保留一半</span></span><br><span class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>; <span class="comment">//has_sidetable_rc置为1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        <span class="comment">// Copy the other half of the retain counts to the side table.</span></span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>retain流程如上，所以release操作也需要类似操作，此处就省略代码了</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p><code>void *memset(void *s, int ch, size_t n);</code><br>函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。<br><code>memset</code>：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看到这里，对autoreleasePool已经有了基本的认识原理，了解push和pop操作，对象的autorelease和release</p><h2 id="顺便一提"><a href="#顺便一提" class="headerlink" title="顺便一提"></a>顺便一提</h2><p>接触了Hopper Disassembler之后，反编译二进制代码得到伪代码非常方便可以观察<br>前提是先获取到二进制可执行文件，可以通过xcode编译得到，也可以通过clang的命令获取</p><ul><li>通过xcode编译文件<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Pig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Pig</span>()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Pig</span></span></span><br><span class="line">- (<span class="keyword">void</span>)getPig</span><br><span class="line">&#123;</span><br><span class="line">    Pig *pig = [[Pig alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">- (Pig *)getPig1</span><br><span class="line">&#123;</span><br><span class="line">    Pig *pig = [[Pig alloc] init];</span><br><span class="line">    <span class="keyword">return</span> pig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>将可执行文件拖进Hopper，得到Pig的两个方法的反编译代码<br><img src="/images/autoreleasepool_pig.png" alt="autoreleasepool_pig"><br><img src="/images/autoreleasepool_pig1.png" alt="autoreleasepool_pig1"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void -[Pig getPig](void * self, void * _cmd) &#123;</span><br><span class="line">    rdi = var_18;</span><br><span class="line">    [[Pig alloc] init];</span><br><span class="line">    objc_storeStrong(rdi, 0x0);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void * -[Pig getPig1](void * self, void * _cmd) &#123;</span><br><span class="line">    var_18 = [[Pig alloc] init];</span><br><span class="line">    var_28 = [var_18 retain];</span><br><span class="line">    objc_storeStrong(var_18, 0x0);</span><br><span class="line">    rax = [var_28 autorelease];</span><br><span class="line">    return rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是ARC下系统对autorelease的返回值优化策略</p><ul><li>objc_storeStrong源码<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_storeStrong(<span class="keyword">id</span> *location, <span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> prev = *location;</span><br><span class="line">    <span class="keyword">if</span> (obj == prev) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    objc_retain(obj);</span><br><span class="line">    *location = obj;</span><br><span class="line">    objc_release(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>赋值strong类型的属性的时候会调用<code>objc_storeStrong</code><br>copy,weak等都不会调用<br>第一个入参，有值的<br>第二个入参，赋值的时候有值，也有存在ox0的情况<br>1.当init方法时候给成员赋值，obj有值，当init方法return的时候，obj为ox0<br>2.当dealloc对象的时候，obj为ox0情况居多<br>总结:在__strong类型的变量的作用域结束时，自动添加release函数进行释放。</p><p>打印类地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p (objc_class *)[Pig class]</span><br></pre></td></tr></table></figure></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">http://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇开始学习OC的内存管理，先来说说autoreleasepool相关的原理&lt;br&gt;一般来说，线程和autoreleasepool是对应存在的，主线程，默认含有自动释放池&lt;/p&gt;
&lt;h2 id=&quot;源码解析&quot;&gt;&lt;a href=&quot;#源码解析&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Objc" scheme="https://pattyxp.github.io/tags/Objc/"/>
    
  </entry>
  
  <entry>
    <title>Objc-protocol篇</title>
    <link href="https://pattyxp.github.io/2018/02/12/Objc-protocol%E7%AF%87/"/>
    <id>https://pattyxp.github.io/2018/02/12/Objc-protocol篇/</id>
    <published>2018-02-12T03:28:59.000Z</published>
    <updated>2018-05-23T05:57:33.970Z</updated>
    
    <content type="html"><![CDATA[<p>本篇研究以下问题</p><ul><li>Protocol的实践</li></ul><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@protocol DogProtocol</span><br><span class="line">@required</span><br><span class="line">- (void)printName;</span><br><span class="line">@optional</span><br><span class="line">- (void)printAge;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Dog: NSObject</span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@property (nonatomic) NSInteger age;</span><br><span class="line">@property (nonatomic, weak) id delegate;</span><br><span class="line">- (void)printDetails;</span><br><span class="line">@end</span><br><span class="line">@implementation Dog</span><br><span class="line">-(void)printDetails</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;I&apos;m Dog&quot;);</span><br><span class="line">    [self.delegate printName];</span><br><span class="line">    [self.delegate printAge];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface SampleClass:NSObject&lt;DogProtocol&gt;</span><br><span class="line">@property (nonatomic, strong) Dog *littleDog;</span><br><span class="line">- (void)startAction;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SampleClass</span><br><span class="line"></span><br><span class="line">- (void)startAction&#123;</span><br><span class="line">    Dog *dog = [[Dog alloc]init];</span><br><span class="line">    dog.name = @&quot;PattyDog&quot;;</span><br><span class="line">    dog.age = 10;</span><br><span class="line">    dog.delegate = self;</span><br><span class="line"></span><br><span class="line">    self.littleDog = dog;</span><br><span class="line">    [dog printDetails];</span><br><span class="line">&#125;</span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;name:%@&quot;,self.littleDog.name);</span><br><span class="line">&#125;</span><br><span class="line">- (void)printAge</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;age:%zd&quot;,self.littleDog.age);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark -main</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        SampleClass *sample = [[SampleClass alloc] init];</span><br><span class="line">        [sample startAction];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看控制台打印输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m Dog</span><br><span class="line">name:PattyDog</span><br><span class="line">age:10</span><br></pre></td></tr></table></figure></p><h2 id="protocol-t结构"><a href="#protocol-t结构" class="headerlink" title="protocol_t结构"></a>protocol_t结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct protocol_t : objc_object &#123;</span><br><span class="line">    const char *mangledName;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    method_list_t *instanceMethods;</span><br><span class="line">    method_list_t *classMethods;</span><br><span class="line">    method_list_t *optionalInstanceMethods;</span><br><span class="line">    method_list_t *optionalClassMethods;</span><br><span class="line">    property_list_t *instanceProperties;</span><br><span class="line">    uint32_t size;   // sizeof(protocol_t)</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    // Fields below this point are not always present on disk.</span><br><span class="line">    const char **_extendedMethodTypes;</span><br><span class="line">    const char *_demangledName;</span><br><span class="line">    property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    const char *demangledName();</span><br><span class="line"></span><br><span class="line">    const char *nameForLogging() &#123;</span><br><span class="line">        return demangledName();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分别申明-required和-optional方法"><a href="#分别申明-required和-optional方法" class="headerlink" title="分别申明@required和@optional方法"></a>分别申明@required和@optional方法</h2><p>下面打印验证协议方法<br>打印方法类似之前文章中介绍消息缓存<br>现在查看SampleClass遵循的协议</p><p><img src="/images/protocol_t.png" alt="protocol_t结构证明"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">2018-02-13 09:51:09.129854+0800 debug-objc[26530:1205183] 0x100002610</span><br><span class="line">(lldb) p (objc_class *)0x100002610</span><br><span class="line">(objc_class *) $0 = 0x0000000100002610</span><br><span class="line">(lldb) p (class_data_bits_t *)0x0000000100002630</span><br><span class="line">(class_data_bits_t *) $1 = 0x0000000100002630</span><br><span class="line">(lldb) p (class_rw_t *)$1-&gt;data()</span><br><span class="line">(class_rw_t *) $2 = 0x0000000100a21a80</span><br><span class="line">(lldb) p $2-&gt;protocols</span><br><span class="line">(protocol_array_t) $3 = &#123;</span><br><span class="line">  list_array_tt&lt;unsigned long, protocol_list_t&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = 0x0000000100002370</span><br><span class="line">      arrayAndFlag = 4294976368</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $3.beginLists()</span><br><span class="line">(protocol_list_t **) $4 = 0x0000000100a21aa0</span><br><span class="line">(lldb) p **$4</span><br><span class="line">(protocol_list_t) $5 = (count = 1, list = protocol_ref_t [] @ 0x00007fbc7e780c58)</span><br><span class="line">(lldb) p $5.list[0]</span><br><span class="line">(protocol_ref_t) $6 = 4294977080</span><br><span class="line">(lldb) p (protocol_t *)$6</span><br><span class="line">(protocol_t *) $7 = 0x0000000100002638</span><br><span class="line">(lldb) p *$7</span><br><span class="line">(protocol_t) $8 = &#123;</span><br><span class="line">  objc_object = &#123;</span><br><span class="line">    isa = &#123;</span><br><span class="line">      cls = Protocol</span><br><span class="line">      bits = 4302295240</span><br><span class="line">       = &#123;</span><br><span class="line">        nonpointer = 0</span><br><span class="line">        has_assoc = 0</span><br><span class="line">        has_cxx_dtor = 0</span><br><span class="line">        shiftcls = 537786905</span><br><span class="line">        magic = 0</span><br><span class="line">        weakly_referenced = 0</span><br><span class="line">        deallocating = 0</span><br><span class="line">        has_sidetable_rc = 0</span><br><span class="line">        extra_rc = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mangledName = 0x0000000100001f5e &quot;DogProtocol&quot;   //证明协议名称</span><br><span class="line">  protocols = 0x0000000000000000</span><br><span class="line">  instanceMethods = 0x0000000100002320</span><br><span class="line">  classMethods = 0x0000000000000000</span><br><span class="line">  optionalInstanceMethods = 0x0000000100002340</span><br><span class="line">  optionalClassMethods = 0x0000000000000000</span><br><span class="line">  instanceProperties = 0x0000000000000000</span><br><span class="line">  size = 96</span><br><span class="line">  flags = 0</span><br><span class="line">  _extendedMethodTypes = 0x0000000100002360</span><br><span class="line">  _demangledName = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  _classProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $8.instanceMethods  //打印实例方法</span><br><span class="line">(method_list_t *) $9 = 0x0000000100002320</span><br><span class="line">(lldb) p $9-&gt;get(0)</span><br><span class="line">(method_t) $10 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $11 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 1</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从打印记录可以看到，SampleClass 含有的协议是”DogProtocol”<br>协议含有的实例方法列表 只有required方法<br>如果将DogProtocol协议中的@optional申明注释，打印协议里面的实例方法</p><h2 id="required申明方法"><a href="#required申明方法" class="headerlink" title="required申明方法"></a>required申明方法</h2><p>可以看到协议的实例方法列表含有两个方法,分别是printName和printAge，都是@required申明的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *$7</span><br><span class="line">(protocol_t) $8 = &#123;</span><br><span class="line">  objc_object = &#123;</span><br><span class="line">    isa = &#123;</span><br><span class="line">      cls = Protocol</span><br><span class="line">      bits = 4302295240</span><br><span class="line">       = &#123;</span><br><span class="line">        nonpointer = 0</span><br><span class="line">        has_assoc = 0</span><br><span class="line">        has_cxx_dtor = 0</span><br><span class="line">        shiftcls = 537786905</span><br><span class="line">        magic = 0</span><br><span class="line">        weakly_referenced = 0</span><br><span class="line">        deallocating = 0</span><br><span class="line">        has_sidetable_rc = 0</span><br><span class="line">        extra_rc = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mangledName = 0x0000000100001f5e &quot;DogProtocol&quot;</span><br><span class="line">  protocols = 0x0000000000000000</span><br><span class="line">  instanceMethods = 0x0000000100002320</span><br><span class="line">  classMethods = 0x0000000000000000</span><br><span class="line">  optionalInstanceMethods = 0x0000000000000000</span><br><span class="line">  optionalClassMethods = 0x0000000000000000</span><br><span class="line">  instanceProperties = 0x0000000000000000</span><br><span class="line">  size = 96</span><br><span class="line">  flags = 0</span><br><span class="line">  _extendedMethodTypes = 0x0000000100002358</span><br><span class="line">  _demangledName = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  _classProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $8.instanceMethods()</span><br><span class="line">error: called object type &apos;method_list_t *&apos; is not a function or function pointer</span><br><span class="line">(lldb) p $8.instanceMethods</span><br><span class="line">(method_list_t *) $9 = 0x0000000100002320</span><br><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $10 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 2</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(0)</span><br><span class="line">(method_t) $11 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10-&gt;get(1)</span><br><span class="line">(method_t) $12 = &#123;</span><br><span class="line">  name = &quot;printAge&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="默认不申明"><a href="#默认不申明" class="headerlink" title="默认不申明"></a>默认不申明</h2><p>打印说明默认的就是required<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $10 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 2</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(0)</span><br><span class="line">(method_t) $11 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(1)</span><br><span class="line">(method_t) $12 = &#123;</span><br><span class="line">  name = &quot;printAge&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="将方法都申明为optional"><a href="#将方法都申明为optional" class="headerlink" title="将方法都申明为optional"></a>将方法都申明为optional</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@protocol DogProtocol</span><br><span class="line">@optional</span><br><span class="line">- (void)printName;</span><br><span class="line">- (void)printAge;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>打印,可以看到协议的实例方法为空，但是optionalInstanceMethods有两个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)0x100002608</span><br><span class="line">(objc_class *) $0 = 0x0000000100002608</span><br><span class="line">(lldb) p (class_data_bits_t *)0x0000000100002628</span><br><span class="line">(class_data_bits_t *) $1 = 0x0000000100002628</span><br><span class="line">(lldb) p (class_rw_t *)$1-&gt;data()</span><br><span class="line">(class_rw_t *) $2 = 0x0000000100b909a0</span><br><span class="line">(lldb) p $2-&gt;protocols</span><br><span class="line">(protocol_array_t) $3 = &#123;</span><br><span class="line">  list_array_tt&lt;unsigned long, protocol_list_t&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = 0x0000000100002368</span><br><span class="line">      arrayAndFlag = 4294976360</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $3.beginLists()</span><br><span class="line">(protocol_list_t **) $4 = 0x0000000100b909c0</span><br><span class="line">(lldb) p $5.list[0]</span><br><span class="line">error: use of undeclared identifier &apos;$5&apos;</span><br><span class="line">(lldb) p **$4</span><br><span class="line">(protocol_list_t) $5 = (count = 1, list = protocol_ref_t [] @ 0x00007fbc7e1dad48)</span><br><span class="line">(lldb) p $5.list[0]</span><br><span class="line">(protocol_ref_t) $6 = 4294977072</span><br><span class="line">(lldb) p (protocol_t *)$6</span><br><span class="line">(protocol_t *) $7 = 0x0000000100002630</span><br><span class="line">(lldb) p *$7</span><br><span class="line">(protocol_t) $8 = &#123;</span><br><span class="line">  objc_object = &#123;</span><br><span class="line">    isa = &#123;</span><br><span class="line">      cls = Protocol</span><br><span class="line">      bits = 4302295240</span><br><span class="line">       = &#123;</span><br><span class="line">        nonpointer = 0</span><br><span class="line">        has_assoc = 0</span><br><span class="line">        has_cxx_dtor = 0</span><br><span class="line">        shiftcls = 537786905</span><br><span class="line">        magic = 0</span><br><span class="line">        weakly_referenced = 0</span><br><span class="line">        deallocating = 0</span><br><span class="line">        has_sidetable_rc = 0</span><br><span class="line">        extra_rc = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mangledName = 0x0000000100001f5e &quot;DogProtocol&quot;</span><br><span class="line">  protocols = 0x0000000000000000</span><br><span class="line">  instanceMethods = 0x0000000000000000</span><br><span class="line">  classMethods = 0x0000000000000000</span><br><span class="line">  optionalInstanceMethods = 0x0000000100002320</span><br><span class="line">  optionalClassMethods = 0x0000000000000000</span><br><span class="line">  instanceProperties = 0x0000000000000000</span><br><span class="line">  size = 96</span><br><span class="line">  flags = 0</span><br><span class="line">  _extendedMethodTypes = 0x0000000100002358</span><br><span class="line">  _demangledName = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  _classProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $8.optionalInstanceMethods</span><br><span class="line">(method_list_t *) $9 = 0x0000000100002320</span><br><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $10 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 2</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(0)</span><br><span class="line">(method_t) $11 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(1)</span><br><span class="line">(method_t) $12 = &#123;</span><br><span class="line">  name = &quot;printAge&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇研究以下问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Protocol的实践&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h2&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
      <category term="Objc" scheme="https://pattyxp.github.io/tags/Objc/"/>
    
  </entry>
  
  <entry>
    <title>Objc category篇</title>
    <link href="https://pattyxp.github.io/2018/02/11/Objc-category%E7%AF%87/"/>
    <id>https://pattyxp.github.io/2018/02/11/Objc-category篇/</id>
    <published>2018-02-11T03:05:02.000Z</published>
    <updated>2018-05-18T09:29:16.496Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章中，分析load有提到对category中的load方法进行存储调用<br>现在我们来窥探一下category的作用</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>category主要用于动态的为类添加一些方法和属性<br>在OC中，catefory是在运行期决议的。当编译完成,对象的内存布局已经确定，我们无法为类添加实例变量，通过category,可以设置关联对象，为类动态添加属性,也可以添加方法</p><p>注:<br>extension它是在编译期，和类的.h和.m构成类的结构，可以添加实例变量，一般用于隐藏类的私有属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Category</span><br><span class="line">@interface PattyDog (Category)</span><br><span class="line">// 只会生成set,get方法的声明,创建的对象没有name属性.</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Extension(类扩展)</span><br><span class="line">@interface PattyDog</span><br><span class="line">// 创建name成员变量,并声明和实现set,get方法</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>在objc-runtime-new.h中,申明了category的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct category_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    struct method_list_t *instanceMethods;</span><br><span class="line">    struct method_list_t *classMethods;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    struct property_list_t *instanceProperties;</span><br><span class="line">    // Fields below this point are not always present on disk.</span><br><span class="line">    struct property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *methodsForMeta(bool isMeta) &#123;</span><br><span class="line">        if (isMeta) return classMethods;</span><br><span class="line">        else return instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>从上面可以了解到，category包含了</p><ul><li>类的名字</li><li>类</li><li>给类添加的  实例方法列表</li><li>给类添加的  类方法列表</li><li>给类添加的  协议列表</li><li>给类添加的  属性列表</li><li>给类添加的  类属性列表</li></ul><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Dog.h</span><br><span class="line">@interface Dog: NSObject</span><br><span class="line">- (void)printName;</span><br><span class="line">@end</span><br><span class="line">@interface Dog (Patty)</span><br><span class="line">@property(nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//Dog.m</span><br><span class="line">@implementation Dog</span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;CommonDog&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Dog(Patty)</span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;PattyDog&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>下面将Dog.m文件进行clang编译，看下编译之后有哪些改动，以下是主要的变化</p><ul><li>category_t 结构体含有实例方法_CATEGORY_INSTANCE_METHODS<em>Dog</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Dog_$_Patty,</span><br><span class="line"></span><br><span class="line">具体实现存储的方法只有一个，方法名称是printName，方法编码，函数地址都存储在里面</span><br><span class="line">__attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line"> sizeof(_objc_method),</span><br><span class="line"> 1,</span><br><span class="line"> &#123;&#123;(struct objc_selector *)&quot;printName&quot;, &quot;v16@0:8&quot;, (void *)_I_Dog_Patty_printName&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">static __NSConstantStringImpl __NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_0 __attribute__ ((section (&quot;__DATA, __cfstring&quot;))) = &#123;__CFConstantStringClassReference,0x000007c8,&quot;CommonDog&quot;,9&#125;;</span><br><span class="line">static __NSConstantStringImpl __NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_1 __attribute__ ((section (&quot;__DATA, __cfstring&quot;))) = &#123;__CFConstantStringClassReference,0x000007c8,&quot;PattyDog&quot;,8&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// @implementation Dog</span><br><span class="line"></span><br><span class="line">static void _I_Dog_printName(Dog * self, SEL _cmd) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_0);</span><br><span class="line">&#125;</span><br><span class="line">// @end</span><br><span class="line">// @implementation Dog(Patty)</span><br><span class="line"></span><br><span class="line">static void _I_Dog_Patty_printName(Dog * self, SEL _cmd) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_1);</span><br><span class="line">&#125;</span><br><span class="line">// @end</span><br><span class="line"></span><br><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Dog_$_Patty __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">1,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;printName&quot;, &quot;v16@0:8&quot;, (void *)_I_Dog_Patty_printName&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_Dog;</span><br><span class="line"></span><br><span class="line">static struct _category_t _OBJC_$_CATEGORY_Dog_$_Patty __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) =</span><br><span class="line">&#123;</span><br><span class="line">&quot;Dog&quot;,</span><br><span class="line">0, // &amp;OBJC_CLASS_$_Dog,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Dog_$_Patty,</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">&#125;;</span><br><span class="line">static void OBJC_CATEGORY_SETUP_$_Dog_$_Patty(void ) &#123;</span><br><span class="line">_OBJC_$_CATEGORY_Dog_$_Patty.cls = &amp;OBJC_CLASS_$_Dog;</span><br><span class="line">&#125;</span><br><span class="line">#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)</span><br><span class="line">__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">(void *)&amp;OBJC_CATEGORY_SETUP_$_Dog_$_Patty,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;OBJC_CLASS_$_Dog,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;_OBJC_$_CATEGORY_Dog_$_Patty,</span><br><span class="line">&#125;;</span><br><span class="line">static struct IMAGE_INFO &#123; unsigned version; unsigned flag; &#125; _OBJC_IMAGE_INFO = &#123; 0, 2 &#125;;</span><br></pre></td></tr></table></figure><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>category是由OC动态加载（runtime）,多个category的调用顺序是无法保证的，<br>一般来说category内的方法需要添加前缀可避免重复添加导致编译出错<br>OC的运行入口，在objc-os.mm内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized = false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized = true;</span><br><span class="line"></span><br><span class="line">    // fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_2_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过上面的方法，在map_2_images函数里面进入加载images,最终调用到_read_images方法</p><ul><li>获取OC的category列表catlist</li><li>然后remapClass</li><li>如果category含有实例方法，协议或者属性列表，添加到类上</li><li>如果category含有类方法列表，协议,添加到类的metaclass上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">// Discover categories.</span><br><span class="line">    for (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist =</span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);//从表中取出cat对应的cls</span><br><span class="line"></span><br><span class="line">            if (!cls) &#123;</span><br><span class="line">                // Category&apos;s target class is missing (probably weak-linked).</span><br><span class="line">                // Disavow any knowledge of this category.</span><br><span class="line">                catlist[i] = nil;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span><br><span class="line">                                 &quot;missing weak-linked target class&quot;,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bool classExists = NO;</span><br><span class="line">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties)</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                if (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,</span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name,</span><br><span class="line">                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                if (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,</span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>绑定category的方法、协议等映射到类上，内部调用方法addUnattachedCategoryForClass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void addUnattachedCategoryForClass(category_t *cat, Class cls,</span><br><span class="line">                                          header_info *catHeader)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    // DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead</span><br><span class="line">    NXMapTable *cats = unattachedCategories();  //初始化NXMapTable</span><br><span class="line">    category_list *list;</span><br><span class="line"></span><br><span class="line">    list = (category_list *)NXMapGet(cats, cls);//去Table表中查找对应cls的category列表</span><br><span class="line">    if (!list) &#123;</span><br><span class="line">        list = (category_list *)</span><br><span class="line">            calloc(sizeof(*list) + sizeof(list-&gt;list[0]), 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        list = (category_list *)</span><br><span class="line">            realloc(list, sizeof(*list) + sizeof(list-&gt;list[0]) * (list-&gt;count + 1));</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;list[list-&gt;count++] = (locstamped_category_t)&#123;cat, catHeader&#125;;//扩大list</span><br><span class="line">    NXMapInsert(cats, cls, list); //将cls对应的list插入到表中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>remethodizeClass 将cat一系列方法添加到类上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">static void remethodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // Re-methodizing: check for more categories</span><br><span class="line">    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        attachCategories(cls, cats, true /*flush caches*/);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // fixme rearrange to remove these intermediate allocations</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int propcount = 0;</span><br><span class="line">    int protocount = 0;</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    bool fromBundle = NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        property_list_t *proplist =</span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键在attachLists方法，将cls的rw对应的方法列表，属性列表，协议列表进行添加列表</p><ul><li>memmove<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">       if (addedCount == 0) return;</span><br><span class="line"></span><br><span class="line">       if (hasArray()) &#123;</span><br><span class="line">           // many lists -&gt; many lists</span><br><span class="line">           uint32_t oldCount = array()-&gt;count;</span><br><span class="line">           uint32_t newCount = oldCount + addedCount;</span><br><span class="line">           setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">           array()-&gt;count = newCount;</span><br><span class="line">           memmove(array()-&gt;lists + addedCount, array()-&gt;lists,</span><br><span class="line">                   oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">           memcpy(array()-&gt;lists, addedLists,</span><br><span class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">       &#125;</span><br><span class="line">       else if (!list  &amp;&amp;  addedCount == 1) &#123;</span><br><span class="line">           // 0 lists -&gt; 1 list</span><br><span class="line">           list = addedLists[0];</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123;</span><br><span class="line">           // 1 list -&gt; many lists</span><br><span class="line">           List* oldList = list;</span><br><span class="line">           uint32_t oldCount = oldList ? 1 : 0;</span><br><span class="line">           uint32_t newCount = oldCount + addedCount;</span><br><span class="line">           setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">           array()-&gt;count = newCount;</span><br><span class="line">           if (oldList) array()-&gt;lists[addedCount] = oldList;</span><br><span class="line">           memcpy(array()-&gt;lists, addedLists,</span><br><span class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>memmove和memcpy 两个C函数的操作，<br>将array先前的列表内容拷贝到新数组的末尾，然后将新添加的list插入到新数组的头部<br>解释了category的特性</p><ul><li>category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加方法后，类的方法列表里会有两个methodA</li><li>category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，也就是我们常说category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会停止查找，殊不知后面可能还有一样名字的方法。</li><li>category关联对象特性在之前文章中，请自行翻阅</li></ul><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>memmove(p2, p1, len) 内存拷贝<br>将p1的前面len长度的字符，拷贝到p2</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li>c函数 memmove和memcpy的区别 <a href="http://blog.jobbole.com/108842/" target="_blank" rel="noopener">http://blog.jobbole.com/108842/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在之前的文章中，分析load有提到对category中的load方法进行存储调用&lt;br&gt;现在我们来窥探一下category的作用&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="Objc" scheme="https://pattyxp.github.io/tags/Objc/"/>
    
  </entry>
  
  <entry>
    <title>Objc关联对象的实现</title>
    <link href="https://pattyxp.github.io/2018/02/03/Objc%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://pattyxp.github.io/2018/02/03/Objc关联对象的实现/</id>
    <published>2018-02-03T07:36:52.000Z</published>
    <updated>2018-05-18T09:29:40.358Z</updated>
    
    <content type="html"><![CDATA[<p>今天主要来聊一聊以下三个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void *key) &#123;</span><br><span class="line">    return _object_get_associative_reference(object, (void *)key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">    _object_set_associative_reference(object, (void *)key, value, policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void objc_removeAssociatedObjects(id object)</span><br><span class="line">&#123;</span><br><span class="line">    if (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        _object_remove_assocations(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分类添加属性的时候，由于系统没有办法自动将属性添加set和get方法，需要自动实现，就需要以上的方法来实现</p><h2 id="事例code"><a href="#事例code" class="headerlink" title="事例code"></a>事例code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@interface Dog: NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation Dog</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Dog(DanceCategory)</span><br><span class="line">@property (nonatomic, strong) NSString *categoryProperty;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog(DanceCategory)</span><br><span class="line">- (NSString *)categoryProperty</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">- (void)setCategoryProperty:(NSString *)categoryProperty</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(categoryProperty), categoryProperty, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark -main</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Dog *dd = [[Dog alloc] init];</span><br><span class="line">        dd.categoryProperty = @&quot;分类属性&quot;;</span><br><span class="line">        dd.categoryProperty;</span><br><span class="line">        objc_removeAssociatedObjects(dd);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>先看下设置属性的方法调用顺序<br><img src="/images/分类属性-调用堆栈.png" alt="调用堆栈.png"></p><h3 id="object-set-associative-reference"><a href="#object-set-associative-reference" class="headerlink" title="object_set_associative_reference"></a>object_set_associative_reference</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line"></span><br><span class="line">    ObjcAssociation old_association(0, nil); //生成旧对象</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;  </span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i != associations.end()) &#123;</span><br><span class="line">                // secondary table exists</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second; //如果存在之前的值，给旧对象赋值</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // create the new association (first time).</span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // setting the association to nil breaks the association.</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果旧对象有值，进行释放</span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个主要的类</p><ul><li>AssociationsManager   全局，持有spinlock_t 和 AssociationsHashMap</li><li>AssociationsHashMap   全局单例</li><li>ObjectAssociationMap  </li><li>ObjcAssociation       真正关联对象的类，包含policy和value</li></ul><p>此处有个简单例子说明下关联对象在内存的存储形式，例子和图片出自此处(<a href="https://draveness.me/ao" target="_blank" rel="noopener">https://draveness.me/ao</a>)<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">        objc_setAssociatedObject(obj, <span class="keyword">@selector</span>(hello), <span class="string">@"Hello"</span>, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/association结构.png" alt="association结构"></p><p>接着分析上面源代码:</p><ul><li>初始生成old_association，便于存储旧对象以及清除旧值</li><li>acquireValue 方法内部是对value进行copy或者retain</li><li>初始化生成或者取出唯一的全局单例AssociationsManager 和 AssociationsHashMap</li><li>disguised_object 是根据object生成的</li></ul><p><strong>两种情况</strong><br>下面根据newValue是否为空来处理的</p><ol><li><p>newValue 存在:设置或更新值的时候</p><ul><li>在AssociationsHashMap中根据disguised_object作为key去取对应的object的AssociationsHashMap</li><li><p>如果map存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectAssociationMap *refs = i-&gt;second</span><br><span class="line">ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">if (j != refs-&gt;end()) &#123; //如果存在旧值，将旧值赋值给临时变量old_association，便于最后释放</span><br><span class="line">    old_association = j-&gt;second;</span><br><span class="line">    j-&gt;second = ObjcAssociation(policy, new_value);//然后重新赋值</span><br><span class="line">&#125; else &#123; //如果不存在旧值，给map表设置key和value</span><br><span class="line">    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果map不存在，新生成ObjectAssociationMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAssociationMap *refs = new ObjectAssociationMap; //新生成ObjectAssociationMap</span><br><span class="line">associations[disguised_object] = refs; //将disguised_object作为key ,value是ObjectAssociationMap</span><br><span class="line">(*refs)[key] = ObjcAssociation(policy, new_value) //在ObjectAssociationMap中插入key和对应的ObjcAssociation</span><br><span class="line">object-&gt;setHasAssociatedObjects();//标记对象对应的标记位</span><br></pre></td></tr></table></figure></li></ul></li><li><p>newValue=nil 删除一个关联对象</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">if (i !=  associations.end()) &#123; //如果存在该object对应的map表，</span><br><span class="line">    ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">    ObjectAssociationMap::iterator j = refs-&gt;find(key); //从ObjectAssociationMap表中取出对应的key所对应的association</span><br><span class="line">    if (j != refs-&gt;end()) &#123;</span><br><span class="line">        old_association = j-&gt;second; //将存在的值赋值给old_association</span><br><span class="line">        refs-&gt;erase(j); //从表中将key对应的ObjcAssociation进行擦除</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>最后 如果存在旧值，将旧值释放即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (old_association.hasValue()) ReleaseValue()(old_association);</span><br></pre></td></tr></table></figure></li></ul><h3 id="object-get-associative-reference"><a href="#object-get-associative-reference" class="headerlink" title="object_get_associative_reference"></a>object_get_associative_reference</h3><p><img src="/images/分类属性-get.png" alt="getAssociation堆栈图"><br>上图是调用对象属性的get方法执行的堆栈结构图</p><p>流程比上面的方法相对简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id _object_get_associative_reference(id object, void *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object); //从AssociationsHashMap表中查找对象</span><br><span class="line">        if (i != associations.end()) &#123; //如果存在对象的话</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key); //从对象对应的ObjectAssociationMap表中根据key取出对应的value</span><br><span class="line">            if (j != refs-&gt;end()) &#123; //如果存在value</span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.value(); //将存在的ObjcAssociation属性对应赋值</span><br><span class="line">                policy = entry.policy();</span><br><span class="line">                if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);   //对value进行retain</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);</span><br><span class="line">    &#125;</span><br><span class="line">    return value; //最后将关联对象 ObjcAssociation 的值进行返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="objc-removeAssociatedObjects"><a href="#objc-removeAssociatedObjects" class="headerlink" title="objc_removeAssociatedObjects"></a>objc_removeAssociatedObjects</h2><p>先来看下调用remove方法的函数调用<br><img src="/images/分类属性-remove.png" alt="remove"><br>打印isa的结构，可以看到对象的has_assoc 标记为1，也就是存在关联对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void _object_remove_assocations(id object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        if (associations.size() == 0) return; //如果不存在 返回</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object); //查找object对应的表</span><br><span class="line">        if (i != associations.end()) &#123;</span><br><span class="line">            // copy all of the associations that need to be removed.</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second; //存在的话取出对应的object表</span><br><span class="line">            for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);//将表的元素存入elements</span><br><span class="line">            &#125;</span><br><span class="line">            delete refs; //移除object对应的表</span><br><span class="line">            associations.erase(i); //同时在AssociationsHashMap表中将object也移除</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // the calls to releaseValue() happen outside of the lock.</span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue()); //通过循环将elements元素都进行释放</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文就是对于如何给分类添加属性操作进行解读</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天主要来聊一聊以下三个方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;
      
    
    </summary>
    
    
      <category term="Objc" scheme="https://pattyxp.github.io/tags/Objc/"/>
    
  </entry>
  
</feed>
