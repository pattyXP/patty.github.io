<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温暖的弦</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pattyxp.github.io/"/>
  <updated>2018-03-14T06:50:33.774Z</updated>
  <id>https://pattyxp.github.io/</id>
  
  <author>
    <name>Patty</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ReactiveObjc入门</title>
    <link href="https://pattyxp.github.io/2018/03/12/ReactiveObjc%E5%85%A5%E9%97%A8/"/>
    <id>https://pattyxp.github.io/2018/03/12/ReactiveObjc入门/</id>
    <published>2018-03-12T09:40:55.000Z</published>
    <updated>2018-03-14T06:50:33.774Z</updated>
    
    <content type="html"><![CDATA[<p>ReactiveCocoa，将各种不同的设计模式，代理响应，观察者模式，通知等设计模式的输入，都抽象成为信号，让单一的组件对自己的行为进行控制，简化控制器的负担。<br>ReactiveCocoa的核心是信号，RACSignal</p><h2 id="RACSignal-与-RACStream"><a href="#RACSignal-与-RACStream" class="headerlink" title="RACSignal 与 RACStream"></a>RACSignal 与 RACStream</h2><p>RACSignal 是抽象类RACStream的子类，另一个子类是RACSequence<br><img src="/images/RAC-stream.png" alt="RAC-stream"></p><p>在 ReactiveCocoa 的世界中所有的消息都是通过信号的方式来传递的，原有的设计模式都会简化为一种模型,下面先来介绍下与RACSignal相关的问题</p><p>RACSignal继承自RACStream,RACStream作为抽象类，在实现内部抛出异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (__kindof RACStream *)empty &#123;</span><br><span class="line">NSString *reason = [NSString stringWithFormat:@&quot;%@ must be overridden by subclasses&quot;, NSStringFromSelector(_cmd)];</span><br><span class="line">@throw [NSException exceptionWithName:NSInternalInconsistencyException reason:reason userInfo:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (__kindof RACStream *)bind:(RACStreamBindBlock (^)(void))block;</span><br><span class="line">+ (__kindof RACStream *)return:(id)value;</span><br><span class="line">- (__kindof RACStream *)concat:(RACStream *)stream;</span><br><span class="line">- (__kindof RACStream *)zipWith:(RACStream *)stream;</span><br></pre></td></tr></table></figure><p>RACStream 需要子类实现这些方法，否则抛出异常<br>RACStream的分类Operations，定义了许多方法，只要子类实现以上的抽象方法，这些分类方法都能使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(id value))block &#123;</span><br><span class="line">Class class = self.class;</span><br><span class="line"></span><br><span class="line">return [[self bind:^&#123;</span><br><span class="line">return ^(id value, BOOL *stop) &#123;</span><br><span class="line">id stream = block(value) ?: [class empty];</span><br><span class="line">NSCAssert([stream isKindOfClass:RACStream.class], @&quot;Value returned from -flattenMap: is not a stream: %@&quot;, stream);</span><br><span class="line"></span><br><span class="line">return stream;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -flattenMap:&quot;, self.name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (__kindof RACStream *)flatten</span><br><span class="line">- (__kindof RACStream *)map:(id (^)(id value))block</span><br><span class="line">- (__kindof RACStream *)mapReplace:(id)object</span><br><span class="line">- (__kindof RACStream *)combinePreviousWithStart:(id)start reduce:(id (^)(id previous, id next))reduceBlock</span><br><span class="line">- (__kindof RACStream *)filter:(BOOL (^)(id value))block</span><br><span class="line">- (__kindof RACStream *)ignore:(id)value</span><br><span class="line">- (__kindof RACStream *)reduceEach:(RACReduceBlock)reduceBlock</span><br><span class="line">- (__kindof RACStream *)startWith:(id)value</span><br><span class="line">- (__kindof RACStream *)skip:(NSUInteger)skipCount</span><br><span class="line">- (__kindof RACStream *)take:(NSUInteger)count</span><br><span class="line">+ (__kindof RACStream *)join:(id&lt;NSFastEnumeration&gt;)streams block:(RACStream * (^)(id, id))block</span><br><span class="line">+ (__kindof RACStream *)zip:(id&lt;NSFastEnumeration&gt;)streams</span><br><span class="line">+ (__kindof RACStream *)zip:(id&lt;NSFastEnumeration&gt;)streams reduce:(RACGenericReduceBlock)reduceBlock</span><br><span class="line">+ (__kindof RACStream *)concat:(id&lt;NSFastEnumeration&gt;)streams</span><br><span class="line">- (__kindof RACStream *)scanWithStart:(id)startingValue reduce:(id (^)(id running, id next))reduceBlock</span><br><span class="line">- (__kindof RACStream *)scanWithStart:(id)startingValue reduceWithIndex:(id (^)(id, id, NSUInteger))reduceBlock</span><br><span class="line">- (__kindof RACStream *)takeUntilBlock:(BOOL (^)(id x))predicate</span><br><span class="line">- (__kindof RACStream *)takeWhileBlock:(BOOL (^)(id x))predicate</span><br><span class="line">- (__kindof RACStream *)skipUntilBlock:(BOOL (^)(id x))predicate</span><br><span class="line">- (__kindof RACStream *)skipWhileBlock:(BOOL (^)(id x))predicate</span><br><span class="line">- (__kindof RACStream *)distinctUntilChanged</span><br></pre></td></tr></table></figure></p><p>在 RACSignal (RACStream)</p><ul><li><p>return<br>通过传入NSObject类型的value,返回RACSignal对象，完成了UIKit -&gt; ReactiveCocoa</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)return:(id)value &#123;</span><br><span class="line">return [RACReturnSignal return:value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RACReturnSignal.m</span><br><span class="line">+ (RACSignal *)return:(id)value &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">RACReturnSignal *signal = [[self alloc] init];</span><br><span class="line">signal-&gt;_value = value;</span><br><span class="line"></span><br><span class="line">#ifdef DEBUG</span><br><span class="line">[signal setNameWithFormat:@&quot;+return: %@&quot;, value];</span><br><span class="line">#endif</span><br><span class="line">return signal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>bind<br>将原来的RACSignal通过传入的block，生成新的RACSignal</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">//RACSignalBindBlock:接受 NSObject 对象返回 RACSignal 对象</span><br><span class="line">typedef RACSignal * _Nullable (^RACSignalBindBlock)(ValueType _Nullable value, BOOL *stop);</span><br><span class="line"></span><br><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block &#123;</span><br><span class="line">  ...</span><br><span class="line">return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACSignalBindBlock bindingBlock = block();</span><br><span class="line"></span><br><span class="line">__block volatile int32_t signalCount = 1;   // indicates self</span><br><span class="line"></span><br><span class="line">RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">void (^completeSignal)(RACDisposble *) = ^(RACDisposble *finishedDisposable) &#123;</span><br><span class="line">if (OSAtomicDecrement32Barrier(&amp;signalCount) == 0) &#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">[compoundDisposable dispose];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">[compoundDisposable removeDisposable:finishedDisposable];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void (^addSignal)(RACSignal *) = ^(RACSignal *signal) &#123;</span><br><span class="line">OSAtomicIncrement32Barrier(&amp;signalCount);</span><br><span class="line"></span><br><span class="line">RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">[compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">RACDisposble *disposable = [signal subscribeNext:^(id x) &#123;</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">[compoundDisposable dispose];</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">completeSignal(selfDisposable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">selfDisposable.disposable = disposable;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">[compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">RACDisposble *bindingDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line">// Manually check disposal to handle synchronous errors.</span><br><span class="line">if (compoundDisposable.disposed) return;</span><br><span class="line"></span><br><span class="line">BOOL stop = NO;</span><br><span class="line">id signal = bindingBlock(x, &amp;stop);</span><br><span class="line"></span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">if (signal != nil) addSignal(signal);</span><br><span class="line">if (signal == nil || stop) &#123;</span><br><span class="line">[selfDisposable dispose];</span><br><span class="line">completeSignal(selfDisposable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">[compoundDisposable dispose];</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">completeSignal(selfDisposable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">selfDisposable.disposable = bindingDisposable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return compoundDisposable;</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -bind:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>bind方法虽然看着长，但是内部实现可以理解为，将RACSignal进行解包出NSObject，然后将NSObject传入RACSignalBindBlock，生成新的 RACSignal 返回<br>如果不考虑RACDisposble和error，可以将bind简化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block &#123;</span><br><span class="line"></span><br><span class="line">    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line"></span><br><span class="line">       return [self subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">            BOOL stop = NO;</span><br><span class="line">            [bindingBlock(x, &amp;stop) subscribeNext:^(id x) &#123;</span><br><span class="line">                [subscriber sendNext:x];</span><br><span class="line">            &#125;];</span><br><span class="line">       &#125;];</span><br><span class="line">    &#125;]setNameWithFormat:@&quot;[%@] -bind:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面结合实例讲解下bind的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposble * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    [subscriber sendNext:@2];</span><br><span class="line">    [subscriber sendNext:@3];</span><br><span class="line">    [subscriber sendNext:@4];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *blockSignal = [signal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">    return  ^(NSNumber *value, BOOL *stop) &#123;</span><br><span class="line">        value = @(value.integerValue * value.integerValue);</span><br><span class="line">        return [RACSignal return:value];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">   NSLog(@&quot;signal %@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[blockSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;blockSignal %@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>打印输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">signal 1</span><br><span class="line">signal 2</span><br><span class="line">signal 3</span><br><span class="line">signal 4</span><br><span class="line">blockSignal 1</span><br><span class="line">blockSignal 4</span><br><span class="line">blockSignal 9</span><br><span class="line">blockSignal 16</span><br></pre></td></tr></table></figure></p><p>整个过程大致如下:</p><ul><li>订阅原信号中的值；</li><li>将原信号发出的值传入 RACSignalBindBlock 进行转换；</li><li>如果 RACSignalBindBlock 返回一个信号，就会订阅该信号并将信号中的所有值传给订阅者 subscriber；</li><li>如果 RACSignalBindBlock 请求终止信号就会向原信号发出 -sendCompleted 消息；</li><li>当所有信号都完成时，会向订阅者发送 -sendCompleted；</li><li>无论何时，如果信号发出错误，都会向订阅者发送 -sendError: 消息。</li></ul><p>这里牵涉到了RACSubscriber，信号的订阅与信息的发送过程主要是由 RACSubscriber 类来处理的，这也是信号的处理过程中最重要的一部分</p><h2 id="RACSubscriber"><a href="#RACSubscriber" class="headerlink" title="RACSubscriber"></a>RACSubscriber</h2><p>下面结合实例讲解下bind的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposble * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@4];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">   NSLog(@&quot;signal %@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>创建信号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)createSignal:(RACDisposble * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line">RACDynamicSignal *signal = [[self alloc] init];</span><br><span class="line">signal-&gt;_didSubscribe = [didSubscribe copy];</span><br><span class="line">return [signal setNameWithFormat:@&quot;+createSignal:&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>信号创建之后，调用subscribeNext 不只会返回RACDisposble ，还生成一个 RACSubscriber 对象，向这个对象发送消息 -sendNext: 时，就向所有的订阅者发送消息。</p><p>当调用subscribeNext方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposble *)subscribeNext:(void (^)(id x))nextBlock &#123;</span><br><span class="line">NSCParameterAssert(nextBlock != NULL);</span><br><span class="line"></span><br><span class="line">RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];</span><br><span class="line">return [self subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初始化方法创建RACSubscriber实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed &#123;</span><br><span class="line">RACSubscriber *subscriber = [[self alloc] init];</span><br><span class="line"></span><br><span class="line">subscriber-&gt;_next = [next copy];</span><br><span class="line">subscriber-&gt;_error = [error copy];</span><br><span class="line">subscriber-&gt;_completed = [completed copy];</span><br><span class="line"></span><br><span class="line">return subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建的RACSubscriber实例需要订阅,subscribe:方法需要被RACSignal的子类实现，如 RACDynamicSignal<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">RACSignal.m</span><br><span class="line">- (RACDisposble *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">NSCAssert(NO, @&quot;This method must be overridden by subclasses&quot;);</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RACDynamicSignal.m</span><br><span class="line">- (RACDisposble *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">NSCParameterAssert(subscriber != nil);</span><br><span class="line"></span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">  //将subscriber，signal，disposable绑定</span><br><span class="line">subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</span><br><span class="line"></span><br><span class="line">if (self.didSubscribe != NULL) &#123; //self.didSubscribe是初始化RACSignal时候赋值block</span><br><span class="line">RACDisposble *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">      //schedule即执行block()，也就是下面的内容</span><br><span class="line">RACDisposble *innerDisposable = self.didSubscribe(subscriber);//将订阅者传进去执行结果</span><br><span class="line">[disposable addDisposable:innerDisposable];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:schedulingDisposable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用self.didSubscribe(subscriber)对订阅者发送消息，也就是执行了<br><code>[subscriber sendNext:@4];</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark RACSubscriber</span><br><span class="line"></span><br><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">void (^nextBlock)(id) = [self.next copy];</span><br><span class="line">if (nextBlock == nil) return;</span><br><span class="line"></span><br><span class="line">nextBlock(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendNext操作，就是将subscribe初始化传进来的block进行copy然后调用参数执行block,所以将参数x传递进来<br>执行下面这句话<br><code>NSLog(@&quot;signal %@&quot;,x);</code><br>剩下 RACDisposble 暂时不管，至此一个信号的创建和订阅完毕</p><p>信号的订阅发送，可以按需定制<br><img src="/images/RAC-发送订阅.png" alt="RAC-发送订阅"></p><p>原理大致相似，此处省略</p><h2 id="RACDisposble"><a href="#RACDisposble" class="headerlink" title="RACDisposble"></a>RACDisposble</h2><p>在创建信号的时候，会返回一个 RACDisposble ，用于在订阅结束进行必要的清理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface RACDisposable () &#123;</span><br><span class="line">void * volatile _disposeBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACDisposable 最核心的就是 <code>_disposeBlock</code> ，内部的方法都是围绕它进行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)disposableWithBlock:(void (^)(void))block &#123;</span><br><span class="line">return [[self alloc] initWithBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBlock:(void (^)(void))block &#123;</span><br><span class="line">NSCParameterAssert(block != nil);</span><br><span class="line"></span><br><span class="line">self = [super init];</span><br><span class="line"></span><br><span class="line">_disposeBlock = (void *)CFBridgingRetain([block copy]);</span><br><span class="line">OSMemoryBarrier();</span><br><span class="line"></span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">self = [super init];</span><br><span class="line"></span><br><span class="line">_disposeBlock = (__bridge void *)self;</span><br><span class="line">OSMemoryBarrier();</span><br><span class="line"></span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>void (^)(void)类型的block作为参数传入，会转化为CoreFoundation中的类型，赋值disposeBlock</p><p>下面是相关主要的子类RACSerialDisposable 和 RACCompoundDisposable</p><ul><li><p>RACSerialDisposable<br>线程安全，使用 pthread_mutex_t 保证<br>保证只含有一个RACDisposble</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  - (BOOL)isDisposed &#123;</span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">const BOOL disposed = _disposed;</span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line">return disposed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RACCompoundDisposable<br>管理多个 RACDisposable 对象的释放</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@interface RACCompoundDisposable () &#123;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t _mutex;</span><br><span class="line">RACDisposable *_inlineDisposables[RACCompoundDisposableInlineCount];</span><br><span class="line">CFMutableArrayRef _disposables;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithDisposables:(NSArray *)otherDisposables &#123;</span><br><span class="line">self = [self init];</span><br><span class="line"></span><br><span class="line">#if RACCompoundDisposableInlineCount</span><br><span class="line">[otherDisposables enumerateObjectsUsingBlock:^(RACDisposable *disposable, NSUInteger index, BOOL *stop) &#123;</span><br><span class="line">self-&gt;_inlineDisposables[index] = disposable;</span><br><span class="line"></span><br><span class="line">// Stop after this iteration if we&apos;ve reached the end of the inlined</span><br><span class="line">// array.</span><br><span class="line">if (index == RACCompoundDisposableInlineCount - 1) *stop = YES;</span><br><span class="line">&#125;];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">if (otherDisposables.count &gt; RACCompoundDisposableInlineCount) &#123;</span><br><span class="line">_disposables = RACCreateDisposablesArray();</span><br><span class="line"></span><br><span class="line">CFRange range = CFRangeMake(RACCompoundDisposableInlineCount, (CFIndex)otherDisposables.count - RACCompoundDisposableInlineCount);</span><br><span class="line">CFArrayAppendArray(_disposables, (__bridge CFArrayRef)otherDisposables, range);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对象持有的 RACDisposable 不超过 RACCompoundDisposableInlineCount(2) 时，都会存储在 <code>_inlineDisposables</code> 数组中，而更多的实例都会存储在 <code>_disposables</code> 中：</p><p>值得注意的还有一个 addDisposable 方法<br>方法线程安全，如果_inlineDisposables数组内没有存满，先优先存储在inlineDisposbles数组，如果存满，往_disposables拼接数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDisposable:(RACDisposable *)disposable &#123;</span><br><span class="line">NSCParameterAssert(disposable != self);</span><br><span class="line">if (disposable == nil || disposable.disposed) return;</span><br><span class="line"></span><br><span class="line">BOOL shouldDispose = NO;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">&#123;</span><br><span class="line">if (_disposed) &#123;</span><br><span class="line">shouldDispose = YES;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">#if RACCompoundDisposableInlineCount</span><br><span class="line">for (unsigned i = 0; i &lt; RACCompoundDisposableInlineCount; i++) &#123;</span><br><span class="line">if (_inlineDisposables[i] == nil) &#123;</span><br><span class="line">_inlineDisposables[i] = disposable;</span><br><span class="line">goto foundSlot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">if (_disposables == NULL) _disposables = RACCreateDisposablesArray();</span><br><span class="line">CFArrayAppendValue(_disposables, (__bridge void *)disposable);</span><br><span class="line"></span><br><span class="line">if (RACCOMPOUNDDISPOSABLE_ADDED_ENABLED()) &#123;</span><br><span class="line">RACCOMPOUNDDISPOSABLE_ADDED(self.description.UTF8String, disposable.description.UTF8String, CFArrayGetCount(_disposables) + RACCompoundDisposableInlineCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if RACCompoundDisposableInlineCount</span><br><span class="line">foundSlot:;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line">if (shouldDispose) [disposable dispose];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="订阅的销毁"><a href="#订阅的销毁" class="headerlink" title="订阅的销毁"></a>订阅的销毁</h2><p>在了解了相关RACDisposble之后，再来看下bind方法中关于这方面发处理,以下是缩略版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACSignalBindBlock bindingBlock = block();</span><br><span class="line"></span><br><span class="line">__block volatile int32_t signalCount = 1;   // indicates self</span><br><span class="line"></span><br><span class="line">RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">void (^completeSignal)(RACDisposable *) = ...</span><br><span class="line"></span><br><span class="line">void (^addSignal)(RACSignal *) = ...</span><br><span class="line"></span><br><span class="line">    RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">    [compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">    RACDisposable *bindingDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">      if (compoundDisposable.disposed) return;</span><br><span class="line"></span><br><span class="line">      BOOL stop = NO;</span><br><span class="line">      id signal = bindingBlock(x, &amp;stop);</span><br><span class="line"></span><br><span class="line">        if (signal != nil) addSignal(signal);</span><br><span class="line">        if (signal == nil || stop) &#123;</span><br><span class="line">          [selfDisposable dispose];</span><br><span class="line">          completeSignal(selfDisposable);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; completed:^&#123;</span><br><span class="line">        completeSignal(selfDisposable);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">selfDisposable.disposable = bindingDisposable;</span><br><span class="line">return compoundDisposable;</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -bind:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简化后，可以观察到，信号的清理交给了 RACCompoundDisposable 实例，向 RACCompoundDisposable添加了 RACSerialDisposable ，将信号订阅后返回的 RACDisposable 交给了 RACSerialDisposable</p><p>completeSignal 和  addSignal 负责新信号创建之后的清理<br>当订阅新信号，产生的 RACSerialDisposable 添加进 RACCompoundDisposable 实例<br>当信号完成，compoundDisposable进行清理工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void (^completeSignal)(RACDisposable *) = ^(RACDisposable *finishedDisposable) &#123;</span><br><span class="line">    if (OSAtomicDecrement32Barrier(&amp;signalCount) == 0) &#123;</span><br><span class="line">      [subscriber sendCompleted];</span><br><span class="line">      [compoundDisposable dispose];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      [compoundDisposable removeDisposable:finishedDisposable];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  void (^addSignal)(RACSignal *) = ^(RACSignal *signal) &#123;</span><br><span class="line">    OSAtomicIncrement32Barrier(&amp;signalCount);</span><br><span class="line"></span><br><span class="line">    RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">    [compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">    RACDisposable *disposable = [signal subscribeNext:^(id x) &#123;</span><br><span class="line">      [subscriber sendNext:x];</span><br><span class="line">    &#125; error:^(NSError *error) &#123;</span><br><span class="line">      [compoundDisposable dispose];</span><br><span class="line">      [subscriber sendError:error];</span><br><span class="line">    &#125; completed:^&#123;</span><br><span class="line">      @autoreleasepool &#123;</span><br><span class="line">        completeSignal(selfDisposable);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    selfDisposable.disposable = disposable;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>下面结合事例code看下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    [subscriber sendNext:@2];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;Origin Signal Dispose&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *blockSignal = [signal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">    return  ^(NSNumber *value, BOOL *stop) &#123;</span><br><span class="line">        value = @(value.integerValue * value.integerValue);</span><br><span class="line"></span><br><span class="line">        return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            for (int i=0; i&lt;value.integerValue; i++) &#123;</span><br><span class="line">                [subscriber sendNext:value];</span><br><span class="line">            &#125;</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                NSLog(@&quot;Binding Signal Dispose&quot;);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[blockSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;signal %@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">打印log</span><br><span class="line">ReactiveObjcTest[17315:3506059] signal 1</span><br><span class="line">ReactiveObjcTest[17315:3506059] Binding Signal Dispose</span><br><span class="line">ReactiveObjcTest[17315:3506059] signal 4</span><br><span class="line">ReactiveObjcTest[17315:3506059] signal 4</span><br><span class="line">ReactiveObjcTest[17315:3506059] signal 4</span><br><span class="line">ReactiveObjcTest[17315:3506059] signal 4</span><br><span class="line">ReactiveObjcTest[17315:3506059] Binding Signal Dispose</span><br><span class="line">ReactiveObjcTest[17315:3506059] Origin Signal Dispose</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RACSignal 相关的类及代码较简洁，方法也不是很复杂，但是之前并没有深入学习，理解还是需要分析的。<br>结合实际事例，查看调用栈分析情况容易入手，<br>使用上看着也方便，但是内部创建了多个实例对象，信号、订阅者、信号清理机制等，看着有点绕，但是使用block非常方便调用</p><p>信号使用过程:<br>先订阅，然后发送信息，订阅者接收到消息<br>subscribeNext -&gt;产生Subscriber-&gt; sendNext -&gt;所有的Subscriber接收到消息</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://github.com/Draveness/analyze/blob/master/contents/ReactiveObjC/RACSignal.md" target="_blank" rel="noopener">https://github.com/Draveness/analyze/blob/master/contents/ReactiveObjC/RACSignal.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ReactiveCocoa，将各种不同的设计模式，代理响应，观察者模式，通知等设计模式的输入，都抽象成为信号，让单一的组件对自己的行为进行控制，简化控制器的负担。&lt;br&gt;ReactiveCocoa的核心是信号，RACSignal&lt;/p&gt;
&lt;h2 id=&quot;RACSignal-
      
    
    </summary>
    
    
      <category term="源码" scheme="https://pattyxp.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>AFNetworking源码分析</title>
    <link href="https://pattyxp.github.io/2018/02/27/AFNetworking%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://pattyxp.github.io/2018/02/27/AFNetworking源码分析/</id>
    <published>2018-02-27T08:43:30.000Z</published>
    <updated>2018-03-01T07:38:29.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AFNetworking结构"><a href="#AFNetworking结构" class="headerlink" title="AFNetworking结构"></a>AFNetworking结构</h2><p>主要分为五部分内容</p><ul><li>网络通信NSURLSession (核心)</li><li>网络状态监听Reachability</li><li>网络安全Security</li><li>网络信息序列化Serialization</li><li>UIKit扩展</li></ul><h2 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h2><p>AFNetworking 基于NSURLSession 封装了 AFURLSessionManager 和 AFHTTPSessionManager<br>AFHTTPSessionManager继承自 AFURLSessionManager 主要提供对外的接口API<br>AFURLSessionManager 才是核心关键</p><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>先来看下AFHTTPSessionManager 网络请求，以POST为例，调用父类方法获取task，然后调用resume<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)POST:(NSString *)URLString</span><br><span class="line">                    parameters:(id)parameters</span><br><span class="line">                      progress:(void (^)(NSProgress * _Nonnull))uploadProgress</span><br><span class="line">                       success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success</span><br><span class="line">                       failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;POST&quot; URLString:URLString parameters:parameters uploadProgress:uploadProgress downloadProgress:nil success:success failure:failure];</span><br><span class="line"></span><br><span class="line">    [dataTask resume];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在父类方法中，将参数和请求URL转化为Request，然后生成dataTask做网络请求</span><br><span class="line"></span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</span><br><span class="line">                                       URLString:(NSString *)URLString</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</span><br><span class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</span><br><span class="line">&#123;</span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    dataTask = [self dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="请求参数解析类"><a href="#请求参数解析类" class="headerlink" title="请求参数解析类"></a>请求参数解析类</h2><p>详解如何将参数转化为Request<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableURLRequest *)requestWithMethod:(NSString *)method</span><br><span class="line">                                 URLString:(NSString *)URLString</span><br><span class="line">                                parameters:(id)parameters</span><br><span class="line">                                     error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line"></span><br><span class="line">    NSParameterAssert(url);</span><br><span class="line"></span><br><span class="line">    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];</span><br><span class="line">    mutableRequest.HTTPMethod = method;</span><br><span class="line"></span><br><span class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主要作用</p><ul><li>生成 NSMutableURLRequest</li><li>设置 Request的 HTTPMethod</li><li>AFHTTPRequestSerializerObservedKeyPaths内包含 NSMutableURLRequest的部分属性<ul><li>BOOL allowsCellularAccess;</li><li>NSURLRequestCachePolicy cachePolicy;cachePolicy</li><li>BOOL HTTPShouldHandleCookies</li><li>BOOL HTTPShouldUsePipelining</li><li>NSURLRequestNetworkServiceType networkServiceType</li><li>NSTimeInterval timeoutInterval<br>当检测到这几个属性有变化，重新赋值给mutableRequest</li></ul></li><li>将parameter进行编码添加入request</li></ul><h2 id="parameter编码"><a href="#parameter编码" class="headerlink" title="parameter编码"></a>parameter编码</h2><p>请求参数进行编码，根据请求Method区分参数是拼接在URL后面 setURL，还是设置请求体setHTTPBody<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</span><br><span class="line">                               withParameters:(id)parameters</span><br><span class="line">                                        error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</span><br><span class="line">    ...</span><br><span class="line">    NSString *query = nil;</span><br><span class="line">    ...</span><br><span class="line">    //将参数进行拼接</span><br><span class="line">    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">    ...</span><br><span class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;  // 如果是 GET 等，拼接参数重置 URL</span><br><span class="line">        if (query &amp;&amp; query.length &gt; 0) &#123;</span><br><span class="line">            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // #2864: an empty string is a valid x-www-form-urlencoded payload</span><br><span class="line">        if (!query) &#123;</span><br><span class="line">            query = @&quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</span><br><span class="line">            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];   //setHTTPHeaderField</span><br><span class="line">        &#125;</span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];// setHTTPBody</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/parameter转换.png" alt="parameter转换"></p><p>参数转码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">NSString * AFQueryStringFromParameters(NSDictionary *parameters) &#123;</span><br><span class="line">    NSMutableArray *mutablePairs = [NSMutableArray array];</span><br><span class="line">    //将参数转化为字典</span><br><span class="line">    for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class="line">    &#125;</span><br><span class="line">    //拼接</span><br><span class="line">    return [mutablePairs componentsJoinedByString:@&quot;&amp;&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSArray * AFQueryStringPairsFromDictionary(NSDictionary *dictionary) &#123;</span><br><span class="line">    return AFQueryStringPairsFromKeyAndValue(nil, dictionary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) &#123;</span><br><span class="line">    NSMutableArray *mutableQueryStringComponents = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">    //将参数的key对description进行排序，使用compare方法比较</span><br><span class="line">    //&#123; net,bar,base&#125; -&gt; &#123; bar,base,net&#125;</span><br><span class="line">    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;description&quot; ascending:YES selector:@selector(compare:)];</span><br><span class="line"></span><br><span class="line">    //对value是dict，array，set类型处理，直到为其他类型，生成AFQueryStringPair插入数组</span><br><span class="line">    if ([value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">        NSDictionary *dictionary = value;</span><br><span class="line">        for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            id nestedValue = dictionary[nestedKey];</span><br><span class="line">            if (nestedValue) &#123;</span><br><span class="line">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@&quot;%@[%@]&quot;, key, nestedKey] : nestedKey), nestedValue)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if ([value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">        NSArray *array = value;</span><br><span class="line">        for (id nestedValue in array) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@&quot;%@[]&quot;, key], nestedValue)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if ([value isKindOfClass:[NSSet class]]) &#123;</span><br><span class="line">        NSSet *set = value;</span><br><span class="line">        for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参数转码举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@&#123;</span><br><span class="line">     @&quot;name&quot; : @&quot;bang&quot;,</span><br><span class="line">     @&quot;phone&quot;: @&#123;@&quot;mobile&quot;: @&quot;xx&quot;, @&quot;home&quot;: @&quot;xx&quot;&#125;,</span><br><span class="line">     @&quot;families&quot;: @[@&quot;father&quot;, @&quot;mother&quot;],</span><br><span class="line">     @&quot;nums&quot;: [NSSet setWithObjects:@&quot;1&quot;, @&quot;2&quot;, nil]</span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line">@[</span><br><span class="line">     field: @&quot;name&quot;, value: @&quot;bang&quot;,</span><br><span class="line">     field: @&quot;phone[mobile]&quot;, value: @&quot;xx&quot;,</span><br><span class="line">     field: @&quot;phone[home]&quot;, value: @&quot;xx&quot;,</span><br><span class="line">     field: @&quot;families[]&quot;, value: @&quot;father&quot;,</span><br><span class="line">     field: @&quot;families[]&quot;, value: @&quot;mother&quot;,</span><br><span class="line">     field: @&quot;nums&quot;, value: @&quot;1&quot;,</span><br><span class="line">     field: @&quot;nums&quot;, value: @&quot;2&quot;,</span><br><span class="line">]</span><br><span class="line">-&gt;</span><br><span class="line">name=bang&amp;phone[mobile]=xx&amp;phone[home]=xx&amp;families[]=father&amp;families[]=mother&amp;nums=1&amp;num=2</span><br></pre></td></tr></table></figure></p><p>至此，request已经设置好，下面就是如何生成 NSURLSessionDataTask</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">dataTask = [self dataTaskWithRequest:request ...]</span><br><span class="line"></span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line"></span><br><span class="line">    //为了解决iOS 8以下 创建task并发创建多个task但因同步问题导致task的identifier不唯一，所以串行处理</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [self.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug 1140.11</span><br><span class="line"></span><br><span class="line">static void url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123;</span><br><span class="line">        // Fix of bug</span><br><span class="line">        // Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span><br><span class="line">        // Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span><br><span class="line">        dispatch_sync(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个task都对应一个delegate,便于之后数据处理以及回调<br>根据dataTask唯一的taskIdentifier和AFURLSessionManagerTaskDelegate相对应，存储在字典中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class="line">    delegate.manager = self;  //设置manager</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</span><br><span class="line">    [self setDelegate:delegate forTask:dataTask]; //绑定delegate和dataTask</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(NSURLSessionTask *)task</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    //保证线程安全</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    //将AFdelegate存入以task的identifier为key的字典中</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    //监听task任务开始和暂停的通知</span><br><span class="line">    [self addNotificationObserverForTask:task];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//监听task任务开始和暂停的通知</span><br><span class="line">- (void)addNotificationObserverForTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上方法创建了AFURLSessionManagerTaskDelegate 将其和dataTask对应存储到manager的字典中，<br>同时还监听任务开始和挂起的通知，<br>差不多准备工作完毕，在AFHTTPSessionManager中拿到了返回的task，调用了resume启动任务</p><p>网络开始请求数据，初始化的时候，设置AFURLSessionManager 为session的代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br></pre></td></tr></table></figure></p><p>于是会进行下面的回调<br><img src="/images/AFNet-代理方法整理..png" alt="AFNet-代理方法整理"></p><p>AFURLSessionManager 包含许多自定义的block，可以在回调方法中处理接收到数据<br>其中六个方法会回调到AF自定义的delegate,负责把每个task对应的数据回调出去<br><img src="/images/AFNet-AFDelegate.jpeg" alt="AFNet-AFDelegate"></p><p>以task 请求baidu为例<br>首先会收到回调receiveData<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];</span><br><span class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line"></span><br><span class="line">    if (self.dataTaskDidReceiveData) &#123;</span><br><span class="line">        self.dataTaskDidReceiveData(session, dataTask, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    self.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive;</span><br><span class="line">    self.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived;</span><br><span class="line"></span><br><span class="line">    [self.mutableData appendData:data]; //拼接data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果请求完成，进入下面操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    // delegate may be nil when completing a task in the background</span><br><span class="line">    if (delegate) &#123;</span><br><span class="line">        //把代理转发给我们绑定的AFURLSessionManagerTaskDelegate</span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line"></span><br><span class="line">        [self removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //执行 completeblock</span><br><span class="line">    if (self.taskDidComplete) &#123;</span><br><span class="line">        self.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">  /*</span><br><span class="line">  @interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;</span><br><span class="line"></span><br><span class="line">  @property (nonatomic, weak) AFURLSessionManager *manager;</span><br><span class="line"></span><br><span class="line">  AFURLSessionManagerTaskDelegate 弱持有manager，所以下面强引用manager</span><br><span class="line">  不会存在循环引用问题</span><br><span class="line">  */</span><br><span class="line">    __strong AFURLSessionManager *manager = self.manager;</span><br><span class="line"></span><br><span class="line">    __block id responseObject = nil;</span><br><span class="line"></span><br><span class="line">    //下面对userInfo进行拼接</span><br><span class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    if (self.mutableData) &#123;</span><br><span class="line">        data = [self.mutableData copy]; //任务完成了，将数据拷贝后，不需要mutableData，清空释放内存</span><br><span class="line">        self.mutableData = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</span><br><span class="line">    &#125; else if (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (error) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">        //在自定义的completionGroup或者completionQueue进行回调操作</span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (self.completionHandler) &#123;</span><br><span class="line">                self.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line">            //在主线程发出任务完成通知</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            NSError *serializationError = nil;</span><br><span class="line"></span><br><span class="line">            //根据定义的responseSerializer 解析数据</span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            //如果是下载文件，解析数据为下载路径</span><br><span class="line">            if (self.downloadFileURL) &#123;</span><br><span class="line">                responseObject = self.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                if (self.completionHandler) &#123;</span><br><span class="line">                    self.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h2><p>自定义block，通过对外声明set方法，重写block的set方法，清晰了解block的参数和返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@interface AFURLSessionManager ()</span><br><span class="line">@property (readwrite, nonatomic, strong) NSURLSessionConfiguration *sessionConfiguration;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSOperationQueue *operationQueue;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSURLSession *session;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;</span><br><span class="line">@property (readonly, nonatomic, copy) NSString *taskDescriptionForSessionTasks;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSLock *lock;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidCompleteBlock taskDidComplete;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>下面了解下各个block的使用</p><ul><li><p>AFURLSessionDidBecomeInvalidBlock</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当session失效，该代理方法被调用</span><br><span class="line">当调用finishTasksAndInvalidate使session失效，但是允许现有任务运行完成之后调用该代理</span><br><span class="line">当调用invalidateAndCancel,session会立即调用该代理</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didBecomeInvalidWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">  if (self.sessionDidBecomeInvalid) &#123;</span><br><span class="line">      self.sessionDidBecomeInvalid(session, error);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AFURLSessionDidReceiveAuthenticationChallengeBlock</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  该方法主要用于对https的认证</span><br><span class="line">*/</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    // 挑战处理类型</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    // 使用指定证书</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line"></span><br><span class="line">    if (self.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      /*</span><br><span class="line">       此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust</span><br><span class="line">      也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。</span><br><span class="line">      而这个证书就需要使用credentialForTrust:来创建一个NSURLCredential对象</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">          // 基于客户端的安全策略来决定是否信任该服务器</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line"></span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                if (credential) &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengeUseCredential; //使用证书</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;//取消挑战</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //完成挑战</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AFURLSessionDidFinishEventsForBackgroundURLSessionBlock</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当session中所有已经入队的消息被发送出去后，会调用该代理方法</span><br><span class="line"></span><br><span class="line">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session &#123;</span><br><span class="line">    if (self.didFinishEventsForBackgroundURLSession) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            self.didFinishEventsForBackgroundURLSession(session);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>AFURLSessionTaskWillPerformHTTPRedirectionBlock<br>//当服务器重定向的时候调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">willPerformHTTPRedirection:(NSHTTPURLResponse *)response</span><br><span class="line">        newRequest:(NSURLRequest *)request</span><br><span class="line"> completionHandler:(void (^)(NSURLRequest *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLRequest *redirectRequest = request;</span><br><span class="line"></span><br><span class="line">    //如果存在自定义重定向block，返回新的重定向Request</span><br><span class="line">    if (self.taskWillPerformHTTPRedirection) &#123;</span><br><span class="line">        redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用request重新请求</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(redirectRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AFURLSessionTaskDidReceiveAuthenticationChallengeBlock</p></li></ul><p>和上面认证https方法类似，只是多了参数task,可以根据每个task去自定义需要的https认证方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line"></span><br><span class="line">    if (self.taskDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>AFURLSessionTaskNeedNewBodyStreamBlock</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line"> needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSInputStream *inputStream = nil;</span><br><span class="line"></span><br><span class="line">    if (self.taskNeedNewBodyStream) &#123;</span><br><span class="line">        inputStream = self.taskNeedNewBodyStream(session, task);</span><br><span class="line">    &#125; else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) &#123;</span><br><span class="line">        inputStream = [task.originalRequest.HTTPBodyStream copy];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.jianshu.com/p/856f0e26279d" target="_blank" rel="noopener">https://www.jianshu.com/p/856f0e26279d</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AFNetworking结构&quot;&gt;&lt;a href=&quot;#AFNetworking结构&quot; class=&quot;headerlink&quot; title=&quot;AFNetworking结构&quot;&gt;&lt;/a&gt;AFNetworking结构&lt;/h2&gt;&lt;p&gt;主要分为五部分内容&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="源码" scheme="https://pattyxp.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>内存分配</title>
    <link href="https://pattyxp.github.io/2018/02/27/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://pattyxp.github.io/2018/02/27/内存分配/</id>
    <published>2018-02-27T07:07:05.000Z</published>
    <updated>2018-02-27T08:16:00.199Z</updated>
    
    <content type="html"><![CDATA[<p>本文分析内存使用Xcode自带的Instruments分析工具Alloctions<br>运行profile下的Alloctions，可以看到有一栏统计All Heap &amp; Anonymous VM使用的内存<br>All Heap:堆上分配的内存情况<br>Anonymous VM:虚拟内存分配</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>当应用向系统申请分配内存时，系统不会返回需要的物理内存地址，而是返回虚拟内存地址。当开始真正使用申请到的虚拟内存的时候，系统才将虚拟内存映射到具体的物理内存上。</p><h2 id="内存页"><a href="#内存页" class="headerlink" title="内存页"></a>内存页</h2><p>系统将内存页分为三种状态。</p><p>活跃内存页（active pages）- 这种内存页已经被映射到物理内存中，而且近期被访问过，处于活跃状态。<br>非活跃内存页（inactive pages）- 这种内存页已经被映射到物理内存中，但是近期没有被访问过。<br>可用的内存页（free pages）- 没有关联到虚拟内存页的物理内存页集合。</p><p>当可用的内存页降低到一定的阀值时，系统就会采取低内存应对措施，在OSX中，系统会将非活跃内存页交换到硬盘上，而在iOS中，则会触发Memory Warning，如果你的App没有处理低内存警告并且还在后台占用太多内存，则有可能被杀掉。</p><h2 id="VM-Region-Size"><a href="#VM-Region-Size" class="headerlink" title="VM Region Size"></a>VM Region Size</h2><p><img src="/images/内存分配-1.png" alt="内存分配"><br>上图是mac OS应用的 VM Tracker分析图，可以看到VM Tree Region有4种size</p><ul><li>Dirty Size</li><li>Swapped Size:交换到硬盘上的大小 仅OSX系统适用</li><li>Resident Size:实际使用物理内存的大小</li><li>Virtual Size:虚拟内存大小</li></ul><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>我们常使用以下几种方式来分配内存</p><ul><li>NSObject的 alloc 方法</li><li>c函数的 malloc 方法<br>malloc有一个缺陷，必须配合memset将内存区中所有的值设置为0。这样就导致了一个问题:malloc出一块内存区域时，系统并没有分配物理内存。然而调用memset后，系统将会把malloc出的所有虚拟内存关联到物理内存上<br>因此系统建议使用calloc方法,calloc返回的内存区域会自动清零，而且只有使用时才会关联到物理内存并清零。</li></ul><p>以OC当中创建实例对象为例，最终调用方法_class_createInstanceFromZone<br>方法内部调用calloc来分配内存，下图显示调用栈的情况<br><img src="/images/内存分配-alloc.png" alt="内存分配-alloc"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              bool cxxConstruct = true,</span><br><span class="line">                              size_t *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    if (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">        obj = (id)calloc(1, size);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (zone) &#123;</span><br><span class="line">            obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj = (id)calloc(1, size);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://juejin.im/post/5a5e13c45188257327399e19" target="_blank" rel="noopener">https://juejin.im/post/5a5e13c45188257327399e19</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文分析内存使用Xcode自带的Instruments分析工具Alloctions&lt;br&gt;运行profile下的Alloctions，可以看到有一栏统计All Heap &amp;amp; Anonymous VM使用的内存&lt;br&gt;All Heap:堆上分配的内存情况&lt;br&gt;Ano
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Aspects源码解析</title>
    <link href="https://pattyxp.github.io/2018/02/23/Aspects%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://pattyxp.github.io/2018/02/23/Aspects源码解析/</id>
    <published>2018-02-23T07:37:15.000Z</published>
    <updated>2018-02-26T02:02:32.587Z</updated>
    
    <content type="html"><![CDATA[<p>本文源码解析来自官方1.4.2版本</p><h2 id="AspectInfo"><a href="#AspectInfo" class="headerlink" title="AspectInfo"></a>AspectInfo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface AspectInfo : NSObject &lt;AspectInfo&gt;</span><br><span class="line">@property (nonatomic, unsafe_unretained, readonly) id instance;</span><br><span class="line">@property (nonatomic, strong, readonly) NSArray *arguments;</span><br><span class="line">@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="AspectIdentifier"><a href="#AspectIdentifier" class="headerlink" title="AspectIdentifier"></a>AspectIdentifier</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface AspectIdentifier : NSObject</span><br><span class="line">@property (nonatomic, assign) SEL selector;</span><br><span class="line">@property (nonatomic, strong) id block;</span><br><span class="line">@property (nonatomic, strong) NSMethodSignature *blockSignature;</span><br><span class="line">@property (nonatomic, weak) id object;</span><br><span class="line">@property (nonatomic, assign) AspectOptions options;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="AspectsContainer"><a href="#AspectsContainer" class="headerlink" title="AspectsContainer"></a>AspectsContainer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface AspectsContainer : NSObject</span><br><span class="line"></span><br><span class="line">- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;</span><br><span class="line">- (BOOL)removeAspect:(id)aspect;</span><br><span class="line">- (BOOL)hasAspects;</span><br><span class="line"></span><br><span class="line">@property (atomic, copy) NSArray *beforeAspects;</span><br><span class="line">@property (atomic, copy) NSArray *insteadAspects;</span><br><span class="line">@property (atomic, copy) NSArray *afterAspects;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="AspectTracker"><a href="#AspectTracker" class="headerlink" title="AspectTracker"></a>AspectTracker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface AspectTracker : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) Class trackedClass;</span><br><span class="line">@property (nonatomic, readonly) NSString *trackedClassName;</span><br><span class="line">@property (nonatomic, strong) NSMutableSet *selectorNames;</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary *selectorNamesToSubclassTrackers;</span><br><span class="line"></span><br><span class="line">- (id)initWithTrackedClass:(Class)trackedClass;</span><br><span class="line">- (void)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;</span><br><span class="line">- (void)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;</span><br><span class="line">- (BOOL)subclassHasHookedSelectorName:(NSString *)selectorName;</span><br><span class="line">- (NSSet *)subclassTrackersHookingSelectorName:(NSString *)selectorName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>调试，首先调用aspect_add方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) &#123;</span><br><span class="line">    NSCParameterAssert(self);</span><br><span class="line">    NSCParameterAssert(selector);</span><br><span class="line">    NSCParameterAssert(block);</span><br><span class="line"></span><br><span class="line">    __block AspectIdentifier *identifier = nil;</span><br><span class="line">    aspect_performLocked(^&#123;</span><br><span class="line">        if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) &#123;</span><br><span class="line">            AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector);</span><br><span class="line">            identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];  //生成AspectIdentifier</span><br><span class="line">            if (identifier) &#123;</span><br><span class="line">                [aspectContainer addAspect:identifier withOptions:options];</span><br><span class="line">                //区分options向aspectContainer的数组添加aspect</span><br><span class="line"></span><br><span class="line">                // Modify the class to allow message interception.</span><br><span class="line">                aspect_prepareClassAndHookSelector(self, selector, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return identifier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static AspectsContainer *aspect_getContainerForObject(NSObject *self, SEL selector) &#123;</span><br><span class="line">    NSCParameterAssert(self);</span><br><span class="line">    SEL aliasSelector = aspect_aliasForSelector(selector);//拼接生成新selector</span><br><span class="line">    AspectsContainer *aspectContainer = objc_getAssociatedObject(self, aliasSelector);</span><br><span class="line">    if (!aspectContainer) &#123;</span><br><span class="line">        aspectContainer = [AspectsContainer new];</span><br><span class="line">        objc_setAssociatedObject(self, aliasSelector, aspectContainer, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    &#125;</span><br><span class="line">    //当前对象如果不存在aliasSelector,给当前对象绑定属性aliasSelector</span><br><span class="line">    return aspectContainer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>aspect_performLocked 使用OSSpinLock</li><li>aspect_isSelectorAllowedAndTrack 过滤当前aspect的selector是否为合法的selector</li><li>生成AspectIdentifier,根据block生成block签名,根据options加入AspectContainer的相应数组</li><li>aspect_prepareClassAndHookSelector hook方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) &#123;</span><br><span class="line">    NSCParameterAssert(selector);</span><br><span class="line">    Class klass = aspect_hookClass(self, error);</span><br><span class="line">    Method targetMethod = class_getInstanceMethod(klass, selector);</span><br><span class="line">    IMP targetMethodIMP = method_getImplementation(targetMethod);</span><br><span class="line">    if (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;</span><br><span class="line">        const char *typeEncoding = method_getTypeEncoding(targetMethod);</span><br><span class="line">        SEL aliasSelector = aspect_aliasForSelector(selector);</span><br><span class="line">        if (![klass instancesRespondToSelector:aliasSelector]) &#123;</span><br><span class="line">            __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);</span><br><span class="line">            NSCAssert(addedAlias, @&quot;Original implementation for %@ is already copied to %@ on %@&quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We use forwardInvocation to hook in.</span><br><span class="line">        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);</span><br><span class="line">        AspectLog(@&quot;Aspects: Installed hook for -[%@ %@].&quot;, klass, NSStringFromSelector(selector));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>aspect_prepareClassAndHookSelector 方法主要操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - Hook Class</span><br><span class="line"></span><br><span class="line">static Class aspect_hookClass(NSObject *self, NSError **error) &#123;</span><br><span class="line">    NSCParameterAssert(self);</span><br><span class="line">Class statedClass = self.class;</span><br><span class="line">Class baseClass = object_getClass(self);</span><br><span class="line">NSString *className = NSStringFromClass(baseClass);</span><br><span class="line"></span><br><span class="line">if ([className hasSuffix:AspectsSubclassSuffix]) &#123;</span><br><span class="line">return baseClass;</span><br><span class="line">&#125;else if (class_isMetaClass(baseClass)) &#123;</span><br><span class="line">        return aspect_swizzleClassInPlace((Class)self);</span><br><span class="line">        // Probably a KVO&apos;ed class. Swizzle in place. Also swizzle meta classes in place.</span><br><span class="line">    &#125;else if (statedClass != baseClass) &#123;</span><br><span class="line">        return aspect_swizzleClassInPlace(baseClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  //生成子类subclass</span><br><span class="line">const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;</span><br><span class="line">Class subclass = objc_getClass(subclassName);</span><br><span class="line"></span><br><span class="line">if (subclass == nil) &#123;</span><br><span class="line">subclass = objc_allocateClassPair(baseClass, subclassName, 0);//Allocate subclass</span><br><span class="line">if (subclass == nil) &#123;</span><br><span class="line">            NSString *errrorDesc = [NSString stringWithFormat:@&quot;objc_allocateClassPair failed to allocate class %s.&quot;, subclassName];</span><br><span class="line">            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">aspect_swizzleForwardInvocation(subclass);//替换子类forwardInvocation方法</span><br><span class="line">aspect_hookedGetClass(subclass, statedClass);//替换子类class方法为原类statedClass</span><br><span class="line">aspect_hookedGetClass(object_getClass(subclass), statedClass);//替换子类的元类的class方法为原类statedClass</span><br><span class="line">objc_registerClassPair(subclass);//注册子类</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object_setClass(self, subclass);//替换当前对象的isa为subclass obj-&gt;changeIsa(cls)</span><br><span class="line">return subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先 对当前self进行hook class<br>此处self为AspectsViewController类型的对象，hook后为AspectsViewController<em>Aspects</em></li><li>给子类也就是hook后的类AspectsViewController<em>Aspects</em>添加方法，name为aspect_aliasForSelector(selector),方法实现method_getImplementation(原selector的method实现)</li><li><p>替换子类的原selector实现为aspect_getMsgForwardIMP(self, selector)</p></li><li><p>aspect_getMsgForwardIMP 作用<br>返回IMP,用于当消息转发的时候use forwardInvocation to hook</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static IMP aspect_getMsgForwardIMP(NSObject *self, SEL selector) &#123;</span><br><span class="line">    IMP msgForwardIMP = _objc_msgForward;</span><br><span class="line">#if !defined(__arm64__)</span><br><span class="line"></span><br><span class="line">    Method method = class_getInstanceMethod(self.class, selector);</span><br><span class="line">    const char *encoding = method_getTypeEncoding(method);</span><br><span class="line">    BOOL methodReturnsStructValue = encoding[0] == _C_STRUCT_B;</span><br><span class="line">    if (methodReturnsStructValue) &#123;</span><br><span class="line">        @try &#123;</span><br><span class="line">            NSUInteger valueSize = 0;</span><br><span class="line">            NSGetSizeAndAlignment(encoding, &amp;valueSize, NULL);</span><br><span class="line"></span><br><span class="line">            if (valueSize == 1 || valueSize == 2 || valueSize == 4 || valueSize == 8) &#123;</span><br><span class="line">                methodReturnsStructValue = NO;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; @catch (__unused NSException *e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (methodReturnsStructValue) &#123;</span><br><span class="line">        msgForwardIMP = (IMP)_objc_msgForward_stret;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    return msgForwardIMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>至此，准备工作已经结束，下面进行调试工作<br>当点击按钮的时候，查看到左边的函数调用栈，消息转发进入<strong>ASPECTS_ARE_BEING_CALLED</strong>这里是关键<br>之前说过，当前class已经被修改isa为子类，子类的selector方法被hook了IMP，消息进入转发流程<br><img src="/images/Aspects_hook原selector.png" alt="hook原selector"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// This is the swizzled forwardInvocation: method.</span><br><span class="line">static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) &#123;</span><br><span class="line">    ...</span><br><span class="line">    SEL originalSelector = invocation.selector;</span><br><span class="line">  SEL aliasSelector = aspect_aliasForSelector(invocation.selector);</span><br><span class="line">    invocation.selector = aliasSelector;</span><br><span class="line">    AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector);</span><br><span class="line">    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector);</span><br><span class="line">    AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation];</span><br><span class="line">    NSArray *aspectsToRemove = nil;</span><br><span class="line"></span><br><span class="line">    // Before hooks.</span><br><span class="line">    aspect_invoke(classContainer.beforeAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.beforeAspects, info);</span><br><span class="line"></span><br><span class="line">    //子类执行 aliasSelector ，也就是原selector对应的method</span><br><span class="line">    // Instead hooks.</span><br><span class="line">    BOOL respondsToAlias = YES;</span><br><span class="line">    if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123;</span><br><span class="line">        aspect_invoke(classContainer.insteadAspects, info);</span><br><span class="line">        aspect_invoke(objectContainer.insteadAspects, info);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        Class klass = object_getClass(invocation.target);</span><br><span class="line">        do &#123;</span><br><span class="line">            if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123;</span><br><span class="line">                [invocation invoke];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;while (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //执行block的方法</span><br><span class="line">    // After hooks.</span><br><span class="line">    aspect_invoke(classContainer.afterAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.afterAspects, info);</span><br><span class="line"></span><br><span class="line">    //如果没有实现alias方法，执行原来的selector</span><br><span class="line">    if (!respondsToAlias) &#123;</span><br><span class="line">        invocation.selector = originalSelector;</span><br><span class="line">        SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName);</span><br><span class="line">        if ([self respondsToSelector:originalForwardInvocationSEL]) &#123;</span><br><span class="line">            ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            [self doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Remove any hooks that are queued for deregistration.</span><br><span class="line">    [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏aspect_invoke<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#define aspect_invoke(aspects, info) \</span><br><span class="line">for (AspectIdentifier *aspect in aspects) &#123;\</span><br><span class="line">    [aspect invokeWithInfo:info];\</span><br><span class="line">    if (aspect.options &amp; AspectOptionAutomaticRemoval) &#123; \</span><br><span class="line">        aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用AspectIdentifier的实例方法</span><br><span class="line">- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info &#123;</span><br><span class="line">    NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:self.blockSignature];</span><br><span class="line">    NSInvocation *originalInvocation = info.originalInvocation;</span><br><span class="line">    NSUInteger numberOfArguments = self.blockSignature.numberOfArguments;</span><br><span class="line"></span><br><span class="line">    // Be extra paranoid. We already check that on hook registration.</span><br><span class="line">    if (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123;</span><br><span class="line">        AspectLogError(@&quot;Block has too many arguments. Not calling %@&quot;, info);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The `self` of the block will be the AspectInfo. Optional.</span><br><span class="line">    if (numberOfArguments &gt; 1) &#123;</span><br><span class="line">        [blockInvocation setArgument:&amp;info atIndex:1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">void *argBuf = NULL;</span><br><span class="line">    for (NSUInteger idx = 2; idx &lt; numberOfArguments; idx++) &#123;</span><br><span class="line">        const char *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">NSUInteger argSize;</span><br><span class="line">NSGetSizeAndAlignment(type, &amp;argSize, NULL);</span><br><span class="line"></span><br><span class="line">if (!(argBuf = reallocf(argBuf, argSize))) &#123;</span><br><span class="line">            AspectLogError(@&quot;Failed to allocate memory for block invocation.&quot;);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[originalInvocation getArgument:argBuf atIndex:idx];</span><br><span class="line">[blockInvocation setArgument:argBuf atIndex:idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [blockInvocation invokeWithTarget:self.block]; //执行blockInvocation</span><br><span class="line"></span><br><span class="line">    if (argBuf != NULL) &#123;</span><br><span class="line">        free(argBuf);</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此流程调用分析结束</p><h2 id="Aspects原理"><a href="#Aspects原理" class="headerlink" title="Aspects原理"></a>Aspects原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend(id self, SEL op, ...) &#123;</span><br><span class="line">    if (!self) return nil;</span><br><span class="line">    IMP imp = class_getMethodImplementation(self-&gt;isa, SEL op);</span><br><span class="line">    imp(self, op, ...); //调用这个函数，伪代码...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找IMP</span><br><span class="line">IMP class_getMethodImplementation(Class cls, SEL sel) &#123;</span><br><span class="line">    if (!cls || !sel) return nil;</span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel);</span><br><span class="line">    if (!imp) return _objc_msgForward; //_objc_msgForward 用于消息转发</span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息的发送最终走到objc_msgSend<br>消息转发流程图:<br><img src="/images/Aspects_SEL invoke流程图.png" alt="Aspects_SEL invoke流程图"></p><p>Aspects 正是利用其中最灵活的forwardInvocation进行封装的<br>对于待 hook 的 selector，将其指向 objc_msgForward /objc_msgForward_stret ,<br>同时生成一个新的 aliasSelector 指向原来的 IMP，<br>并且 hook 住 forwardInvocation 函数，使他指向自己的实现。按照上面的思路，当被 hook 的 selector 被执行的时候，首先根据 selector 找到了 objc_msgForward /objc_msgForward_stret ,而这个会触发消息转发，从而进入 forwardInvocation。同时由于 forwardInvocation 的指向也被修改了，因此会转入新的 forwardInvocation 函数，在里面执行需要嵌入的附加代码，完成之后，再转回原来的 IMP。</p><h2 id="Aspects-执行流程"><a href="#Aspects-执行流程" class="headerlink" title="Aspects 执行流程"></a>Aspects 执行流程</h2><p>这里以实例对象为例,运行官方demo,对象方法的hook，首先需要先添加待hook的方法，aspect_add<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) &#123;</span><br><span class="line">    ...</span><br><span class="line">    __block AspectIdentifier *identifier = nil;</span><br><span class="line">    aspect_performLocked(^&#123;</span><br><span class="line">        if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) &#123;//1判断能否hook</span><br><span class="line">            ... //2 记录数据结构</span><br><span class="line">            aspect_prepareClassAndHookSelector(self, selector, error);//3 swizzling</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>aspect_isSelectorAllowedAndTrack判断方法能否被hook,对于forwardInvocation、dealloc等方法在黑名单之中</li><li>对于元类，需要保证类的方法只在继承链中被hook一次,,先从当前类开始查找方法是否已经被hook,否则从父类中查找,找到了说明能被hook且被hook过一次</li><li><p>以下源码 从当前类开始，添加所有继承链上的AspectTracker的selectorNames或者subclassTracker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AspectTracker *tracker = nil;</span><br><span class="line">AspectTracker *subclassTracker = nil;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">       tracker = swizzledClassesDict[currentClass];</span><br><span class="line">       if (!tracker) &#123;</span><br><span class="line">           tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass]; //初始化</span><br><span class="line">           swizzledClassesDict[(id&lt;NSCopying&gt;)currentClass] = tracker; //赋值操作</span><br><span class="line">      &#125;</span><br><span class="line">      if (subclassTracker) &#123;</span><br><span class="line">           [tracker addSubclassTracker:subclassTracker hookingSelectorName:selectorName];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">           [tracker.selectorNames addObject:selectorName];</span><br><span class="line">      &#125;</span><br><span class="line">      // All superclasses get marked as having a subclass that is modified.</span><br><span class="line">      subclassTracker = tracker;</span><br><span class="line">&#125;while ((currentClass = class_getSuperclass(currentClass)));</span><br></pre></td></tr></table></figure></li><li><p>aspect_prepareClassAndHookSelector 最重要的就是hook ForwardInvocation方法<br>刚注册子类的时候，子类没有forwardInvocation方法，aspect_swizzleForwardInvocation内class_addMethod不会执行，所以不会生成  NSSelectorFromString(AspectsForwardInvocationSelectorName)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void aspect_swizzleForwardInvocation(Class klass) &#123;</span><br><span class="line">    NSCParameterAssert(klass);</span><br><span class="line">    // If there is no method, replace will act like class_addMethod.</span><br><span class="line">    IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, &quot;v@:@&quot;);</span><br><span class="line">    if (originalImplementation) &#123;</span><br><span class="line">        class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, &quot;v@:@&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    AspectLog(@&quot;Aspects: %@ is now aspect aware.&quot;, NSStringFromClass(klass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>aspect_hookClass之后，添加aliasSelector，方法指向原selector的实现，原selector指向转发IMP</p></li><li>方法转发<strong>ASPECTS_ARE_BEING_CALLED</strong> 最终执行到这个方法,依次处理before/instead/after逻辑以及调用原来的逻辑，如果不存在hook方法，能响应原始函数则执行原始函数，否则报错</li></ul><h2 id="加深了解"><a href="#加深了解" class="headerlink" title="加深了解"></a>加深了解</h2><ul><li>block转化为NSInvocation<br>消息转发的时候，需要调用NSInvocation,hook的时候缓存的是block,因此需要将block转化为NSInvocation，<br>AspectIdentifier 内含有NSMethodSignature *blockSignature,包括执行 block 所需要用到的具体信息如方法签名、参数等</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static NSMethodSignature *aspect_blockMethodSignature(id block, NSError **error) &#123;</span><br><span class="line">    AspectBlockRef layout = (__bridge void *)block;</span><br><span class="line">if (!(layout-&gt;flags &amp; AspectBlockFlagsHasSignature)) &#123;</span><br><span class="line">        NSString *description = [NSString stringWithFormat:@&quot;The block %@ doesn&apos;t contain a type signature.&quot;, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">void *desc = layout-&gt;descriptor;</span><br><span class="line">desc += 2 * sizeof(unsigned long int);</span><br><span class="line">if (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) &#123;</span><br><span class="line">desc += 2 * sizeof(void *);</span><br><span class="line">    &#125;</span><br><span class="line">if (!desc) &#123;</span><br><span class="line">        NSString *description = [NSString stringWithFormat:@&quot;The block %@ doesn&apos;t has a type signature.&quot;, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">const char *signature = (*(const char **)desc);</span><br><span class="line">return [NSMethodSignature signatureWithObjCTypes:signature];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>NSInvocation的创建, 需要signature, argument.<br>signature可以从block中转换过来, 而参数则可以从原来的AspectInfo对象中取出来做转换<br>从Block获得编码的Signature，可以转化为方法签名<br>在源码block签名方法中打上断点，可以查看block具体结构体<br><img src="/images/Aspects_block_signature.png" alt="Aspects_block_signature"></p><p>void *desc = layout-&gt;descriptor 这个指针就是用于获取block的签名, 根据clang的源码, 签名位于descriptor结构体的第三个变量, 所以将指针移动两个单位.<br>flag用于判断block的具体类型BLOCK_HAS_COPY_DISPOSE, 代表这个block是否有捕获外部参数, 如果有捕获则descriptor中会多插入两个变量, 所以需要将desc指针再移动两个单位</p></li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>以下code实践将block转化为NSInvocation执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">struct Block_literal_1 &#123;</span><br><span class="line">    void *isa; // initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span><br><span class="line">    int flags;</span><br><span class="line">    int reserved;</span><br><span class="line">    void (*invoke)(void *, ...);</span><br><span class="line">    struct Block_descriptor_1 &#123;</span><br><span class="line">        unsigned long int reserved;         // NULL</span><br><span class="line">        unsigned long int size;         // sizeof(struct Block_literal_1)</span><br><span class="line">        // optional helper functions</span><br><span class="line">        void (*copy_helper)(void *dst, void *src);     // IFF (1&lt;&lt;25)</span><br><span class="line">        void (*dispose_helper)(void *src);             // IFF (1&lt;&lt;25)</span><br><span class="line">        // required ABI.2010.3.16</span><br><span class="line">        const char *signature;                         // IFF (1&lt;&lt;30)</span><br><span class="line">    &#125; *descriptor;</span><br><span class="line">    // imported variables</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static NSMethodSignature *blockSignature(id blockObj)</span><br><span class="line">&#123;</span><br><span class="line">    struct Block_literal_1 *block = (__bridge void *)blockObj;</span><br><span class="line"></span><br><span class="line">    int signatureFlag = 1 &lt;&lt; 30;</span><br><span class="line">    assert(block-&gt;flags &amp; signatureFlag);</span><br><span class="line"></span><br><span class="line">    void *desc = block-&gt;descriptor;</span><br><span class="line">    desc += 2 * sizeof(unsigned long int); //signature</span><br><span class="line"></span><br><span class="line">    int copyDisposeFlag = 1 &lt;&lt; 25;</span><br><span class="line">    if (block-&gt;flags &amp; copyDisposeFlag) &#123;</span><br><span class="line">        desc += 2 * sizeof(void *);</span><br><span class="line">    &#125;</span><br><span class="line">    const char *signature = (*(const char **)desc);</span><br><span class="line">    return [NSMethodSignature signatureWithObjCTypes:signature];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)testBlockInvocation</span><br><span class="line">&#123;</span><br><span class="line">    NSString* (^myblock) (NSString* , NSString* ) = ^(NSString* a, NSString* b)&#123;</span><br><span class="line">        NSLog(@&quot;a:%@,b:%@&quot;,a,b);</span><br><span class="line">        return [NSString stringWithFormat:@&quot;a:%@,b:%@&quot;,a,b];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    NSString *result = myblock(@&quot;Tom&quot;,@&quot;Jerry&quot;);</span><br><span class="line">    XCTAssertTrue([result isEqualToString:[NSString stringWithFormat:@&quot;a:Tom,b:Jerry&quot;]], @&quot;result Must be a:Tom,b:Jerry&quot;);</span><br><span class="line"></span><br><span class="line">    NSMethodSignature *sig = blockSignature(myblock);</span><br><span class="line"></span><br><span class="line">    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sig];</span><br><span class="line">    invocation.target = myblock;</span><br><span class="line"></span><br><span class="line">    NSArray *args = @[@&quot;Patty&quot;,@&quot;Cat&quot;];</span><br><span class="line"></span><br><span class="line">    for(NSUInteger i = 0; i &lt; args.count ; ++i)&#123;</span><br><span class="line">        NSString *object = args[i];</span><br><span class="line">        [invocation setArgument:&amp;object atIndex:i + 1];</span><br><span class="line">    &#125;</span><br><span class="line">    [invocation setTarget:myblock];</span><br><span class="line">    [invocation invoke];</span><br><span class="line">    // 获取返回值</span><br><span class="line">    id returnValue = nil;</span><br><span class="line">    if (sig.methodReturnLength) &#123;</span><br><span class="line">        //获取返回值</span><br><span class="line">        [invocation getReturnValue:&amp;returnValue];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取返回值的类型</span><br><span class="line">    const char *returnType = [sig methodReturnType];</span><br><span class="line">    NSLog(@&quot;返回值的类型 %s&quot;,returnType);</span><br><span class="line">    XCTAssertTrue([returnValue isEqualToString:@&quot;a:Patty,b:Cat&quot;], @&quot;result Must be a:Patty,b:Cat&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果如下<br>a:Tom,b:Jerry<br>a:Patty,b:Cat<br>返回值的类型 @”NSString”</p><h2 id="阅读链接"><a href="#阅读链接" class="headerlink" title="阅读链接"></a>阅读链接</h2><p><a href="https://wereadteam.github.io/2016/06/30/Aspects/" target="_blank" rel="noopener">https://wereadteam.github.io/2016/06/30/Aspects/</a><br><a href="http://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="noopener">http://clang.llvm.org/docs/Block-ABI-Apple.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文源码解析来自官方1.4.2版本&lt;/p&gt;
&lt;h2 id=&quot;AspectInfo&quot;&gt;&lt;a href=&quot;#AspectInfo&quot; class=&quot;headerlink&quot; title=&quot;AspectInfo&quot;&gt;&lt;/a&gt;AspectInfo&lt;/h2&gt;&lt;figure class=&quot;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Objc-autoreleasePool</title>
    <link href="https://pattyxp.github.io/2018/02/13/Objc-autoreleasePool/"/>
    <id>https://pattyxp.github.io/2018/02/13/Objc-autoreleasePool/</id>
    <published>2018-02-13T02:55:28.000Z</published>
    <updated>2018-02-23T03:23:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇开始学习OC的内存管理，先来说说autoreleasepool相关的原理<br>一般来说，线程和autoreleasepool是对应存在的，主线程，默认含有自动释放池</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        for (int i=0; i&lt;100; i++) &#123;</span><br><span class="line">            @autoreleasepool&#123;</span><br><span class="line">                SampleClass *sample = [[SampleClass alloc] init];</span><br><span class="line">                [sample startAction];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的for循环内，断点执行，可以看到方法执行函数调用栈<br><img src="/images/autoreleasepool1.png" alt="函数调用栈"></p><h2 id="push操作"><a href="#push操作" class="headerlink" title="push操作"></a>push操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void *</span><br><span class="line">objc_autoreleasePoolPush(void)</span><br><span class="line">&#123;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line">#   define POOL_BOUNDARY nil</span><br><span class="line">static inline void *push()</span><br><span class="line">   &#123;</span><br><span class="line">       id *dest;</span><br><span class="line">       if (DebugPoolAllocation) &#123;</span><br><span class="line">           // Each autorelease pool starts on a new pool page.</span><br><span class="line">           dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           dest = autoreleaseFast(POOL_BOUNDARY); //执行</span><br><span class="line">       &#125;</span><br><span class="line">       assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">       return dest;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static inline id *autoreleaseFast(id obj)</span><br><span class="line">   &#123;</span><br><span class="line">       AutoreleasePoolPage *page = hotPage();</span><br><span class="line">       if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">           return page-&gt;add(obj);</span><br><span class="line">       &#125; else if (page) &#123;</span><br><span class="line">           return autoreleaseFullPage(obj, page);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return autoreleaseNoPage(obj);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>一般所指的hot page ，即最新添加的 autoreleased 对象所在的那个 page</li></ul><p>autoreleaseFast 函数的作用</p><ul><li>判断当前是否存在page，存在<ul><li>page存储满,autoreleaseFullPage</li><li>page有空间，page-&gt;add(obj)</li></ul></li><li>不存在page，创建 autoreleaseNoPage</li></ul><h2 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h2><p>autoreleasepool 没有单独的内存结构，它是以autoreleasepoolPage为结点的双向链表来实现的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage</span><br><span class="line">&#123;</span><br><span class="line">    static pthread_key_t const key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    static uint8_t const SCRIBBLE = 0xA3;  // 0xA3A3A3A3 after releasing</span><br><span class="line">    static size_t const SIZE = PAGE_MAX_SIZE;  // size and alignment, power of 2</span><br><span class="line">    static size_t const COUNT = SIZE / sizeof(id);</span><br><span class="line">    ...</span><br><span class="line">    magic_t const magic;</span><br><span class="line">    id *next;</span><br><span class="line">    pthread_t const thread;</span><br><span class="line">    AutoreleasePoolPage * const parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    uint32_t const depth;</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><p>下面是空AutoreleasePoolPage的内存结构图:<br><img src="/images/空AutoreleasePoolPage.png" alt="空AutoreleasePoolPage"></p><ul><li>magic 用来校验 AutoreleasePoolPage 的结构是否完整；</li><li>next 指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 begin() ；<br>thread 指向当前线程；</li><li>parent 指向父结点，第一个结点的 parent 值为 nil ；</li><li>child 指向子结点，最后一个结点的 child 值为 nil ；</li><li>depth 代表深度，从 0 开始，往后递增 1；</li><li>hiwat 代表 high water mark 。</li><li>当 next == begin() 时，表示 AutoreleasePoolPage 为空；</li><li>当 next == end() 时，表示 AutoreleasePoolPage 已满。</li></ul><p>根据断点调试，进入 page-&gt;add(obj)</p><ul><li>将当前page的next指针处存入obj对象，next指针指向下一个位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id *add(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!full());</span><br><span class="line">    unprotect();</span><br><span class="line">    id *ret = next;  // faster than `return next-1` because of aliasing</span><br><span class="line">    *next++ = obj;</span><br><span class="line">    protect();</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="autorelease操作"><a href="#autorelease操作" class="headerlink" title="autorelease操作"></a>autorelease操作</h2><p>通过 NSObject.mm 源文件，找到以下方法的实现</p><ul><li>(id)autorelease {<br>  return ((id)self)-&gt;rootAutorelease();<br>}<br>通过查看 ((id)self)-&gt;rootAutorelease() 的方法调用，我们发现最终调用的就是 AutoreleasePoolPage 的 autorelease 函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">inline id objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;</span><br><span class="line"></span><br><span class="line">    return rootAutorelease2();</span><br><span class="line">&#125;</span><br><span class="line">id objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line">    return AutoreleasePoolPage::autorelease((id)this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/对象release堆栈图.png" alt="对象release堆栈图"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static inline id autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line">    assert(!obj-&gt;isTaggedPointer());</span><br><span class="line">    id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    assert(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到autorelease操作和push非常相似<br>push插入的是POOL_BOUNDARY 即nil<br>autorelease插入具体需要释放的对象</p><h2 id="Pop操作"><a href="#Pop操作" class="headerlink" title="Pop操作"></a>Pop操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void pop(void *token)</span><br><span class="line">   &#123;</span><br><span class="line">       AutoreleasePoolPage *page;</span><br><span class="line">       id *stop;</span><br><span class="line"></span><br><span class="line">       if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">          ...</span><br><span class="line">          setHotPage(nil);</span><br><span class="line">          ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       page = pageForPointer(token); //取出对应的page</span><br><span class="line">       stop = (id *)token;</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       page-&gt;releaseUntil(stop); //释放token之后所有的对象</span><br><span class="line"></span><br><span class="line">       // memory: delete empty children</span><br><span class="line">       if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">           // special case: delete everything during page-per-pool debugging</span><br><span class="line">           AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">           page-&gt;kill();</span><br><span class="line">           setHotPage(parent);</span><br><span class="line">       &#125; else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">           // special case: delete everything for pop(top)</span><br><span class="line">           // when debugging missing autorelease pools</span><br><span class="line">           page-&gt;kill();</span><br><span class="line">           setHotPage(nil);</span><br><span class="line">       &#125;</span><br><span class="line">       else if (page-&gt;child) &#123;</span><br><span class="line">           // hysteresis: keep one empty child if page is more than half full</span><br><span class="line">           if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">               page-&gt;child-&gt;kill();</span><br><span class="line">           &#125;</span><br><span class="line">           else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">               page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>内存地址在 stop 之后的所有 autoreleased 对象都会被 release ,直到 stop 所在 page 的 next 指向 stop 为止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void releaseUntil(id *stop)</span><br><span class="line">   &#123;</span><br><span class="line">     while (this-&gt;next != stop) &#123;</span><br><span class="line"></span><br><span class="line">           AutoreleasePoolPage *page = hotPage();</span><br><span class="line"></span><br><span class="line">           while (page-&gt;empty()) &#123;</span><br><span class="line">               page = page-&gt;parent;</span><br><span class="line">               setHotPage(page);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           page-&gt;unprotect();</span><br><span class="line">           id obj = *--page-&gt;next;</span><br><span class="line">           memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));</span><br><span class="line">           page-&gt;protect();</span><br><span class="line"></span><br><span class="line">           if (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">               objc_release(obj);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       setHotPage(this);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看到这里，对autoreleasePool已经有了基本的认识原理，了解push和pop操作，对象的autorelease</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇开始学习OC的内存管理，先来说说autoreleasepool相关的原理&lt;br&gt;一般来说，线程和autoreleasepool是对应存在的，主线程，默认含有自动释放池&lt;/p&gt;
&lt;h2 id=&quot;源码解析&quot;&gt;&lt;a href=&quot;#源码解析&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Objc-protocol篇</title>
    <link href="https://pattyxp.github.io/2018/02/12/Objc-protocol%E7%AF%87/"/>
    <id>https://pattyxp.github.io/2018/02/12/Objc-protocol篇/</id>
    <published>2018-02-12T03:28:59.000Z</published>
    <updated>2018-02-13T02:47:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@protocol DogProtocol</span><br><span class="line">@required</span><br><span class="line">- (void)printName;</span><br><span class="line">@optional</span><br><span class="line">- (void)printAge;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Dog: NSObject</span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@property (nonatomic) NSInteger age;</span><br><span class="line">@property (nonatomic, weak) id delegate;</span><br><span class="line">- (void)printDetails;</span><br><span class="line">@end</span><br><span class="line">@implementation Dog</span><br><span class="line">-(void)printDetails</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;I&apos;m Dog&quot;);</span><br><span class="line">    [self.delegate printName];</span><br><span class="line">    [self.delegate printAge];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface SampleClass:NSObject&lt;DogProtocol&gt;</span><br><span class="line">@property (nonatomic, strong) Dog *littleDog;</span><br><span class="line">- (void)startAction;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SampleClass</span><br><span class="line"></span><br><span class="line">- (void)startAction&#123;</span><br><span class="line">    Dog *dog = [[Dog alloc]init];</span><br><span class="line">    dog.name = @&quot;PattyDog&quot;;</span><br><span class="line">    dog.age = 10;</span><br><span class="line">    dog.delegate = self;</span><br><span class="line"></span><br><span class="line">    self.littleDog = dog;</span><br><span class="line">    [dog printDetails];</span><br><span class="line">&#125;</span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;name:%@&quot;,self.littleDog.name);</span><br><span class="line">&#125;</span><br><span class="line">- (void)printAge</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;age:%zd&quot;,self.littleDog.age);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark -main</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        SampleClass *sample = [[SampleClass alloc] init];</span><br><span class="line">        [sample startAction];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看控制台打印输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m Dog</span><br><span class="line">name:PattyDog</span><br><span class="line">age:10</span><br></pre></td></tr></table></figure></p><h2 id="protocol-t结构"><a href="#protocol-t结构" class="headerlink" title="protocol_t结构"></a>protocol_t结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct protocol_t : objc_object &#123;</span><br><span class="line">    const char *mangledName;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    method_list_t *instanceMethods;</span><br><span class="line">    method_list_t *classMethods;</span><br><span class="line">    method_list_t *optionalInstanceMethods;</span><br><span class="line">    method_list_t *optionalClassMethods;</span><br><span class="line">    property_list_t *instanceProperties;</span><br><span class="line">    uint32_t size;   // sizeof(protocol_t)</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    // Fields below this point are not always present on disk.</span><br><span class="line">    const char **_extendedMethodTypes;</span><br><span class="line">    const char *_demangledName;</span><br><span class="line">    property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    const char *demangledName();</span><br><span class="line"></span><br><span class="line">    const char *nameForLogging() &#123;</span><br><span class="line">        return demangledName();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分别申明-required和-optional方法"><a href="#分别申明-required和-optional方法" class="headerlink" title="分别申明@required和@optional方法"></a>分别申明@required和@optional方法</h2><p>下面打印验证协议方法<br>打印方法类似之前文章中介绍消息缓存<br>现在查看SampleClass遵循的协议</p><p><img src="/images/protocol_t.png" alt="protocol_t结构证明"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">2018-02-13 09:51:09.129854+0800 debug-objc[26530:1205183] 0x100002610</span><br><span class="line">(lldb) p (objc_class *)0x100002610</span><br><span class="line">(objc_class *) $0 = 0x0000000100002610</span><br><span class="line">(lldb) p (class_data_bits_t *)0x0000000100002630</span><br><span class="line">(class_data_bits_t *) $1 = 0x0000000100002630</span><br><span class="line">(lldb) p (class_rw_t *)$1-&gt;data()</span><br><span class="line">(class_rw_t *) $2 = 0x0000000100a21a80</span><br><span class="line">(lldb) p $2-&gt;protocols</span><br><span class="line">(protocol_array_t) $3 = &#123;</span><br><span class="line">  list_array_tt&lt;unsigned long, protocol_list_t&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = 0x0000000100002370</span><br><span class="line">      arrayAndFlag = 4294976368</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $3.beginLists()</span><br><span class="line">(protocol_list_t **) $4 = 0x0000000100a21aa0</span><br><span class="line">(lldb) p **$4</span><br><span class="line">(protocol_list_t) $5 = (count = 1, list = protocol_ref_t [] @ 0x00007fbc7e780c58)</span><br><span class="line">(lldb) p $5.list[0]</span><br><span class="line">(protocol_ref_t) $6 = 4294977080</span><br><span class="line">(lldb) p (protocol_t *)$6</span><br><span class="line">(protocol_t *) $7 = 0x0000000100002638</span><br><span class="line">(lldb) p *$7</span><br><span class="line">(protocol_t) $8 = &#123;</span><br><span class="line">  objc_object = &#123;</span><br><span class="line">    isa = &#123;</span><br><span class="line">      cls = Protocol</span><br><span class="line">      bits = 4302295240</span><br><span class="line">       = &#123;</span><br><span class="line">        nonpointer = 0</span><br><span class="line">        has_assoc = 0</span><br><span class="line">        has_cxx_dtor = 0</span><br><span class="line">        shiftcls = 537786905</span><br><span class="line">        magic = 0</span><br><span class="line">        weakly_referenced = 0</span><br><span class="line">        deallocating = 0</span><br><span class="line">        has_sidetable_rc = 0</span><br><span class="line">        extra_rc = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mangledName = 0x0000000100001f5e &quot;DogProtocol&quot;   //证明协议名称</span><br><span class="line">  protocols = 0x0000000000000000</span><br><span class="line">  instanceMethods = 0x0000000100002320</span><br><span class="line">  classMethods = 0x0000000000000000</span><br><span class="line">  optionalInstanceMethods = 0x0000000100002340</span><br><span class="line">  optionalClassMethods = 0x0000000000000000</span><br><span class="line">  instanceProperties = 0x0000000000000000</span><br><span class="line">  size = 96</span><br><span class="line">  flags = 0</span><br><span class="line">  _extendedMethodTypes = 0x0000000100002360</span><br><span class="line">  _demangledName = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  _classProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $8.instanceMethods  //打印实例方法</span><br><span class="line">(method_list_t *) $9 = 0x0000000100002320</span><br><span class="line">(lldb) p $9-&gt;get(0)</span><br><span class="line">(method_t) $10 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $11 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 1</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从打印记录可以看到，SampleClass 含有的协议是”DogProtocol”<br>协议含有的实例方法列表 只有required方法<br>如果将DogProtocol协议中的@optional申明注释，打印协议里面的实例方法</p><h2 id="required申明方法"><a href="#required申明方法" class="headerlink" title="required申明方法"></a>required申明方法</h2><p>可以看到协议的实例方法列表含有两个方法,分别是printName和printAge，都是@required申明的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *$7</span><br><span class="line">(protocol_t) $8 = &#123;</span><br><span class="line">  objc_object = &#123;</span><br><span class="line">    isa = &#123;</span><br><span class="line">      cls = Protocol</span><br><span class="line">      bits = 4302295240</span><br><span class="line">       = &#123;</span><br><span class="line">        nonpointer = 0</span><br><span class="line">        has_assoc = 0</span><br><span class="line">        has_cxx_dtor = 0</span><br><span class="line">        shiftcls = 537786905</span><br><span class="line">        magic = 0</span><br><span class="line">        weakly_referenced = 0</span><br><span class="line">        deallocating = 0</span><br><span class="line">        has_sidetable_rc = 0</span><br><span class="line">        extra_rc = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mangledName = 0x0000000100001f5e &quot;DogProtocol&quot;</span><br><span class="line">  protocols = 0x0000000000000000</span><br><span class="line">  instanceMethods = 0x0000000100002320</span><br><span class="line">  classMethods = 0x0000000000000000</span><br><span class="line">  optionalInstanceMethods = 0x0000000000000000</span><br><span class="line">  optionalClassMethods = 0x0000000000000000</span><br><span class="line">  instanceProperties = 0x0000000000000000</span><br><span class="line">  size = 96</span><br><span class="line">  flags = 0</span><br><span class="line">  _extendedMethodTypes = 0x0000000100002358</span><br><span class="line">  _demangledName = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  _classProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $8.instanceMethods()</span><br><span class="line">error: called object type &apos;method_list_t *&apos; is not a function or function pointer</span><br><span class="line">(lldb) p $8.instanceMethods</span><br><span class="line">(method_list_t *) $9 = 0x0000000100002320</span><br><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $10 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 2</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(0)</span><br><span class="line">(method_t) $11 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10-&gt;get(1)</span><br><span class="line">(method_t) $12 = &#123;</span><br><span class="line">  name = &quot;printAge&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="默认不申明"><a href="#默认不申明" class="headerlink" title="默认不申明"></a>默认不申明</h2><p>打印说明默认的就是required<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $10 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 2</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(0)</span><br><span class="line">(method_t) $11 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(1)</span><br><span class="line">(method_t) $12 = &#123;</span><br><span class="line">  name = &quot;printAge&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="将方法都申明为optional"><a href="#将方法都申明为optional" class="headerlink" title="将方法都申明为optional"></a>将方法都申明为optional</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@protocol DogProtocol</span><br><span class="line">@optional</span><br><span class="line">- (void)printName;</span><br><span class="line">- (void)printAge;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>打印,可以看到协议的实例方法为空，但是optionalInstanceMethods有两个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)0x100002608</span><br><span class="line">(objc_class *) $0 = 0x0000000100002608</span><br><span class="line">(lldb) p (class_data_bits_t *)0x0000000100002628</span><br><span class="line">(class_data_bits_t *) $1 = 0x0000000100002628</span><br><span class="line">(lldb) p (class_rw_t *)$1-&gt;data()</span><br><span class="line">(class_rw_t *) $2 = 0x0000000100b909a0</span><br><span class="line">(lldb) p $2-&gt;protocols</span><br><span class="line">(protocol_array_t) $3 = &#123;</span><br><span class="line">  list_array_tt&lt;unsigned long, protocol_list_t&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = 0x0000000100002368</span><br><span class="line">      arrayAndFlag = 4294976360</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $3.beginLists()</span><br><span class="line">(protocol_list_t **) $4 = 0x0000000100b909c0</span><br><span class="line">(lldb) p $5.list[0]</span><br><span class="line">error: use of undeclared identifier &apos;$5&apos;</span><br><span class="line">(lldb) p **$4</span><br><span class="line">(protocol_list_t) $5 = (count = 1, list = protocol_ref_t [] @ 0x00007fbc7e1dad48)</span><br><span class="line">(lldb) p $5.list[0]</span><br><span class="line">(protocol_ref_t) $6 = 4294977072</span><br><span class="line">(lldb) p (protocol_t *)$6</span><br><span class="line">(protocol_t *) $7 = 0x0000000100002630</span><br><span class="line">(lldb) p *$7</span><br><span class="line">(protocol_t) $8 = &#123;</span><br><span class="line">  objc_object = &#123;</span><br><span class="line">    isa = &#123;</span><br><span class="line">      cls = Protocol</span><br><span class="line">      bits = 4302295240</span><br><span class="line">       = &#123;</span><br><span class="line">        nonpointer = 0</span><br><span class="line">        has_assoc = 0</span><br><span class="line">        has_cxx_dtor = 0</span><br><span class="line">        shiftcls = 537786905</span><br><span class="line">        magic = 0</span><br><span class="line">        weakly_referenced = 0</span><br><span class="line">        deallocating = 0</span><br><span class="line">        has_sidetable_rc = 0</span><br><span class="line">        extra_rc = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mangledName = 0x0000000100001f5e &quot;DogProtocol&quot;</span><br><span class="line">  protocols = 0x0000000000000000</span><br><span class="line">  instanceMethods = 0x0000000000000000</span><br><span class="line">  classMethods = 0x0000000000000000</span><br><span class="line">  optionalInstanceMethods = 0x0000000100002320</span><br><span class="line">  optionalClassMethods = 0x0000000000000000</span><br><span class="line">  instanceProperties = 0x0000000000000000</span><br><span class="line">  size = 96</span><br><span class="line">  flags = 0</span><br><span class="line">  _extendedMethodTypes = 0x0000000100002358</span><br><span class="line">  _demangledName = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  _classProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $8.optionalInstanceMethods</span><br><span class="line">(method_list_t *) $9 = 0x0000000100002320</span><br><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $10 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 2</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(0)</span><br><span class="line">(method_t) $11 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(1)</span><br><span class="line">(method_t) $12 = &#123;</span><br><span class="line">  name = &quot;printAge&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Objc category篇</title>
    <link href="https://pattyxp.github.io/2018/02/11/Objc-category%E7%AF%87/"/>
    <id>https://pattyxp.github.io/2018/02/11/Objc-category篇/</id>
    <published>2018-02-11T03:05:02.000Z</published>
    <updated>2018-02-12T03:15:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章中，分析load有提到对category中的load方法进行存储调用<br>现在我们来窥探一下category的作用</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>category主要用于动态的为类添加一些方法和属性<br>在OC中，catefory是在运行期决议的。当编译完成,对象的内存布局已经确定，我们无法为类添加实例变量，通过category,可以设置关联对象，为类动态添加属性,也可以添加方法</p><p>注:<br>extension它是在编译期，和类的.h和.m构成类的结构，可以添加实例变量，一般用于隐藏类的私有属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Category</span><br><span class="line">@interface PattyDog (Category)</span><br><span class="line">// 只会生成set,get方法的声明,创建的对象没有name属性.</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Extension(类扩展)</span><br><span class="line">@interface PattyDog</span><br><span class="line">// 创建name成员变量,并声明和实现set,get方法</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>在objc-runtime-new.h中,申明了category的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct category_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    struct method_list_t *instanceMethods;</span><br><span class="line">    struct method_list_t *classMethods;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    struct property_list_t *instanceProperties;</span><br><span class="line">    // Fields below this point are not always present on disk.</span><br><span class="line">    struct property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *methodsForMeta(bool isMeta) &#123;</span><br><span class="line">        if (isMeta) return classMethods;</span><br><span class="line">        else return instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>从上面可以了解到，category包含了</p><ul><li>类的名字</li><li>类</li><li>给类添加的  实例方法列表</li><li>给类添加的  类方法列表</li><li>给类添加的  协议列表</li><li>给类添加的  属性列表</li><li>给类添加的  类属性列表</li></ul><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Dog.h</span><br><span class="line">@interface Dog: NSObject</span><br><span class="line">- (void)printName;</span><br><span class="line">@end</span><br><span class="line">@interface Dog (Patty)</span><br><span class="line">@property(nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//Dog.m</span><br><span class="line">@implementation Dog</span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;CommonDog&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Dog(Patty)</span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;PattyDog&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>下面将Dog.m文件进行clang编译，看下编译之后有哪些改动，以下是主要的变化</p><ul><li>category_t 结构体含有实例方法_CATEGORY_INSTANCE_METHODS<em>Dog</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Dog_$_Patty,</span><br><span class="line"></span><br><span class="line">具体实现存储的方法只有一个，方法名称是printName，方法编码，函数地址都存储在里面</span><br><span class="line">__attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line"> sizeof(_objc_method),</span><br><span class="line"> 1,</span><br><span class="line"> &#123;&#123;(struct objc_selector *)&quot;printName&quot;, &quot;v16@0:8&quot;, (void *)_I_Dog_Patty_printName&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">static __NSConstantStringImpl __NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_0 __attribute__ ((section (&quot;__DATA, __cfstring&quot;))) = &#123;__CFConstantStringClassReference,0x000007c8,&quot;CommonDog&quot;,9&#125;;</span><br><span class="line">static __NSConstantStringImpl __NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_1 __attribute__ ((section (&quot;__DATA, __cfstring&quot;))) = &#123;__CFConstantStringClassReference,0x000007c8,&quot;PattyDog&quot;,8&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// @implementation Dog</span><br><span class="line"></span><br><span class="line">static void _I_Dog_printName(Dog * self, SEL _cmd) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_0);</span><br><span class="line">&#125;</span><br><span class="line">// @end</span><br><span class="line">// @implementation Dog(Patty)</span><br><span class="line"></span><br><span class="line">static void _I_Dog_Patty_printName(Dog * self, SEL _cmd) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_1);</span><br><span class="line">&#125;</span><br><span class="line">// @end</span><br><span class="line"></span><br><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Dog_$_Patty __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">1,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;printName&quot;, &quot;v16@0:8&quot;, (void *)_I_Dog_Patty_printName&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_Dog;</span><br><span class="line"></span><br><span class="line">static struct _category_t _OBJC_$_CATEGORY_Dog_$_Patty __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) =</span><br><span class="line">&#123;</span><br><span class="line">&quot;Dog&quot;,</span><br><span class="line">0, // &amp;OBJC_CLASS_$_Dog,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Dog_$_Patty,</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">&#125;;</span><br><span class="line">static void OBJC_CATEGORY_SETUP_$_Dog_$_Patty(void ) &#123;</span><br><span class="line">_OBJC_$_CATEGORY_Dog_$_Patty.cls = &amp;OBJC_CLASS_$_Dog;</span><br><span class="line">&#125;</span><br><span class="line">#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)</span><br><span class="line">__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">(void *)&amp;OBJC_CATEGORY_SETUP_$_Dog_$_Patty,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;OBJC_CLASS_$_Dog,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;_OBJC_$_CATEGORY_Dog_$_Patty,</span><br><span class="line">&#125;;</span><br><span class="line">static struct IMAGE_INFO &#123; unsigned version; unsigned flag; &#125; _OBJC_IMAGE_INFO = &#123; 0, 2 &#125;;</span><br></pre></td></tr></table></figure><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>category是由OC动态加载（runtime）,多个category的调用顺序是无法保证的，<br>一般来说category内的方法需要添加前缀可避免重复添加导致编译出错<br>OC的运行入口，在objc-os.mm内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized = false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized = true;</span><br><span class="line"></span><br><span class="line">    // fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_2_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过上面的方法，在map_2_images函数里面进入加载images,最终调用到_read_images方法</p><ul><li>获取OC的category列表catlist</li><li>然后remapClass</li><li>如果category含有实例方法，协议或者属性列表，添加到类上</li><li>如果category含有类方法列表，协议,添加到类的metaclass上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">// Discover categories.</span><br><span class="line">    for (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist =</span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);//从表中取出cat对应的cls</span><br><span class="line"></span><br><span class="line">            if (!cls) &#123;</span><br><span class="line">                // Category&apos;s target class is missing (probably weak-linked).</span><br><span class="line">                // Disavow any knowledge of this category.</span><br><span class="line">                catlist[i] = nil;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span><br><span class="line">                                 &quot;missing weak-linked target class&quot;,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bool classExists = NO;</span><br><span class="line">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties)</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                if (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,</span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name,</span><br><span class="line">                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                if (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,</span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>绑定category的方法、协议等映射到类上，内部调用方法addUnattachedCategoryForClass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void addUnattachedCategoryForClass(category_t *cat, Class cls,</span><br><span class="line">                                          header_info *catHeader)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    // DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead</span><br><span class="line">    NXMapTable *cats = unattachedCategories();  //初始化NXMapTable</span><br><span class="line">    category_list *list;</span><br><span class="line"></span><br><span class="line">    list = (category_list *)NXMapGet(cats, cls);//去Table表中查找对应cls的category列表</span><br><span class="line">    if (!list) &#123;</span><br><span class="line">        list = (category_list *)</span><br><span class="line">            calloc(sizeof(*list) + sizeof(list-&gt;list[0]), 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        list = (category_list *)</span><br><span class="line">            realloc(list, sizeof(*list) + sizeof(list-&gt;list[0]) * (list-&gt;count + 1));</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;list[list-&gt;count++] = (locstamped_category_t)&#123;cat, catHeader&#125;;//扩大list</span><br><span class="line">    NXMapInsert(cats, cls, list); //将cls对应的list插入到表中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>remethodizeClass 将cat一系列方法添加到类上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">static void remethodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // Re-methodizing: check for more categories</span><br><span class="line">    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        attachCategories(cls, cats, true /*flush caches*/);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // fixme rearrange to remove these intermediate allocations</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int propcount = 0;</span><br><span class="line">    int protocount = 0;</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    bool fromBundle = NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        property_list_t *proplist =</span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键在attachLists方法，将cls的rw对应的方法列表，属性列表，协议列表进行添加列表</p><ul><li>memmove<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">       if (addedCount == 0) return;</span><br><span class="line"></span><br><span class="line">       if (hasArray()) &#123;</span><br><span class="line">           // many lists -&gt; many lists</span><br><span class="line">           uint32_t oldCount = array()-&gt;count;</span><br><span class="line">           uint32_t newCount = oldCount + addedCount;</span><br><span class="line">           setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">           array()-&gt;count = newCount;</span><br><span class="line">           memmove(array()-&gt;lists + addedCount, array()-&gt;lists,</span><br><span class="line">                   oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">           memcpy(array()-&gt;lists, addedLists,</span><br><span class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">       &#125;</span><br><span class="line">       else if (!list  &amp;&amp;  addedCount == 1) &#123;</span><br><span class="line">           // 0 lists -&gt; 1 list</span><br><span class="line">           list = addedLists[0];</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123;</span><br><span class="line">           // 1 list -&gt; many lists</span><br><span class="line">           List* oldList = list;</span><br><span class="line">           uint32_t oldCount = oldList ? 1 : 0;</span><br><span class="line">           uint32_t newCount = oldCount + addedCount;</span><br><span class="line">           setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">           array()-&gt;count = newCount;</span><br><span class="line">           if (oldList) array()-&gt;lists[addedCount] = oldList;</span><br><span class="line">           memcpy(array()-&gt;lists, addedLists,</span><br><span class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>memmove和memcpy 两个C函数的操作，<br>将array先前的列表内容拷贝到新数组的末尾，然后将新添加的list插入到新数组的头部<br>解释了category的特性</p><ul><li>category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加方法后，类的方法列表里会有两个methodA</li><li>category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，也就是我们常说category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会停止查找，殊不知后面可能还有一样名字的方法。</li><li>category关联对象特性在之前文章中，请自行翻阅</li></ul><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>memmove(p2, p1, len) 内存拷贝<br>将p1的前面len长度的字符，拷贝到p2</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li>c函数 memmove和memcpy的区别 <a href="http://blog.jobbole.com/108842/" target="_blank" rel="noopener">http://blog.jobbole.com/108842/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在之前的文章中，分析load有提到对category中的load方法进行存储调用&lt;br&gt;现在我们来窥探一下category的作用&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Objc关联对象的实现</title>
    <link href="https://pattyxp.github.io/2018/02/03/Objc%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://pattyxp.github.io/2018/02/03/Objc关联对象的实现/</id>
    <published>2018-02-03T07:36:52.000Z</published>
    <updated>2018-02-11T03:06:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天主要来聊一聊以下三个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void *key) &#123;</span><br><span class="line">    return _object_get_associative_reference(object, (void *)key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">    _object_set_associative_reference(object, (void *)key, value, policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void objc_removeAssociatedObjects(id object)</span><br><span class="line">&#123;</span><br><span class="line">    if (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        _object_remove_assocations(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分类添加属性的时候，由于系统没有办法自动将属性添加set和get方法，需要自动实现，就需要以上的方法来实现</p><h2 id="事例code"><a href="#事例code" class="headerlink" title="事例code"></a>事例code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@interface Dog: NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation Dog</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Dog(DanceCategory)</span><br><span class="line">@property (nonatomic, strong) NSString *categoryProperty;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog(DanceCategory)</span><br><span class="line">- (NSString *)categoryProperty</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">- (void)setCategoryProperty:(NSString *)categoryProperty</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(categoryProperty), categoryProperty, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark -main</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Dog *dd = [[Dog alloc] init];</span><br><span class="line">        dd.categoryProperty = @&quot;分类属性&quot;;</span><br><span class="line">        dd.categoryProperty;</span><br><span class="line">        objc_removeAssociatedObjects(dd);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>先看下设置属性的方法调用顺序<br><img src="/images/分类属性-调用堆栈.png" alt="调用堆栈.png"></p><h3 id="object-set-associative-reference"><a href="#object-set-associative-reference" class="headerlink" title="object_set_associative_reference"></a>object_set_associative_reference</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line"></span><br><span class="line">    ObjcAssociation old_association(0, nil); //生成旧对象</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;  </span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i != associations.end()) &#123;</span><br><span class="line">                // secondary table exists</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second; //如果存在之前的值，给旧对象赋值</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // create the new association (first time).</span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // setting the association to nil breaks the association.</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果旧对象有值，进行释放</span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上主要操作:</p><ul><li>初始生成old_association，便于存储旧对象以及清除旧值</li><li>acquireValue 方法内部是对value进行copy或者retain</li><li>生成唯一的AssociationsManager 和 AssociationsHashMap</li><li>disguised_object 是根据object生成的，下面需要根据newValue的值是否为空来处理两种情况</li></ul><ol><li><p>newValue 存在</p><ul><li>在AssociationsHashMap中根据disguised_object作为key去取对应的object的AssociationsHashMap</li><li><p>如果map存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectAssociationMap *refs = i-&gt;second</span><br><span class="line">ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">if (j != refs-&gt;end()) &#123; //如果存在旧值，将旧值赋值给old_association</span><br><span class="line">    old_association = j-&gt;second;</span><br><span class="line">    j-&gt;second = ObjcAssociation(policy, new_value);//然后重新赋值</span><br><span class="line">&#125; else &#123; //如果不存在旧值，给map表设置key和value</span><br><span class="line">    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果map不存在，新生成ObjectAssociationMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAssociationMap *refs = new ObjectAssociationMap; //新生成ObjectAssociationMap</span><br><span class="line">associations[disguised_object] = refs; //将disguised_object作为key ,value是ObjectAssociationMap</span><br><span class="line">(*refs)[key] = ObjcAssociation(policy, new_value) //在ObjectAssociationMap中插入key和对应的ObjcAssociation</span><br><span class="line">object-&gt;setHasAssociatedObjects();//标记对象对应的标记位</span><br></pre></td></tr></table></figure></li></ul></li><li><p>newValue 为空 说明需要将对应的map表移除</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">if (i !=  associations.end()) &#123; //如果存在该object对应的map表，</span><br><span class="line">    ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">    ObjectAssociationMap::iterator j = refs-&gt;find(key); //从ObjectAssociationMap表中取出对应的key所对应的association</span><br><span class="line">    if (j != refs-&gt;end()) &#123;</span><br><span class="line">        old_association = j-&gt;second; //将存在的值赋值给old_association</span><br><span class="line">        refs-&gt;erase(j); //从表中将key对应的ObjcAssociation进行擦除</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>最后 如果存在旧值，将旧值释放即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (old_association.hasValue()) ReleaseValue()(old_association);</span><br></pre></td></tr></table></figure></li></ul><h3 id="object-get-associative-reference"><a href="#object-get-associative-reference" class="headerlink" title="object_get_associative_reference"></a>object_get_associative_reference</h3><p><img src="/images/分类属性-get.png" alt="getAssociation堆栈图"><br>上图是调用对象属性的get方法执行的堆栈结构图</p><p>流程比上面的方法相对简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id _object_get_associative_reference(id object, void *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object); //从AssociationsHashMap表中查找对象</span><br><span class="line">        if (i != associations.end()) &#123; //如果存在对象的话</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key); //从对象对应的ObjectAssociationMap表中根据key取出对应的value</span><br><span class="line">            if (j != refs-&gt;end()) &#123; //如果存在value</span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.value(); //将存在的ObjcAssociation属性对应赋值</span><br><span class="line">                policy = entry.policy();</span><br><span class="line">                if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);   //对value进行retain</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);</span><br><span class="line">    &#125;</span><br><span class="line">    return value; //最后将关联对象 ObjcAssociation 的值进行返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="objc-removeAssociatedObjects"><a href="#objc-removeAssociatedObjects" class="headerlink" title="objc_removeAssociatedObjects"></a>objc_removeAssociatedObjects</h2><p>先来看下调用remove方法的函数调用<br><img src="/images/分类属性-remove.png" alt="remove"><br>打印isa的结构，可以看到对象的has_assoc 标记为1，也就是存在关联对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void _object_remove_assocations(id object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        if (associations.size() == 0) return; //如果不存在 返回</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object); //查找object对应的表</span><br><span class="line">        if (i != associations.end()) &#123;</span><br><span class="line">            // copy all of the associations that need to be removed.</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second; //存在的话取出对应的object表</span><br><span class="line">            for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);//将表的元素存入elements</span><br><span class="line">            &#125;</span><br><span class="line">            delete refs; //移除object对应的表</span><br><span class="line">            associations.erase(i); //同时在AssociationsHashMap表中将object也移除</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // the calls to releaseValue() happen outside of the lock.</span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue()); //通过循环将elements元素都进行释放</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文就是对于如何给分类添加属性操作进行解读</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天主要来聊一聊以下三个方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://pattyxp.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>KVO 实现原理分析</title>
    <link href="https://pattyxp.github.io/2018/02/02/KVO-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://pattyxp.github.io/2018/02/02/KVO-实现原理分析/</id>
    <published>2018-02-02T03:59:38.000Z</published>
    <updated>2018-02-02T05:11:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前，一直以为类的isa结构图就是那张很经典的图，但是才发现有个特例情况下，有点变化</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  PattyCat *pcat = [[PattyCat alloc] init];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   NSLog(@&quot;%p--pcat的isa:%p--%@-%@-%@&quot;,(object_getClass([PattyCat class])),object_getClass(pcat),object_getClass(pcat),pcat.superclass,[object_getClass(pcat) superclass]);</span><br><span class="line">   /*</span><br><span class="line">    0x10408c910--pcat的isa:0x10408c870--PattyCat-Cat-Cat</span><br><span class="line">    */</span><br><span class="line">   [pcat addObserver:self</span><br><span class="line">         forKeyPath:@&quot;address&quot;</span><br><span class="line">         options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld</span><br><span class="line">         context:nil];</span><br><span class="line">   pcat.address = @&quot;有地址了&quot;;</span><br><span class="line">//    NSLog(@&quot;%@--%p&quot;,(object_getClass([PattyCat class])),object_getClass(pcat));</span><br><span class="line"></span><br><span class="line">   NSLog(@&quot;%p---pcat的isa:%p-新的子类是:%@-新的子类的isa:%p-%@-%@&quot;,(object_getClass([PattyCat class])),object_getClass(pcat),object_getClass(pcat),object_getClass(object_getClass(pcat)),pcat.superclass,[object_getClass(pcat) superclass]);</span><br><span class="line">   /*</span><br><span class="line">    0x10408c910---pcat的isa:0x7b24000260a0-新的子类是:NSKVONotifying_PattyCat-新的子类的isa:0x7b2400026130-Cat-PattyCat</span><br><span class="line">    */</span><br><span class="line">   [pcat removeObserver:self forKeyPath:@&quot;address&quot;];</span><br><span class="line"></span><br><span class="line">  NSLog(@&quot;%p--pcat的isa:%p--%@-%@-%@&quot;,(object_getClass([PattyCat class])),object_getClass(pcat),object_getClass(pcat),pcat.superclass,[object_getClass(pcat) superclass]);</span><br><span class="line">   /*</span><br><span class="line">    0x10408c910--pcat的isa:0x10408c870--PattyCat-Cat-Cat</span><br><span class="line">    */</span><br></pre></td></tr></table></figure><p>在当前类中引入对象pcat,监听它的KVO变化之后，然后移除KVO，对象的isa以及superClass前后的变化如上</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>苹果文档介绍</p><blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class ..</p></blockquote><p>简要的来说，在我们对某个对象完成监听的注册后，编译器会修改监听对象（上文中的pcat）的isa指针，让这个指针指向一个新生成的中间类，中间类的命名格式如 NSKVONotifying_XX (XX 是pcat对象的class)</p><p>苹果还 <strong>重写了这个子类的class方法跟description方法</strong> 来掩人耳目。<br>另外，新类相对于父类添加了一个NSKVONotifying_前缀，添加这个前缀是为了避免多次创建监听子类，节省资源</p><p>以上通过object_getClass(pcat)命令得到了KVO前为PattyCat   KVO后值为 NSKVONotifying_PattyCat</p><p>注: 以下两个方式得到类的指针是一样的哦<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p object_getClass(pcat)</span><br><span class="line">(Class) $0 = PattyCat</span><br><span class="line">(lldb) p (void *)$0</span><br><span class="line">(void *) $1 = 0x0000000100001188</span><br><span class="line"></span><br><span class="line">(lldb) p (objc_class *)[PattyCat class]</span><br><span class="line">(objc_class *) $2 = 0x0000000100001188</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对实例对象进行KVO观察的时候，实际上对象的isa已经不是之前的类对象了<br>移除KVO之后，恢复之前效果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在之前，一直以为类的isa结构图就是那张很经典的图，但是才发现有个特例情况下，有点变化&lt;/p&gt;
&lt;h2 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code&quot;&gt;&lt;/a&gt;code&lt;/h2&gt;&lt;figure class=
      
    
    </summary>
    
    
      <category term="原理" scheme="https://pattyxp.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Objc中的属性</title>
    <link href="https://pattyxp.github.io/2018/01/31/Objc%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7/"/>
    <id>https://pattyxp.github.io/2018/01/31/Objc中的属性/</id>
    <published>2018-01-31T06:58:14.000Z</published>
    <updated>2018-02-11T03:01:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础OC源码与clang编译"><a href="#基础OC源码与clang编译" class="headerlink" title="基础OC源码与clang编译"></a>基础OC源码与clang编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Dog: NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *sex;</span><br><span class="line">@property (nonatomic, copy) NSString *address;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation Dog</span><br><span class="line">&#123;</span><br><span class="line">    NSString * _name;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark -main</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过clang重写为cpp之后，文件主要的内容截取查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _REWRITER_typedef_Dog</span><br><span class="line">#define _REWRITER_typedef_Dog</span><br><span class="line">typedef struct objc_object Dog;</span><br><span class="line">typedef struct &#123;&#125; _objc_exc_Dog;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; unsigned long OBJC_IVAR_$_Dog$_sex;</span><br><span class="line">extern &quot;C&quot; unsigned long OBJC_IVAR_$_Dog$_address;</span><br><span class="line">struct Dog_IMPL &#123;</span><br><span class="line">struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">NSString *_name;</span><br><span class="line">NSString *_sex;</span><br><span class="line">NSString *_address;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// @property (nonatomic, copy) NSString *sex;</span><br><span class="line">// @property (nonatomic, copy) NSString *address;</span><br><span class="line">/* @end */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/** implementation Dog</span><br><span class="line">&#123;</span><br><span class="line">    NSString * _name;</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">static NSString * _I_Dog_sex(Dog * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Dog$_sex)); &#125;</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_setProperty (id, SEL, long, id, bool, bool);</span><br><span class="line"></span><br><span class="line">static void _I_Dog_setSex_(Dog * self, SEL _cmd, NSString *sex) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Dog, _sex), (id)sex, 0, 1); &#125;</span><br><span class="line"></span><br><span class="line">static NSString * _I_Dog_address(Dog * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Dog$_address)); &#125;</span><br><span class="line">static void _I_Dog_setAddress_(Dog * self, SEL _cmd, NSString *address) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Dog, _address), (id)address, 0, 1); &#125;</span><br><span class="line">// @end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Dog_IMPL 结构体含有三个实例变量，其中两个是系统为property生成的，一个是自身的ivar<br>Dog实现 系统自动生成property对应的set和get方法</p><p>对源码修改，添加如下code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@synthesize address = _name;</span><br></pre></td></tr></table></figure></p><p>clang编译之后，两份.cpp文件对比</p><p><img src="/images/cpp对比图.png" alt="cpp对比图"></p><p>以下是两份对比内容的源码</p><ul><li><p>当前添加code之后的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; unsigned long OBJC_IVAR_$_Dog$_name;</span><br><span class="line">// @synthesize address = _name;</span><br><span class="line">static NSString * _I_Dog_address(Dog * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Dog$_name)); &#125;</span><br><span class="line">static void _I_Dog_setAddress_(Dog * self, SEL _cmd, NSString *address) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Dog, _name), (id)address, 0, 1); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static NSString * _I_Dog_sex(Dog * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Dog$_sex)); &#125;</span><br><span class="line">struct _ivar_t ivar_list[2];</span><br><span class="line">2,</span><br><span class="line"> &#123;(unsigned long int *)&amp;OBJC_IVAR_$_Dog$_sex, &quot;_sex&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;&#125;</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;address&quot;, &quot;@16@0:8&quot;, (void *)_I_Dog_address&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;setAddress:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Dog_setAddress_&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;sex&quot;, &quot;@16@0:8&quot;, (void *)_I_Dog_sex&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;setSex:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Dog_setSex_&#125;&#125;</span><br><span class="line">&#123;&quot;address&quot;,&quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>未修改内容的cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; unsigned long OBJC_IVAR_$_Dog$_address;</span><br><span class="line">NSString *_address;</span><br><span class="line"></span><br><span class="line">static NSString * _I_Dog_sex(Dog * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Dog$_sex)); &#125;</span><br><span class="line"></span><br><span class="line">static NSString * _I_Dog_address(Dog * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Dog$_address)); &#125;</span><br><span class="line">static void _I_Dog_setAddress_(Dog * self, SEL _cmd, NSString *address) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Dog, _address), (id)address, 0, 1); &#125;</span><br><span class="line">extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Dog$_address __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Dog, _address);</span><br><span class="line">struct _ivar_t ivar_list[3];</span><br><span class="line">3,</span><br><span class="line"> &#123;(unsigned long int *)&amp;OBJC_IVAR_$_Dog$_sex, &quot;_sex&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;,</span><br><span class="line"> &#123;(unsigned long int *)&amp;OBJC_IVAR_$_Dog$_address, &quot;_address&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;&#125;</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;sex&quot;, &quot;@16@0:8&quot;, (void *)_I_Dog_sex&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;setSex:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Dog_setSex_&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;address&quot;, &quot;@16@0:8&quot;, (void *)_I_Dog_address&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;setAddress:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Dog_setAddress_&#125;&#125;</span><br><span class="line">&#123;&quot;address&quot;,&quot;T@\&quot;NSString\&quot;,C,N,V_address&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>对比之后可以发现，当重写@synthesize方法, 自定义绑定属性<br>将属性和已经存在的成员变量进行绑定，编译器没有自动生成_address，在类中找不到这个变量的存在<br>所以当我们使用_address的时候，就会报错</p><p>有了getter和setter，方便获取属性，从某个意义上 属性更加面向对象</p><h3 id="查看系统为Dog类生成的实例变量"><a href="#查看系统为Dog类生成的实例变量" class="headerlink" title="查看系统为Dog类生成的实例变量"></a>查看系统为Dog类生成的实例变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@interface Dog: NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *sex;</span><br><span class="line">@property (nonatomic, copy) NSString *address;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog</span><br><span class="line">&#123;</span><br><span class="line">    NSString * _name;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark -main</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        unsigned int ivarCount = 0;</span><br><span class="line">        Ivar * ivars =  class_copyIvarList([Dog class], &amp;ivarCount);</span><br><span class="line">        NSLog(@&quot;=======&quot;);</span><br><span class="line">        for (unsigned int idx = 0; idx &lt; ivarCount; idx++) &#123;</span><br><span class="line">            Ivar ivar = ivars[idx];</span><br><span class="line">            NSLog(@&quot;%s&quot;, ivar_getName(ivar));</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivars);</span><br><span class="line"></span><br><span class="line">        unsigned int propertyCount;</span><br><span class="line">        objc_property_t * properties = class_copyPropertyList([Dog class], &amp;propertyCount);</span><br><span class="line">        NSLog(@&quot;=======&quot;);</span><br><span class="line">        for (unsigned int idx = 0; idx &lt; ivarCount; idx++) &#123;</span><br><span class="line">            objc_property_t property = properties[idx];</span><br><span class="line">            NSLog(@&quot;attribute:%s&quot;,property_getAttributes(property));</span><br><span class="line">        &#125;</span><br><span class="line">        free(properties);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印输出:</span><br><span class="line">_name _sex _address</span><br><span class="line"> attribute:T@&quot;NSString&quot;,C,N,V_sex</span><br><span class="line"> attribute:T@&quot;NSString&quot;,C,N,V_name</span><br></pre></td></tr></table></figure><ul><li>属性说明<br>使用property_getAttributes获得的描述是property_copyAttributeList<br>能获取到的所有的name和value的总体描述，<br>如 T@”NSDictionary”,C,N,V_dict1</li></ul><p>常用的属性如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">属性类型  name值：T  value：变化</span><br><span class="line">编码类型  name值：C(copy) &amp;(strong) W(weak) 空(assign) 等 value：无</span><br><span class="line">非/原子性 name值：空(atomic) N(Nonatomic)  value：无</span><br><span class="line">变量名称  name值：V  value：变化</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OC 属性和实例变量是存在区别的</p><p>实例变量，不会自动生成对应的getter和setter方法<br>属性，系统自动生成对应的getter和setter方法</p><p>相比起变量，在编译期间，编译器做了很多工作，包括这些：</p><ul><li>使用@synthesize生成属性对应的ivar，通常ivar命名为下划线+属性名</li><li>生成setter方法来设置ivar</li><li>生成getter方法来获取ivar</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础OC源码与clang编译&quot;&gt;&lt;a href=&quot;#基础OC源码与clang编译&quot; class=&quot;headerlink&quot; title=&quot;基础OC源码与clang编译&quot;&gt;&lt;/a&gt;基础OC源码与clang编译&lt;/h3&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Objc消息的缓存</title>
    <link href="https://pattyxp.github.io/2018/01/30/Objc%E6%B6%88%E6%81%AF%E7%9A%84%E7%BC%93%E5%AD%98/"/>
    <id>https://pattyxp.github.io/2018/01/30/Objc消息的缓存/</id>
    <published>2018-01-30T06:30:00.000Z</published>
    <updated>2018-01-31T06:03:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>先来看下class对象的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p><p>存在了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct objc_cache *cache</span><br></pre></td></tr></table></figure></p><p>类型的方法缓存结构，objc_cache是一个结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct objc_cache &#123;</span><br><span class="line">    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;</span><br><span class="line">    unsigned int occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[1]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>mask表示当前能达到的最大index,从0开始，所以总是是mask+1</li><li>occupied 当前被占用的位置数量</li><li>buckets 数组表示的hash表，数组的每一项都代表的是方法，<br>类型是Method，Method的结构是objc_method,<br>里面存储了方法的method_name,method_types,method_imp<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method;</span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></li></ul><p>每个类都存在objc_cache的结构体缓存方法列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PattyCat *pcat = [PattyCat alloc];</span><br><span class="line">[pcat init];</span><br><span class="line"></span><br><span class="line">[pcat class];</span><br></pre></td></tr></table></figure><p>所以在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[pcat class]</span><br></pre></td></tr></table></figure></p><p>处打上断点,在lookUpImpOrForward也打上断点，看看如何查找到父类的class方法流程</p><ul><li>去当前类的缓存cache_getImp查找，找不到去当前类的方法列表里methods.beginLists去查找，</li><li>如果当前类不存在方法，就会通过while循环查找， 先在父类缓存查找方法cache_getImp，找不到就在当前父类的方法列表查找getMethodNoSuper_nolock，如果找不到就往上找，</li><li>直到找到之后，都会缓存该方法实现 log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);缓存在类本身的方法缓存里。</li></ul><p>以上查找流程，当while循环两次之后，当curClass=NSObject,通过getMethodNoSuper_nolock查找到了class这个方法的method,<br><img src="/images/method_cache.png" alt="method缓存图"><br>可以看到class方法的type是 “#16@0:8”</p><p>从下图可以看到如何执行的方法cache，此处将NSObject的-class方法进行缓存<br><img src="/images/method_cache_fill.png" alt="method缓存fill"></p><p>cache_fill_nolock方法主要就是将cls的缓存方法结构体进行修改 bucket-&gt;set(key, imp);<br>如果cache的容量不够，则进行扩展cache-&gt;expand();<br>如果当前占用的数量还在总容量的3/4，则不扩展<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    // Never cache before +initialize is done</span><br><span class="line">    if (!cls-&gt;isInitialized()) return;</span><br><span class="line"></span><br><span class="line">    // Make sure the entry wasn&apos;t added to the cache by some other thread</span><br><span class="line">    // before we grabbed the cacheUpdateLock.</span><br><span class="line">    if (cache_getImp(cls, sel)) return;</span><br><span class="line"></span><br><span class="line">    cache_t *cache = getCache(cls);</span><br><span class="line">    cache_key_t key = getKey(sel);</span><br><span class="line"></span><br><span class="line">    // Use the cache as-is if it is less than 3/4 full</span><br><span class="line">    mask_t newOccupied = cache-&gt;occupied() + 1;</span><br><span class="line">    mask_t capacity = cache-&gt;capacity();</span><br><span class="line">    if (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        // Cache is read-only. Replace it.</span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (newOccupied &lt;= capacity / 4 * 3) &#123;</span><br><span class="line">        // Cache is less than 3/4 full. Use it as-is.</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // Cache is too full. Expand it.</span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Scan for the first unused slot and insert there.</span><br><span class="line">    // There is guaranteed to be an empty slot because the</span><br><span class="line">    // minimum size is 4 and we resized at 3/4 full.</span><br><span class="line">    bucket_t *bucket = cache-&gt;find(key, receiver);</span><br><span class="line">    if (bucket-&gt;key() == 0) cache-&gt;incrementOccupied();</span><br><span class="line">    bucket-&gt;set(key, imp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>bucket设置之后，方法的cache存储结构如下<br><img src="/images/cache_bucket.png" alt="method缓存bucket"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先来看下class对象的结构&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由RACSwizzleClass引发的class思考</title>
    <link href="https://pattyxp.github.io/2018/01/26/%E7%94%B1RACSwizzleClass%E5%BC%95%E5%8F%91%E7%9A%84class%E6%80%9D%E8%80%83/"/>
    <id>https://pattyxp.github.io/2018/01/26/由RACSwizzleClass引发的class思考/</id>
    <published>2018-01-26T09:12:47.000Z</published>
    <updated>2018-01-30T03:08:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前在看ReactiveCocoa的源码时候，看到交换类的class方法，存在些疑惑，记下来以免忘记</p><p>下面是主要的code，两个类，存在继承关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -class</span><br><span class="line">@interface Cat: NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation Cat</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface PattyCat: Cat</span><br><span class="line">@end</span><br><span class="line">@implementation PattyCat</span><br><span class="line">@end</span><br><span class="line">void RACSwizzleGetClass(Class class, Class statedClass) &#123;</span><br><span class="line">    SEL selector = @selector(class);</span><br><span class="line">    Method method = class_getInstanceMethod(class, selector);</span><br><span class="line">    IMP newIMP = imp_implementationWithBlock(^(id self) &#123;</span><br><span class="line">        return statedClass;</span><br><span class="line">    &#125;);</span><br><span class="line">    class_replaceMethod(class, selector, newIMP, method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;%p ---- %p&quot;,[PattyCat class],[Cat class]);</span><br><span class="line">        NSLog(@&quot;%p ---- %p&quot;,[[PattyCat new]class],[[Cat new]class]);</span><br><span class="line"></span><br><span class="line">        RACSwizzleGetClass([PattyCat class],[Cat class]);</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;%p \n %p&quot;,[PattyCat class],[Cat class]);</span><br><span class="line">        NSLog(@&quot;%p ---- %p&quot;,[[PattyCat new]class],[[Cat new]class]);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        RACSwizzleGetClass 方法交换的class之后，</span><br><span class="line">        为什么打印的[PattyCat class]前后没有变化？</span><br><span class="line">        [[PattyCat new]class]变化了，怎么写才会有变化</span><br><span class="line">        */</span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实践<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;%p ---- %p&quot;,[PattyCat class],[Cat class]);</span><br><span class="line">        NSLog(@&quot;%p ---- %p&quot;,[[PattyCat new]class],[[Cat new]class]);</span><br><span class="line"></span><br><span class="line">        IMP pattyCat_Class_IMP_before = [[PattyCat class] methodForSelector:@selector(class)];</span><br><span class="line">        IMP pattyCat_Instance_IMP_before = [[PattyCat new] methodForSelector:@selector(class)];</span><br><span class="line">        IMP pattyCat_MetaClass_IMP_before = [object_getClass([PattyCat class]) methodForSelector:@selector(class)];</span><br><span class="line"></span><br><span class="line">        //第一种情况</span><br><span class="line">       // RACSwizzleGetClass([PattyCat class],[Cat class]);</span><br><span class="line"></span><br><span class="line">        //第二种情况</span><br><span class="line">        id metaClass = object_getClass([PattyCat class]);</span><br><span class="line">        RACSwizzleGetClass(metaClass,[Cat class]);</span><br><span class="line"></span><br><span class="line">        IMP pattyCat_Class_IMP_after = [[PattyCat class] methodForSelector:@selector(class)];</span><br><span class="line">        IMP pattyCat_Instance_IMP_after= [[PattyCat new] methodForSelector:@selector(class)];</span><br><span class="line">        IMP pattyCat_MetaClass_IMP_after = [object_getClass([PattyCat class]) methodForSelector:@selector(class)];</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;%p ---- %p&quot;,[PattyCat class],[Cat class]);</span><br><span class="line">        NSLog(@&quot;%p ---- %p&quot;,[[PattyCat new]class],[[Cat new]class]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 对于第一种情况 RACSwizzleGetClass([PattyCat class],[Cat class]);<br> 打印前后 NSLog(@”%p \n %p”,[PattyCat class],[Cat class]);值没有变化</p><p> 在左侧的结果里，可以看到<br> pattyCat_Class_IMP_before 和 pattyCat_Class_IMP_after 都是一样的结果<br> 但是pattyCat_Instance_IMP_before 和 pattyCat_Instance_IMP_after不一样了</p><p> 说明swizzle交换的是-class方法，<br> 打印[[PattyCat new]class] 和 [[Cat new]class] 结果是一样的</p><p> 原因：<br> RACSwizzleGetClass 的第一个参数 如果是[PattyCat class]，那么<br> 根据 NSObject.mm<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)class &#123;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> [PattyCat class]返回的是PattyCat对象自身，所以<br> class_replaceMethod(class, selector, newIMP, method_getTypeEncoding(method));<br> 这句话是去PattyCat对象的methodList方法列表里去查找class方法，找到的当然是-class，替换为Cat对象</p><p> 对于第二种情况<br> id metaClass = object_getClass([PattyCat class]);<br> RACSwizzleGetClass(metaClass,[Cat class]);<br> 在左侧的结果里，可以看到 imp在前后都是一样的实现<br> 说明交互的是+class</p><p> 打印[PattyCat class]和[Cat class]是一样的了，也就是替换了[PattyCat class]指向<br> 因为第一个参数传递的是元类，也就是获取的是+class，所以打印的时候，[PattyCat class]从patty_meta_class查找方法，<br> 找不到就去super_meta_class查找，直到NSObject_meta_class，查找到替换方法的返回结果，所以获取[PattyCat class]取到的是替换后的结果，打印结果和之前有变化</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><p>-class 和 +class 取值的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PattyCat *pcat = [[PattyCat alloc]init];</span><br></pre></td></tr></table></figure></p><p>[pcat class] 实例对象的class方法，是去PattyCat类查找class,如果没有，就一直去父类找，找到NSObject的-class方法，然后copy缓存一份在PattyCat的类列表里,虽然打印结果是一样的，但是指针地址%p是不一样的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在看ReactiveCocoa的源码时候，看到交换类的class方法，存在些疑惑，记下来以免忘记&lt;/p&gt;
&lt;p&gt;下面是主要的code，两个类，存在继承关系&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa RACDelegateProxy</title>
    <link href="https://pattyxp.github.io/2018/01/18/ReactiveCocoa-RACDelegateProxy/"/>
    <id>https://pattyxp.github.io/2018/01/18/ReactiveCocoa-RACDelegateProxy/</id>
    <published>2018-01-18T05:49:25.000Z</published>
    <updated>2018-01-20T06:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>ReactiveCocoa，将Cocoa世界中的代理，KVO，通知等桥接到了RAC的世界中，就是使用的RACDelegateProxy，通过运行时修改方法的运行机制，下面一起来熟悉下怎么做到的</p><p>使用事例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RACDelegateProxy *delegateProxy = [[RACDelegateProxy alloc]initWithProtocol:@protocol(UITextFieldDelegate)];</span><br><span class="line">   [[delegateProxy rac_signalForSelector:@selector(textFieldShouldReturn:)] subscribeNext:^(RACTuple *args) &#123;</span><br><span class="line">       UITextField *field = [args first];</span><br><span class="line">       [field resignFirstResponder];</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   self.textfield.delegate = (id&lt;UITextFieldDelegate&gt;)delegateProxy;</span><br><span class="line"></span><br><span class="line">   //防止delegateProxy被释放</span><br><span class="line">   objc_setAssociatedObject(self.textfield, _cmd, delegateProxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br></pre></td></tr></table></figure><h2 id="RACDelegateProxy"><a href="#RACDelegateProxy" class="headerlink" title="RACDelegateProxy"></a>RACDelegateProxy</h2><p>RACDelegateProxy 继承自NSObject<br>创建只有一个init方法initWithProtocol传入协议，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithProtocol:(Protocol *)protocol &#123;</span><br><span class="line">NSCParameterAssert(protocol != NULL);</span><br><span class="line"></span><br><span class="line">self = [super init];</span><br><span class="line"></span><br><span class="line">class_addProtocol(self.class, protocol);</span><br><span class="line"></span><br><span class="line">_protocol = protocol;</span><br><span class="line"></span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">给当前对象的类加上protocol</span><br></pre></td></tr></table></figure></p><p>RACDelegateProxy 有一个属性 id rac_proxiedDelegate:如果没有实现signalForSelector，则消息真正转发的代理对象</p><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">[invocation invokeWithTarget:self.rac_proxiedDelegate]; //转发代理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line">  //获取协议必须和非必须的方法描述</span><br><span class="line">struct objc_method_description methodDescription = protocol_getMethodDescription(_protocol, selector, NO, YES);</span><br><span class="line"></span><br><span class="line">if (methodDescription.name == NULL) &#123;</span><br><span class="line">methodDescription = protocol_getMethodDescription(_protocol, selector, YES, YES);</span><br><span class="line">if (methodDescription.name == NULL) return [super methodSignatureForSelector:selector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return [NSMethodSignature signatureWithObjCTypes:methodDescription.types];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark API</span><br><span class="line"></span><br><span class="line">- (RACSignal *)signalForSelector:(SEL)selector &#123;</span><br><span class="line">return [self rac_signalForSelector:selector fromProtocol:_protocol];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSignal *)rac_signalForSelector:(SEL)selector fromProtocol:(Protocol *)protocol &#123;</span><br><span class="line">NSCParameterAssert(selector != NULL);</span><br><span class="line">NSCParameterAssert(protocol != NULL);</span><br><span class="line"></span><br><span class="line">return NSObjectRACSignalForSelector(self, selector, protocol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NSObjectRACSignalForSelector"><a href="#NSObjectRACSignalForSelector" class="headerlink" title="NSObjectRACSignalForSelector"></a>NSObjectRACSignalForSelector</h3><p>方法就是实现消息转发的关键，如何将seletor方法转化为信号RACSignal<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">static RACSignal *NSObjectRACSignalForSelector(NSObject *self, SEL selector, Protocol *protocol) &#123;</span><br><span class="line">SEL aliasSelector = RACAliasForSelector(selector);</span><br><span class="line"></span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);</span><br><span class="line">if (subject != nil) return subject;</span><br><span class="line"></span><br><span class="line">Class class = RACSwizzleClass(self);</span><br><span class="line">NSCAssert(class != nil, @&quot;Could not swizzle class of %@&quot;, self);</span><br><span class="line"></span><br><span class="line">subject = [[RACSubject subject] setNameWithFormat:@&quot;%@ -rac_signalForSelector: %s&quot;, RACDescription(self), sel_getName(selector)];</span><br><span class="line">objc_setAssociatedObject(self, aliasSelector, subject, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line"></span><br><span class="line">[self.rac_deallocDisposable addDisposable:[RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[subject sendCompleted];</span><br><span class="line">&#125;]];</span><br><span class="line"></span><br><span class="line">Method targetMethod = class_getInstanceMethod(class, selector);</span><br><span class="line">if (targetMethod == NULL) &#123; //对不存在该方法，只需要获得方法的类型编码并将实现添加为 _objc_msgForward，交给消息转发流程进行处理即可。</span><br><span class="line">const char *typeEncoding;</span><br><span class="line">if (protocol == NULL) &#123;</span><br><span class="line">typeEncoding = RACSignatureForUndefinedSelector(selector);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        //protocol_getMethodDescription 两次从协议中获取可选和必须实现的方法的描述，并从结构体中拿出类型编码，最后为类添加这个之前不存在的方法：</span><br><span class="line"></span><br><span class="line">if (methodDescription.name == NULL) &#123;</span><br><span class="line">// Then fall back to looking for a required instance method.</span><br><span class="line">methodDescription = protocol_getMethodDescription(protocol, selector, YES, YES);</span><br><span class="line">NSCAssert(methodDescription.name != NULL, @&quot;Selector %@ does not exist in &lt;%s&gt;&quot;, NSStringFromSelector(selector), protocol_getName(protocol));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeEncoding = methodDescription.types;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RACCheckTypeEncoding(typeEncoding);</span><br><span class="line"></span><br><span class="line">// Define the selector to call -forwardInvocation:.</span><br><span class="line">if (!class_addMethod(class, selector, _objc_msgForward, typeEncoding)) &#123;</span><br><span class="line">NSDictionary *userInfo = @&#123;</span><br><span class="line">NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedString(@&quot;A race condition occurred implementing %@ on class %@&quot;, nil), NSStringFromSelector(selector), class],</span><br><span class="line">NSLocalizedRecoverySuggestionErrorKey: NSLocalizedString(@&quot;Invoke -rac_signalForSelector: again to override the implementation.&quot;, nil)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">return [RACSignal error:[NSError errorWithDomain:RACSelectorSignalErrorDomain code:RACSelectorSignalErrorMethodSwizzlingRace userInfo:userInfo]];</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (method_getImplementation(targetMethod) != _objc_msgForward) &#123;</span><br><span class="line">// Make a method alias for the existing method implementation.</span><br><span class="line">const char *typeEncoding = method_getTypeEncoding(targetMethod);</span><br><span class="line"></span><br><span class="line">RACCheckTypeEncoding(typeEncoding);</span><br><span class="line"></span><br><span class="line">BOOL addedAlias __attribute__((unused)) = class_addMethod(class, aliasSelector, method_getImplementation(targetMethod), typeEncoding);</span><br><span class="line">NSCAssert(addedAlias, @&quot;Original implementation for %@ is already copied to %@ on %@&quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), class);</span><br><span class="line"></span><br><span class="line">// Redefine the selector to call -forwardInvocation:.</span><br><span class="line">class_replaceMethod(class, selector, _objc_msgForward, method_getTypeEncoding(targetMethod));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return subject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上方法可以分为三个部分</p><ul><li>生成对应的aliasSelector，绑定RACSubject</li><li>RACSwizzleClass</li><li>class_addMethod</li></ul><p>class_addMethod 可以分为三部分</p><ul><li>targetMethod == NULL &amp;&amp;  Protocol == NULL : RACSignatureForUndefinedSelector根据selector生成不存在的方法，返回方法类型编码，然后class_addMethod</li><li>protocol != NULL : 获取对应协议方法的类型编码,然后class_addMethod</li><li>targetMethod ！= NULL  如果存在对应的方法，但是方法的实现不是objc_msgForward:将原方法的selector指向objc_msgForward，生成一个aliasSelector指向原方法的method实现</li></ul><p>以上三个部分，最后都实现 class_addMethod(class, selector, objc_msgForward, typeEncoding)</p><p>注:上面方法中objc_msgForward实际是_objc_msgForward，因为编写有问题就简化了</p><h3 id="RACSignatureForUndefinedSelector"><a href="#RACSignatureForUndefinedSelector" class="headerlink" title="RACSignatureForUndefinedSelector"></a>RACSignatureForUndefinedSelector</h3><p>根据selector生成对应的方法签名类型编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">默认返回self 以及当前方法的选择子 SEL，也就是v@:</span><br><span class="line">根据Apple的参数类型，id类型的对象都用@表示,v表示void,:表示SEL</span><br><span class="line">如果selector中含有参数，拼接@，可见参数都是id类型</span><br><span class="line"></span><br><span class="line">static const char *RACSignatureForUndefinedSelector(SEL selector) &#123;</span><br><span class="line">const char *name = sel_getName(selector);</span><br><span class="line">NSMutableString *signature = [NSMutableString stringWithString:@&quot;v@:&quot;];</span><br><span class="line"></span><br><span class="line">while ((name = strchr(name, &apos;:&apos;)) != NULL) &#123;</span><br><span class="line">[signature appendString:@&quot;@&quot;];</span><br><span class="line">name++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return signature.UTF8String;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="重点swizzleClass"><a href="#重点swizzleClass" class="headerlink" title="重点swizzleClass"></a>重点swizzleClass</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">static Class RACSwizzleClass(NSObject *self) &#123;</span><br><span class="line">Class statedClass = self.class;</span><br><span class="line">Class baseClass = object_getClass(self);//获取self的isa：元类</span><br><span class="line"></span><br><span class="line">Class knownDynamicSubclass = objc_getAssociatedObject(self, RACSubclassAssociationKey);</span><br><span class="line">if (knownDynamicSubclass != Nil) return knownDynamicSubclass;</span><br><span class="line"></span><br><span class="line">NSString *className = NSStringFromClass(baseClass);</span><br><span class="line"></span><br><span class="line">if (statedClass != baseClass) &#123;</span><br><span class="line"></span><br><span class="line">@synchronized (swizzledClasses()) &#123;</span><br><span class="line">if (![swizzledClasses() containsObject:className]) &#123;</span><br><span class="line">RACSwizzleForwardInvocation(baseClass);</span><br><span class="line">RACSwizzleRespondsToSelector(baseClass);</span><br><span class="line">RACSwizzleGetClass(baseClass, statedClass);</span><br><span class="line">RACSwizzleGetClass(object_getClass(baseClass), statedClass);</span><br><span class="line">RACSwizzleMethodSignatureForSelector(baseClass);</span><br><span class="line">[swizzledClasses() addObject:className];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return baseClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const char *subclassName = [className stringByAppendingString:RACSubclassSuffix].UTF8String;</span><br><span class="line">Class subclass = objc_getClass(subclassName);</span><br><span class="line"></span><br><span class="line">  //生成baseClass对应的子类</span><br><span class="line">if (subclass == nil) &#123;</span><br><span class="line">subclass = objc_allocateClassPair(baseClass, subclassName, 0);</span><br><span class="line">if (subclass == nil) return nil;</span><br><span class="line"></span><br><span class="line">RACSwizzleForwardInvocation(subclass);</span><br><span class="line">RACSwizzleRespondsToSelector(subclass);</span><br><span class="line"></span><br><span class="line">RACSwizzleGetClass(subclass, statedClass);</span><br><span class="line">RACSwizzleGetClass(object_getClass(subclass), statedClass);</span><br><span class="line"></span><br><span class="line">RACSwizzleMethodSignatureForSelector(subclass);</span><br><span class="line"></span><br><span class="line">objc_registerClassPair(subclass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object_setClass(self, subclass); //修改self为对应的子类，以后消息转发到了子类执行</span><br><span class="line">objc_setAssociatedObject(self, RACSubclassAssociationKey, subclass, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">return subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以分为三部分 主要是修改当前类的一些方法实现</p><ul><li><p>生成子类，然后替换子类的实现方法<br>子类RACDelegateProxy_RACSelectorSignal的class方法返回的对象是当前的类RACDelegateProxy</p></li><li><p>RACSwizzleForwardInvocation(baseClass);</p></li><li>RACSwizzleRespondsToSelector(baseClass);</li><li>RACSwizzleMethodSignatureForSelector(baseClass);</li><li>RACSwizzleGetClass</li></ul><h3 id="RACSwizzleForwardInvocation"><a href="#RACSwizzleForwardInvocation" class="headerlink" title="RACSwizzleForwardInvocation"></a>RACSwizzleForwardInvocation</h3><p>这是最主要的方法RACSwizzleForwardInvocation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">将当前forwardInvocation实现替换为newForwardInvocation的实现</span><br><span class="line"></span><br><span class="line">static void RACSwizzleForwardInvocation(Class class) &#123;</span><br><span class="line">SEL forwardInvocationSEL = @selector(forwardInvocation:);</span><br><span class="line">Method forwardInvocationMethod = class_getInstanceMethod(class, forwardInvocationSEL);</span><br><span class="line"></span><br><span class="line">// Preserve any existing implementation of -forwardInvocation:.</span><br><span class="line">void (*originalForwardInvocation)(id, SEL, NSInvocation *) = NULL;</span><br><span class="line">if (forwardInvocationMethod != NULL) &#123;</span><br><span class="line">originalForwardInvocation = (__typeof__(originalForwardInvocation))method_getImplementation(forwardInvocationMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id newForwardInvocation = ^(id self, NSInvocation *invocation) &#123;</span><br><span class="line">BOOL matched = RACForwardInvocation(self, invocation);</span><br><span class="line">if (matched) return;</span><br><span class="line"></span><br><span class="line">if (originalForwardInvocation == NULL) &#123;</span><br><span class="line">[self doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">originalForwardInvocation(self, forwardInvocationSEL, invocation);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class_replaceMethod(class, forwardInvocationSEL, imp_implementationWithBlock(newForwardInvocation), &quot;v@:@&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static BOOL RACForwardInvocation(id self, NSInvocation *invocation) &#123;</span><br><span class="line">SEL aliasSelector = RACAliasForSelector(invocation.selector);</span><br><span class="line">RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);</span><br><span class="line"></span><br><span class="line">Class class = object_getClass(invocation.target);</span><br><span class="line">BOOL respondsToAlias = [class instancesRespondToSelector:aliasSelector];</span><br><span class="line">if (respondsToAlias) &#123;</span><br><span class="line">invocation.selector = aliasSelector;</span><br><span class="line">[invocation invoke]; //响应方法的target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (subject == nil) return respondsToAlias;</span><br><span class="line"></span><br><span class="line">[subject sendNext:invocation.rac_argumentsTuple];//信号，传参</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="RACSwizzleMethodSignatureForSelector"><a href="#RACSwizzleMethodSignatureForSelector" class="headerlink" title="RACSwizzleMethodSignatureForSelector"></a>RACSwizzleMethodSignatureForSelector</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//在方法不存在时，通过 objc_msgSendSuper 调用父类的 -methodSignatureForSelector: 方法获取方法签名。</span><br><span class="line"></span><br><span class="line">static void RACSwizzleMethodSignatureForSelector(Class class) &#123;</span><br><span class="line">IMP newIMP = imp_implementationWithBlock(^(id self, SEL selector) &#123;</span><br><span class="line"></span><br><span class="line">Class actualClass = object_getClass(self);</span><br><span class="line">Method method = class_getInstanceMethod(actualClass, selector);</span><br><span class="line">if (method == NULL) &#123;</span><br><span class="line"></span><br><span class="line">struct objc_super target = &#123;</span><br><span class="line">.super_class = class_getSuperclass(class),</span><br><span class="line">.receiver = self,</span><br><span class="line">&#125;;</span><br><span class="line">NSMethodSignature * (*messageSend)(struct objc_super *, SEL, SEL) = (__typeof__(messageSend))objc_msgSendSuper;</span><br><span class="line">return messageSend(&amp;target, @selector(methodSignatureForSelector:), selector);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char const *encoding = method_getTypeEncoding(method);</span><br><span class="line">return [NSMethodSignature signatureWithObjCTypes:encoding];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">SEL selector = @selector(methodSignatureForSelector:);</span><br><span class="line">Method methodSignatureForSelectorMethod = class_getInstanceMethod(class, selector);</span><br><span class="line">class_replaceMethod(class, selector, newIMP, method_getTypeEncoding(methodSignatureForSelectorMethod));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RACSwizzleGetClass"><a href="#RACSwizzleGetClass" class="headerlink" title="RACSwizzleGetClass"></a>RACSwizzleGetClass</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void RACSwizzleGetClass(Class class, Class statedClass) &#123;</span><br><span class="line">SEL selector = @selector(class);</span><br><span class="line">Method method = class_getInstanceMethod(class, selector);</span><br><span class="line">IMP newIMP = imp_implementationWithBlock(^(id self) &#123;</span><br><span class="line">return statedClass;</span><br><span class="line">&#125;);</span><br><span class="line">class_replaceMethod(class, selector, newIMP, method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br><span class="line">将class的selector(class)实现替换为newIMP，即返回(statedClass)</span><br></pre></td></tr></table></figure><p>swizzleGetClass有点疑惑，所以写下code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">有两个类</span><br><span class="line">Cat 继承NSObject</span><br><span class="line">PattyCat 继承Cat</span><br><span class="line"></span><br><span class="line">Class object_getClass(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)wanwan</span><br><span class="line">&#123;</span><br><span class="line">  NSLog(@&quot;PattyCat:%p&quot;,[PattyCat class]); //0x101bfa630</span><br><span class="line">  NSLog(@&quot;Cat:%p&quot;,[Cat class]);           //0x101bfa5e0</span><br><span class="line"></span><br><span class="line">  Class statedClass = PattyCat.class;                  //0x101bfa630</span><br><span class="line">  Class baseClass = object_getClass([PattyCat class]);//0x101bfa608</span><br><span class="line"></span><br><span class="line">  if (statedClass != baseClass) &#123;</span><br><span class="line">      RACSwizzleGetClass(baseClass, statedClass);//hook class方法</span><br><span class="line">      RACSwizzleGetClass(object_getClass(baseClass), statedClass);</span><br><span class="line"></span><br><span class="line">      NSLog(@&quot;PattyCat:%p&quot;,[PattyCat class]); //0x101bfa630</span><br><span class="line">      NSLog(@&quot;Cat:%p&quot;,[Cat class]);           //0x101bfa630</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class实例方法存在NSObject的方法列表，类方法存在NSobject-MetaClass的类列表方法里面，所以RACSwizzleGetClass(baseClass, statedClass);第一次执行的时候，是将baseClass也就是在PattyCat的metaClass寻找类class方法，找不到继续往上找Cat-MetaClass，然后直到NSobject-MetaClass找到了，改变class返回为statedClass</span><br><span class="line"></span><br><span class="line">第二次执行  RACSwizzleGetClass(object_getClass(baseClass), statedClass);，从NSobject-MetaClass类列表方法查找Class方法，找到了返回为statedClass</span><br><span class="line"></span><br><span class="line">所以[PattyCat class]没有变化，返回statedClass的指针</span><br><span class="line">[Cat class]去Cat-MetaClass类列表查找，一直找到NSObject-metaClass找到后发现class返回的是statedClass，所以打印的也是statedClass的指针</span><br></pre></td></tr></table></figure></p><p>实际上在了解以上步骤之后，对原来的RACSwizzleClass方法才加以了解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static Class RACSwizzleClass(NSObject *self) &#123;</span><br><span class="line">Class statedClass = self.class;</span><br><span class="line">Class baseClass = object_getClass(self);</span><br><span class="line"></span><br><span class="line">Class knownDynamicSubclass = objc_getAssociatedObject(self, RACSubclassAssociationKey);</span><br><span class="line">if (knownDynamicSubclass != Nil) return knownDynamicSubclass;</span><br><span class="line"></span><br><span class="line">NSString *className = NSStringFromClass(baseClass);</span><br><span class="line"></span><br><span class="line">if (statedClass != baseClass) &#123; //如果当前传进来的self是对象的话，此处不执行</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const char *subclassName = [className stringByAppendingString:RACSubclassSuffix].UTF8String;</span><br><span class="line">Class subclass = objc_getClass(subclassName);</span><br><span class="line"></span><br><span class="line">if (subclass == nil) &#123;</span><br><span class="line">subclass = objc_allocateClassPair(baseClass, subclassName, 0);//从baseclass处生成子类</span><br><span class="line">if (subclass == nil) return nil;</span><br><span class="line"></span><br><span class="line">    //替换子类的相应的方法</span><br><span class="line">RACSwizzleForwardInvocation(subclass);</span><br><span class="line">RACSwizzleRespondsToSelector(subclass);</span><br><span class="line"></span><br><span class="line">    //从上面的事例可以帮助理解，此处是将子类subclass的class方法返回为statedClass，也就是子类subclass的isa为statedClass</span><br><span class="line">RACSwizzleGetClass(subclass, statedClass);</span><br><span class="line">RACSwizzleGetClass(object_getClass(subclass), statedClass);</span><br><span class="line">    //这一步是将子类subclass的metaclass，isa指向statedClass</span><br><span class="line"></span><br><span class="line">RACSwizzleMethodSignatureForSelector(subclass);</span><br><span class="line"></span><br><span class="line">objc_registerClassPair(subclass);//注册子类</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object_setClass(self, subclass);//将当前返回的类修改为子类，这样调用当前的方法会转发到子类去执行，但是为外部来说，返回的class还是statedClass也就是原来的类</span><br><span class="line">objc_setAssociatedObject(self, RACSubclassAssociationKey, subclass, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">return subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>strchr 是C函数，原型为<code>extern char *strchr(const char *s,char c)</code><br>可以查找出字符串s中首次出现c的位置，如果没找到，返回NULL</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RACDelegateProxy 使用消息信号的形式监听所有的代理方法，可以用 block 的形式去代替原有的方法，为我们帮助简化代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ReactiveCocoa，将Cocoa世界中的代理，KVO，通知等桥接到了RAC的世界中，就是使用的RACDelegateProxy，通过运行时修改方法的运行机制，下面一起来熟悉下怎么做到的&lt;/p&gt;
&lt;p&gt;使用事例&lt;/p&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="https://pattyxp.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>Objc消息的发送和查找</title>
    <link href="https://pattyxp.github.io/2018/01/15/Objc%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E6%9F%A5%E6%89%BE/"/>
    <id>https://pattyxp.github.io/2018/01/15/Objc消息的发送和查找/</id>
    <published>2018-01-15T06:17:14.000Z</published>
    <updated>2018-02-02T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本Objc系列的文章，都是笔者在学习的阶段，翻阅他人笔记，自己查看源码记录以加深印象，并非全部原创</p><blockquote><p>本文直接运行的是runtime Objc4-706版本，debug-objc的target，mac运行</p></blockquote><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>在main.m中实现如下代码，添加断点查看XXObject调用hello方法的执行流程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;objc-runtime.h&quot;</span><br><span class="line">@interface XXObject: NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation XXObject</span><br><span class="line">- (void)hello</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        XXObject *obj = [[XXObject alloc] init];</span><br><span class="line">        [obj hello];//lldb  p (void *)@selector(hello) 方法也是在编译期间地址就确定了</span><br><span class="line">                    //lldb  (void *) $1 = 0x0000000100000f9c</span><br><span class="line">        [obj hello];//已经缓存过，直接从缓存取，走的是汇编代码，断点直接到方法实现了</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/Objc消息缓存查找.png" alt="Objc消息缓存查找流程"></p><p>方法先是通过 objc_msgSend_uncached去查找是否有方法的缓存，这个时候断点都没有走到，可见在编译阶段就可以去查找方法的缓存了，也就是说方法的地址在编译期间就已经确定了，和类在内存中的地址是一样的，下面去验证这一说法的正确性</p><p>点进去可以看到，是使用的汇编语言执行的，以此来提高查找速度<br>在主函数中，任意断点处，打印lldb<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (void *)@selector(hello)</span><br><span class="line">(void *) $1 = 0x0000000100000f8c</span><br><span class="line">(lldb) p (void *)@selector(undefined_hello)</span><br><span class="line">(void *) $2 = 0x000000010290ced0</span><br></pre></td></tr></table></figure></p><p>可见在代码中，没有显示的申明方法undefined_hello，导致内存地址和已经申明的方法hello还是有些差距的，undefined_hello选择子是在运行时确定的，因此再次显示申明一次方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main.m</span><br><span class="line">  __unused SEL sel = @selector(undefined_hello);</span><br><span class="line">  XXObject *obj = [[XXObject alloc] init];</span><br><span class="line">  [obj hello];</span><br><span class="line"></span><br><span class="line">lldb打印</span><br><span class="line">(lldb) p (void *)@selector(hello)</span><br><span class="line">(void *) $0 = 0x0000000100000f8c</span><br><span class="line">(lldb) p (void *)@selector(undefined_hello)</span><br><span class="line">(void *) $1 = 0x0000000100000f92</span><br></pre></td></tr></table></figure></p><p>两个选择子内存地址已经想差不大了<br>由此可以得出猜测:<br>1.通过@selector打印选择子的地址，而不是通过hello方法的内存地址，可见在OC中有一份巨大的选择子表<br>2.只需要传入sel的name,就可以去查找对应的选择子内存地址，如果没有找到，就会自动生成一个SEL并插入到表中<br>3.在编译期间就可以把所有的头文件和实现文件中的方法和@selector()方式调用的sel都插入到表中</p><p>在init方法执行前，打断点<br><img src="/images/Objc选择子地址.png" alt="Objc选择子地址"><br>打印选择子hello的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p SEL(0x0000000100000f8c)</span><br><span class="line">(SEL) $2 = &quot;hello&quot;</span><br></pre></td></tr></table></figure></p><h2 id="msgSend"><a href="#msgSend" class="headerlink" title="msgSend"></a>msgSend</h2><p>具体方法 OBJC_EXPORT id objc_msgSend(id self, SEL op, …)没有实现方法，是汇编语言实现的具体实现</p><p>当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个 objc_msgSend、objc_msgSend_stret、objc_msgSendSuper 和 objc_msgSendSuper_stret。<br>发送给对象的父类的消息会使用 objc_msgSendSuper 有数据结构作为返回值的方法会使用 objc_msgSendSuper_stret 或 objc_msgSend_stret 其它的消息都是使用 objc_msgSend 发送的</p><p>现在看下整个的主流程，在调用hello方法的地方，打上断点之后，<br>整个流程中，没有找到方法缓存时，会通过调用lookUpImpOrForward查找方法的实现，打开这个函数的断点，<br>lookUpImpOrForward这个函数主要做的事情如下:</p><ul><li>查找缓存中是否存在方法的实现</li><li>如果类没有初始化完成，就会去分配正确的可读写结构体</li><li>当前类和父类中查找方法实现</li><li>方法决议</li></ul><ol><li><p>查找缓存<br>由于参数传入cache为NO,这里其实是不执行的，在汇编objc_msgSend_uncached已经做了缓存处理了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (cache) &#123; //缓存中查找</span><br><span class="line">      imp = cache_getImp(cls, sel);</span><br><span class="line">      if (imp) return imp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>类初始化和实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> if (!cls-&gt;isRealized()) &#123;</span><br><span class="line">     rwlock_writer_t lock(runtimeLock);</span><br><span class="line">     realizeClass(cls);//为类分配可读写结构体 class_rw_t 的空间，并返回正确的类结构体。</span><br><span class="line"> &#125;</span><br><span class="line"> if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">    _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在当前类中查找，如果查找到了跳转done，否则去当前类查找search_method_list，查找到了调用log_and_fill_cache缓存该方法并跳转done</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">imp = cache_getImp(cls, sel);</span><br><span class="line">if (imp) goto done;</span><br><span class="line"></span><br><span class="line">// Try this class&apos;s method lists.</span><br><span class="line"></span><br><span class="line">meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">if (meth) &#123;</span><br><span class="line">    log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">    imp = meth-&gt;imp;</span><br><span class="line">    goto done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>去父类中查找方法，流程和3原理一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">curClass = cls;</span><br><span class="line">  while ((curClass = curClass-&gt;superclass)) &#123;</span><br><span class="line">      // Superclass cache.</span><br><span class="line">      imp = cache_getImp(curClass, sel);</span><br><span class="line">      if (imp) &#123;</span><br><span class="line">          if (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">              log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">              goto done;</span><br><span class="line">          &#125;</span><br><span class="line">          else &#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Superclass method list.</span><br><span class="line">      meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">      if (meth) &#123;</span><br><span class="line">          log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">          imp = meth-&gt;imp;</span><br><span class="line">          goto done;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">与当前类寻找实现的区别是：在父类中寻找到的 _objc_msgForward_impcache 实现会交给当前类来处理。</span><br></pre></td></tr></table></figure></li><li><p>方法决议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//在当前类和父类都没有找到对应的实现</span><br><span class="line">//判断当前类是否实现了 resolveInstanceMethod: 或者 resolveClassMethod: 方法，然后用objc_msgSend 执行sel，缓存方法</span><br><span class="line"></span><br><span class="line">if (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line">    _class_resolveMethod(cls, sel, inst);</span><br><span class="line">    // Don&apos;t cache the result; we don&apos;t hold the lock so it may have</span><br><span class="line">    // changed already. Re-do the search from scratch instead.</span><br><span class="line">    triedResolver = YES;</span><br><span class="line">    goto retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这部分调用_class_resolveMethod实现</p><p>//如果当前类不是元类，调用_class_resolveInstanceMethod实现<br>否则，调用_class_resolveClassMethod<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    if (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        // try [cls resolveInstanceMethod:sel]</span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // try [nonMetaClass resolveClassMethod:sel]</span><br><span class="line">        // and [cls resolveInstanceMethod:sel]</span><br><span class="line"></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        if (!lookUpImpOrNil(cls, sel, inst,</span><br><span class="line">                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/))</span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在执行了 resolveInstanceMethod: 之后，会跳转到 retry 标签，重新执行查找方法实现的流程，只不过不会再调用 resolveInstanceMethod: 方法了（将 triedResolver 标记为 YES）</p><ol><li>消息转发<br>当在缓存，当前类，父类，resolveInstanceMethod都没有实现，则还有最后一步，消息转发<br>执行完后进行方法的缓存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">   cache_fill(cls, sel, imp, inst);</span><br></pre></td></tr></table></figure></li></ol><h2 id="方法缓存之后再次执行同方法"><a href="#方法缓存之后再次执行同方法" class="headerlink" title="方法缓存之后再次执行同方法"></a>方法缓存之后再次执行同方法</h2><p>上面例子中，如果执行两次相同的方法hello<br>在第二次hello方法执行行 打上断点，然后在lookUpImpOrForward这个函数第一行打上断点，发现并没有进入，可见已经在缓存中查找到了方法并执行，这一步直接在汇编实现了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)[XXObject class]</span><br><span class="line">(objc_class *) $0 = 0x0000000100001480</span><br><span class="line">(lldb) p (cache_t *)0x0000000100001490</span><br><span class="line">(cache_t *) $1 = 0x0000000100001490</span><br><span class="line">(lldb) p *$1</span><br><span class="line">(cache_t) $2 = &#123;</span><br><span class="line">  _buckets = 0x0000000101905b50</span><br><span class="line">  _mask = 3</span><br><span class="line">  _occupied = 2</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $2.capacity()</span><br><span class="line">(mask_t) $3 = 4</span><br><span class="line">(lldb) p $2.buckets()[0]</span><br><span class="line">(bucket_t) $4 = &#123;</span><br><span class="line">  _key = 0</span><br><span class="line">  _imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $2.buckets()[1]</span><br><span class="line">(bucket_t) $5 = &#123;</span><br><span class="line">  _key = 4303608373</span><br><span class="line">  _imp = 0x00000001003459e0 (libobjc.A.dylib`::-[NSObject init]() at NSObject.mm:2312)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $2.buckets()[2]</span><br><span class="line">(bucket_t) $6 = &#123;</span><br><span class="line">  _key = 4294971205</span><br><span class="line">  _imp = 0x0000000100000b30 (debug-objc`-[XXObject hello] at main.m:84)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $2.buckets()[3]</span><br><span class="line">(bucket_t) $7 = &#123;</span><br><span class="line">  _key = 0</span><br><span class="line">  _imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure></p><ul><li>注意上面的XXObject类的指针和缓存的方法列表结构体指针有偏移，是不一样，偏移16<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p sizeof(Class)</span><br><span class="line">(unsigned long) $8 = 8</span><br></pre></td></tr></table></figure></li></ul><p>因为objc_Class继承自objc_Object，所以在cache_t对象之前还有一个隐藏的ISA和superClass，<br>所以cache_t相对偏移16</p><p>以上可以获取到类XXObject的cache_t结构体中所有缓存过的方法列表，通过赋值清除方法缓存<br>类似使用如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) expr $2.buckets()[2] = $2.buckets()[1]</span><br><span class="line">(bucket_t) $8 = &#123;</span><br><span class="line">  _key = 0</span><br><span class="line">  _imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后再次调用hello方法，可以预料到方法再次通过lookUpImpOrForward函数去查找方法实现</p><h2 id="类方法存储"><a href="#类方法存储" class="headerlink" title="类方法存储"></a>类方法存储</h2><p>这里又做了个小测试，测试类方法存储<br>PattyCat类写了个类方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (void)eat</span><br></pre></td></tr></table></figure></p><p>在objc_init方法处打上断点，查看当前类的元类，在编译的时候所存储的方法列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p [PattyCat class]</span><br><span class="line">(Class) $0 = PattyCat</span><br><span class="line">(lldb) p (objc_class *)$0</span><br><span class="line">(objc_class *) $2 = 0x00000001000014c0</span><br><span class="line">(lldb) p (object_getClass([PattyCat class]))</span><br><span class="line">(Class) $3 = 0x0000000100001498</span><br><span class="line">(lldb)</span><br><span class="line"></span><br><span class="line">(lldb) p (objc_class *)0x0000000100001498</span><br><span class="line">(objc_class *) $0 = 0x0000000100001498</span><br><span class="line">(lldb)  p (class_data_bits_t *)0x00000001000014b8</span><br><span class="line">(class_data_bits_t *) $1 = 0x00000001000014b8</span><br><span class="line">(lldb) p $1-&gt;data()</span><br><span class="line">warning: could not find Objective-C class data in the process. This may reduce the quality of type information available.</span><br><span class="line">(class_rw_t *) $2 = 0x0000000100001290</span><br><span class="line">(lldb) p (class_ro_t *)$2</span><br><span class="line">(class_ro_t *) $3 = 0x0000000100001290</span><br><span class="line">(lldb) p *$3</span><br><span class="line">(class_ro_t) $4 = &#123;</span><br><span class="line">  flags = 389</span><br><span class="line">  instanceStart = 40</span><br><span class="line">  instanceSize = 40</span><br><span class="line">  reserved = 0</span><br><span class="line">  ivarLayout = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  name = 0x0000000100000f34 &quot;PattyCat&quot;</span><br><span class="line">  baseMethodList = 0x0000000100001270</span><br><span class="line">  baseProtocols = 0x0000000000000000</span><br><span class="line">  ivars = 0x0000000000000000</span><br><span class="line">  weakIvarLayout = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  baseProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p (method_list_t *)0x0000000100001270</span><br><span class="line">(method_list_t *) $6 = 0x0000000100001270</span><br><span class="line">(lldb) p *$6</span><br><span class="line">(method_list_t) $7 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 1</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;eat&quot;</span><br><span class="line">      types = 0x0000000100000f8c &quot;v16@0:8&quot; //这里可以看到，在编译的时候，已经存储好了类方法eat，存储在元类中</span><br><span class="line">      imp = 0x0000000100000b20 (debug-objc`+[PattyCat eat] at main.m:88)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">2018-02-01 15:54:27.808594+0800 debug-objc[14086:176179] I can eat</span><br><span class="line">(lldb) p sizeof(cache_t)</span><br><span class="line">(unsigned long) $8 = 16</span><br><span class="line">(lldb) p (cache_t *)0x00000001000014a8  在执行完[PattyCat class]方法时候，打印元类的缓存方法，查看class是否从NSObjetc的元类方法copy的</span><br><span class="line">(cache_t *) $11 = 0x00000001000014a8</span><br><span class="line">(lldb) p *$11</span><br><span class="line">(cache_t) $12 = &#123;</span><br><span class="line">  _buckets = 0x0000000100c450e0</span><br><span class="line">  _mask = 3</span><br><span class="line">  _occupied = 3</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p (bucket_t *)0x0000000100c450e0</span><br><span class="line">(bucket_t *) $13 = 0x0000000100c450e0</span><br><span class="line">(lldb) p *$13</span><br><span class="line">(bucket_t) $14 = &#123;</span><br><span class="line">  _key = 4303608336</span><br><span class="line">  _imp = 0x0000000100343b50 (libobjc.A.dylib`::+[NSObject class]() at NSObject.mm:1988) //此处可以证明类的class方法是从NSObject的类方法class拷贝得到的哈哈哈</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了提高消息传递的效率，ObjC 对 objc_msgSend 以及 cache_getImp 使用了汇编语言来编写。</p><p>objc_msgSend的汇编文件在objc-msg-arm.s中</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://github.com/Draveness/analyze/blob/master/contents/objc/%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9C%8B%20ObjC%20%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81.md" target="_blank" rel="noopener">https://github.com/Draveness/analyze/blob/master/contents/objc/%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9C%8B%20ObjC%20%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本Objc系列的文章，都是笔者在学习的阶段，翻阅他人笔记，自己查看源码记录以加深印象，并非全部原创&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Objc" scheme="https://pattyxp.github.io/tags/Objc/"/>
    
  </entry>
  
  <entry>
    <title>Objc initialize的分析</title>
    <link href="https://pattyxp.github.io/2018/01/13/Objc%20initialize%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <id>https://pattyxp.github.io/2018/01/13/Objc initialize的分析/</id>
    <published>2018-01-13T06:04:50.000Z</published>
    <updated>2018-02-11T03:07:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本Objc系列的文章，都是笔者在学习的阶段，翻阅他人笔记，自己查看源码记录以加深印象，并非全部原创</p><blockquote><p>本文直接运行的是runtime Objc4-706版本，debug-objc的target，mac运行，</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先来看下源码，在main.m中添加代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface XXObject: NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation XXObject</span><br><span class="line"></span><br><span class="line">+ (void)initialize</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;XXObject initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，发现没有任何打印log<br><img src="/images/initialize的打印.png" alt="initialize的打印"></p><p>和load方法不同，load方法运行还是有打印的，这是为什么呢？？</p><p>如果运行以下code,将会看到断点执行和log<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        __unused XXObject *object = [[XXObject alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/initialize的打印2.png" alt="initialize的打印2"></p><p>由此可见，虽然没有显式调用initialize方法，但是还是打印了log</p><blockquote><p>initialize方法是在该类第一次调用方法的时候才会执行</p></blockquote><p>在方法调用栈里，可以查看到方法调用的顺序，首先_objc_msgSend_uncached，先从方法的缓存里面查找该对应的方法，找不到了，然后从lookUpImpOrForward方法去查找.<br><img src="/images/initialize_lookupImg.png" alt="initialize_lookupImg"><br>在上图的调用栈里，打印 p sel 打印当前的选择子，发现log输出的是alloc,也就是当前调用的是alloc方法，可见initialize方法调用在alloc之前,alloc的调用导致了方法initialize的执行</p><p>下面再看 class_initialize方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    bool reallyInitialize = NO;</span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls); //初始化父类</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Try to atomically set CLS_INITIALIZING.</span><br><span class="line">    &#123;</span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">            cls-&gt;setInitializing(); //设置标志位</span><br><span class="line">            reallyInitialize = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (reallyInitialize) &#123; //如果成功设置标志位,初始化 callInitialize(cls)</span><br><span class="line"></span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: calling +[%s initialize]&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @try &#123;</span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: finished +[%s initialize]&quot;,</span><br><span class="line">                             cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @catch (...) &#123;</span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: +[%s initialize] threw an exception&quot;,</span><br><span class="line">                             cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            @throw;</span><br><span class="line">        &#125;</span><br><span class="line">        @finally &#123;</span><br><span class="line">            monitor_locker_t lock(classInitLock);</span><br><span class="line">            if (!supercls  ||  supercls-&gt;isInitialized()) &#123;</span><br><span class="line">                _finishInitializing(cls, supercls);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                _finishInitializingAfter(cls, supercls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法的主要执行流程:</p><ul><li>如果存在父类，先初始化父类</li><li>加锁，设置初始化RW_INITIALIZING标志，</li><li>向当前类发送执行initialize方法</li><li>设置标志位RW_INITIALIZED完成<br>如果父类已经初始化完成，调用_finishInitializing<br>否则调用_finishInitializingAfter在父类初始化结束之后设置完成标志</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void _finishInitializing(Class cls, Class supercls)</span><br><span class="line">&#123;</span><br><span class="line">    PendingInitialize *pending;</span><br><span class="line"></span><br><span class="line">    classInitLock.assertLocked();</span><br><span class="line">    assert(!supercls  ||  supercls-&gt;isInitialized());</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    cls-&gt;setInitialized();</span><br><span class="line">    classInitLock.notifyAll();</span><br><span class="line">    _setThisThreadIsNotInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">    // mark any subclasses that were merely waiting for this class</span><br><span class="line">    if (!pendingInitializeMap) return;</span><br><span class="line">    pending = (PendingInitialize *)NXMapGet(pendingInitializeMap, cls);</span><br><span class="line">    if (!pending) return;</span><br><span class="line"></span><br><span class="line">    NXMapRemove(pendingInitializeMap, cls);</span><br><span class="line"></span><br><span class="line">    // Destroy the pending table if it&apos;s now empty, to save memory.</span><br><span class="line">    if (NXCountMapTable(pendingInitializeMap) == 0) &#123;</span><br><span class="line">        NXFreeMapTable(pendingInitializeMap);</span><br><span class="line">        pendingInitializeMap = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (pending) &#123;</span><br><span class="line">        PendingInitialize *next = pending-&gt;next;</span><br><span class="line">        if (pending-&gt;subclass) _finishInitializing(pending-&gt;subclass, cls);</span><br><span class="line">        free(pending);</span><br><span class="line">        pending = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">由于父类已经完成了初始化，在这里直接将当前类标记成已经初始化，然后递归地将被当前类 block 的子类标记为已初始化，再把这些类移除 pendingInitializeMap。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void _finishInitializingAfter(Class cls, Class supercls)</span><br><span class="line">&#123;</span><br><span class="line">    PendingInitialize *pending;</span><br><span class="line"></span><br><span class="line">    classInitLock.assertLocked();</span><br><span class="line">    ...</span><br><span class="line">    if (!pendingInitializeMap) &#123;</span><br><span class="line">        pendingInitializeMap =</span><br><span class="line">            NXCreateMapTable(NXPtrValueMapPrototype, 10);</span><br><span class="line">        // fixme pre-size this table for CF/NSObject +initialize</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pending = (PendingInitialize *)malloc(sizeof(*pending));</span><br><span class="line">    pending-&gt;subclass = cls;</span><br><span class="line">    pending-&gt;next = (PendingInitialize *)</span><br><span class="line">        NXMapGet(pendingInitializeMap, supercls);</span><br><span class="line">    NXMapInsert(pendingInitializeMap, supercls, pending);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">首先创建一个pending,然后将当前类作为子类继承，插入到map表</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下关于initialize方法的特性：</p><ul><li>initialize 的调用是惰性的，它会在第一次调用当前类的方法时被调用</li><li>与load 不同，initialize 方法调用时，所有的类都已经加载到了内存中</li><li>initialize 的运行是线程安全的</li><li>子类会继承父类的 initialize 方法</li><li>而其作用也非常局限，一般我们只会在 initialize 方法中进行一些常量的初始化。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本Objc系列的文章，都是笔者在学习的阶段，翻阅他人笔记，自己查看源码记录以加深印象，并非全部原创&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Objc" scheme="https://pattyxp.github.io/tags/Objc/"/>
    
  </entry>
  
  <entry>
    <title>Objc对象的初始化</title>
    <link href="https://pattyxp.github.io/2018/01/12/Objc%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://pattyxp.github.io/2018/01/12/Objc对象的初始化/</id>
    <published>2018-01-12T06:13:13.000Z</published>
    <updated>2018-01-30T03:45:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本Objc系列的文章，都是笔者在学习的阶段，翻阅他人笔记，自己查看源码记录以加深印象，并非全部原创</p><blockquote><p>本文直接运行的是runtime Objc4-706版本，debug-objc的target，mac运行，在main.m文件添加code NSObject*obj=[[NSObject alloc]init];，打上断点一步步调试</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        PattyCat *pcat = [PattyCat alloc];</span><br><span class="line">        [pcat init];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法里，打上断点，进入调试看如何初始化对象</p><h2 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h2><p>先看下大致的流程<br><img src="/images/alloc流程图.png" alt="alloc流程"></p><p>断点首先进入 NSObject.mm中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br><span class="line">id</span><br><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone=false)</span><br><span class="line">&#123;</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil; //根据传参，此行不执行</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">      id obj = class_createInstance(cls, 0);</span><br><span class="line">          if (slowpath(!obj)) return callBadAllocHandler(cls);</span><br><span class="line">          return obj;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行断点调试，发现最终调用class_createInstance<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">class_createInstance(Class cls, size_t extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    return _class_createInstanceFromZone(cls, extraBytes, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对象初始化中最重要的操作都在_class_createInstanceFromZone 方法中执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static __attribute__((always_inline))</span><br><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              bool cxxConstruct = true,</span><br><span class="line">                              size_t *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    if (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">        obj = (id)calloc(1, size);</span><br><span class="line">        if (!obj) return nil;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此，alloc方法执行完毕，所以重点就是分配了一块内存空间，初始化isa</p><p>在分配空间之前，需要先获取cls实例内存空间的大小，方法cls-&gt;instanceSize可以分析下<br>可见这是按照16字节对齐的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">       size_t size = alignedInstanceSize() + extraBytes;</span><br><span class="line">       // CF requires all objects be at least 16 bytes.</span><br><span class="line">       if (size &lt; 16) size = 16;</span><br><span class="line">       return size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Class&apos;s ivar size rounded up to a pointer-size boundary.</span><br><span class="line">uint32_t alignedInstanceSize() &#123;</span><br><span class="line">    return word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span><br><span class="line">    return (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// May be unaligned depending on class&apos;s ivars.</span><br><span class="line">uint32_t unalignedInstanceSize() &#123;</span><br><span class="line">    assert(isRealized());</span><br><span class="line">    return data()-&gt;ro-&gt;instanceSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拿到对象的大小之后，calloc分配空间，然后初始化对象的initIsa<br>obj-&gt;initInstanceIsa(cls, hasCxxDtor);进行对象的isa结构体初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    assert(hasCxxDtor == cls-&gt;hasCxxDtor());</span><br><span class="line"></span><br><span class="line">    initIsa(cls, true, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line">inline void</span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">        ...</span><br><span class="line">        isa_t newisa(0);</span><br><span class="line">        ...</span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">        isa = newisa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>可见init只是返回了当前的对象obj<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    return _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line">id</span><br><span class="line">objc_retain(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return obj;</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return obj;</span><br><span class="line">    return obj-&gt;retain();</span><br><span class="line">&#125;</span><br><span class="line">inline id</span><br><span class="line">objc_object::retain()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    if (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        return rootRetain();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">objc_object::rootRetain()</span><br><span class="line">&#123;</span><br><span class="line">    return rootRetain(false, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objc_object::rootRetain(bool tryRetain, bool handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked = false;</span><br><span class="line">    bool transcribeToSideTable = false;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        transcribeToSideTable = false;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        ...</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc++</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">    &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">最终返回自身</span><br><span class="line">return this</span><br></pre></td></tr></table></figure></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><pre><code>#define fastpath(x) (__builtin_expect(bool(x), 1))#define slowpath(x) (__builtin_expect(bool(x), 0))__builtin_expect的作用  这个指令是gcc引入的，作用是&quot;允许程序员将最有可能执行的分支告诉编译器&quot;。这个指令的写法为：__builtin_expect(EXP, N)。意思是：EXP==N的概率很大。一般的使用方法是将__builtin_expect指令封装为宏</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文内容还是比较简单的，对象的初始化，只是分配内存空间，初始化isa结构体，isa的初始化，可以查看另一篇文章isa的存在</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本Objc系列的文章，都是笔者在学习的阶段，翻阅他人笔记，自己查看源码记录以加深印象，并非全部原创&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Objc" scheme="https://pattyxp.github.io/tags/Objc/"/>
    
  </entry>
  
  <entry>
    <title>图片压缩算法</title>
    <link href="https://pattyxp.github.io/2018/01/11/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    <id>https://pattyxp.github.io/2018/01/11/图片压缩算法/</id>
    <published>2018-01-11T02:16:25.000Z</published>
    <updated>2018-01-11T02:43:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>压缩，可以拆分为压 和 缩</p><p>压，就是将图片的体积变小，图片的质量肯定下降<br>缩，就是将图片的尺寸变小，这样图片体积也会变小</p><p>有时候，需要上传图片到后台服务器，但是如单反照相机拍出来的图片轻则十几兆，一般服务器都会有一个图片压缩的上限，不可能接收很大的图片体积的，所以我们前端需要做处理。根据服务端能够接受的图片大小和图片体积，处理上传需要的最大图片质量。</p><p>因此可以先处理图片的尺寸，压缩到符合要求的尺寸之后，再看图片的大小是否还超过规定范围，超过的话再继续压缩体积</p><p>设计上可以设计为UIImage的分类，因为这是对图片的处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">static const float kMaxFileSize = xxx;</span><br><span class="line">static const float kMaxLayout = xxx;</span><br><span class="line"></span><br><span class="line">- (NSData *)imageCompressTargetPx:(NSInteger)targetPx maxFileSize:(uint64_t)maxFileSize &#123;</span><br><span class="line">    UIImage *newImage = nil;             // 尺寸压缩后的新图</span><br><span class="line">    BOOL drawImge = NO;                  // 是否需要重绘图片 默认是NO</span><br><span class="line"></span><br><span class="line">    CGFloat width = self.size.width;     // 源图片的宽</span><br><span class="line">    CGFloat height = self.size.height;   // 原图片的高</span><br><span class="line">    CGFloat scaledWidth = targetPx;      // 压缩时的宽度 默认是参照像素</span><br><span class="line">    CGFloat scaledHeight = targetPx;     // 压缩时的高度 默认是参照像素</span><br><span class="line"></span><br><span class="line">    if (maxFileSize &lt;= 0) &#123;</span><br><span class="line">        maxFileSize = kMaxFileSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //压缩指定尺寸</span><br><span class="line">    CGSize newSize = [self copressTargetLimitSize:self.size];</span><br><span class="line">    if (newSize.width != width ||newSize.height != height) &#123;</span><br><span class="line">        drawImge = YES;</span><br><span class="line">        scaledWidth = newSize.width;</span><br><span class="line">        scaledHeight = newSize.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果图片需要重绘 就按照新的宽高压缩重绘图片</span><br><span class="line">    if (drawImge == YES) &#123;</span><br><span class="line">        UIGraphicsBeginImageContext(CGSizeMake(scaledWidth, scaledHeight));</span><br><span class="line">        [self drawInRect:CGRectMake(0, 0, scaledWidth,scaledHeight)];</span><br><span class="line">        newImage =UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">        // 使当前的context出堆栈</span><br><span class="line">        UIGraphicsEndImageContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (newImage == nil) &#123;</span><br><span class="line">        newImage = self;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果图片大小大于要求大小,进行质量压缩</span><br><span class="line">    NSData * scaledImageData = nil;</span><br><span class="line">    if (UIImageJPEGRepresentation(newImage, 1) == nil) &#123;</span><br><span class="line">        scaledImageData = UIImagePNGRepresentation(newImage);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        scaledImageData = UIImageJPEGRepresentation(newImage, 1.0);</span><br><span class="line">        CGFloat scale = 0.9;</span><br><span class="line">        while(scaledImageData.length &gt;= maxFileSize)&#123;</span><br><span class="line">            scaledImageData = UIImageJPEGRepresentation(newImage, scale);</span><br><span class="line">            scale -= 0.1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return scaledImageData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -private</span><br><span class="line"></span><br><span class="line">- (CGSize)copressTargetLimitSize:(CGSize)originSize</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat width = originSize.width;     // 源图片的宽</span><br><span class="line">    CGFloat height = originSize.height;   // 原图片的高</span><br><span class="line">    BOOL drawImge = NO;                  // 是否需要重绘图片 默认是NO</span><br><span class="line">    CGFloat scaledWidth = kMaxLayout;      // 压缩时的宽度 默认是参照像素</span><br><span class="line">    CGFloat scaledHeight = kMaxLayout;     // 压缩时的高度 默认是参照像素</span><br><span class="line"></span><br><span class="line">    CGFloat targetPx = kMaxLayout;         // 压缩时的宽度 默认是参照像素</span><br><span class="line"></span><br><span class="line">    CGFloat max = MAX(width, height);</span><br><span class="line">    CGFloat min = MIN(width, height);</span><br><span class="line">    CGFloat factor = min/max;</span><br><span class="line"></span><br><span class="line">    if (width &lt;= 0 &amp;&amp; height &lt;= 0) &#123;</span><br><span class="line">        return originSize;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        drawImge = YES;</span><br><span class="line"></span><br><span class="line">        if (width &gt; height) &#123;</span><br><span class="line">            scaledWidth = targetPx;</span><br><span class="line">            scaledHeight = targetPx *factor;</span><br><span class="line">        &#125;else if (height &gt; width) &#123;</span><br><span class="line">            scaledHeight = targetPx;</span><br><span class="line">            scaledWidth = targetPx *factor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return CGSizeMake(scaledWidth, scaledHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;压缩，可以拆分为压 和 缩&lt;/p&gt;
&lt;p&gt;压，就是将图片的体积变小，图片的质量肯定下降&lt;br&gt;缩，就是将图片的尺寸变小，这样图片体积也会变小&lt;/p&gt;
&lt;p&gt;有时候，需要上传图片到后台服务器，但是如单反照相机拍出来的图片轻则十几兆，一般服务器都会有一个图片压缩的上限，不可能接
      
    
    </summary>
    
    
      <category term="原理" scheme="https://pattyxp.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Objc isa的存在</title>
    <link href="https://pattyxp.github.io/2018/01/10/Objc%20isa%E7%9A%84%E5%AD%98%E5%9C%A8/"/>
    <id>https://pattyxp.github.io/2018/01/10/Objc isa的存在/</id>
    <published>2018-01-10T06:20:40.000Z</published>
    <updated>2018-02-11T03:06:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本Objc系列的文章，都是笔者在学习的阶段，翻阅他人笔记，自己查看源码记录以加深印象，并非全部原创</p><blockquote><p>本文直接运行的是runtime Objc4-706版本，debug-objc的target，mac运行，</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><img src="/images/isa.png" alt="结构图"></p><p>在 Objective-C 中，对象的方法并没有存储于对象的结构体中（如果每一个对象都保存了自己能执行的方法，那么对内存的占用有极大的影响）。</p><p>当实例方法被调用时，它要通过自己持有的 isa 来查找对应的类，然后在这里的 class_data_bits_t 结构体中查找对应方法的实现。同时，每一个 objc_class 也有一个指向自己的父类的指针 super_class 用来查找继承的方法。</p><p>isa分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">union isa_t</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  isa_t() &#123; &#125;</span><br><span class="line">  isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  Class cls;</span><br><span class="line">  uintptr_t bits;</span><br><span class="line"></span><br><span class="line">  //如果是X86的结构，大致信息如下，还有arm_64这里就不贴了，大致字段差不多，多少有点差别</span><br><span class="line">  if __x86_64__  </span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</span><br><span class="line"></span><br><span class="line">    struct &#123;</span><br><span class="line">    uintptr_t nonpointer        : 1;</span><br><span class="line">    uintptr_t has_assoc         : 1;</span><br><span class="line">    uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">    uintptr_t shiftcls          : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000</span><br><span class="line">    uintptr_t magic             : 6;</span><br><span class="line">    uintptr_t weakly_referenced : 1;</span><br><span class="line">    uintptr_t deallocating      : 1;</span><br><span class="line">    uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">    uintptr_t extra_rc          : 8;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>union结构体 结构比较灵活，如下所示，一次只能容纳一件事，但是这个东西可能是一个int，一个浮点数等，这取决于你如何声明它。<br>isa_t、cls、 bits 还有结构体共用同一块地址空间，isa 总共会占据 64 位的内存空间（决定于其中的结构体）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef union MyUnion MYUNION;</span><br><span class="line">union MyUnion</span><br><span class="line">&#123;</span><br><span class="line">   int MyInt;</span><br><span class="line">   float MyFloat;</span><br><span class="line">&#125;;</span><br><span class="line">MyUnion将只包含一个int或一个浮点数，取决于你最近设置的。所以这样做：</span><br><span class="line"></span><br><span class="line">MYUNION u;</span><br><span class="line">u.MyInt = 10;</span><br><span class="line">你现在保持一个int等于10;</span><br><span class="line"></span><br><span class="line">u.MyFloat = 1.0;</span><br><span class="line">你现在拥有一个等于1.0的浮动。</span><br></pre></td></tr></table></figure></p><p>isa的内存结构图<br><img src="images/isa内存结构图.png" alt="isa结构图"></p><p>初始化<br>对于bits的设置可以在初始化中进行设置 objc-object.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    assert(hasCxxDtor == cls-&gt;hasCxxDtor());</span><br><span class="line"></span><br><span class="line">    initIsa(cls, true, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void</span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line"></span><br><span class="line">    if (!nonpointer) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        assert(!DisableNonpointerIsa);</span><br><span class="line">        assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line"></span><br><span class="line">        isa_t newisa(0);</span><br><span class="line"></span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">        assert(cls-&gt;classArrayIndex() &gt; 0);</span><br><span class="line">        newisa.bits = ISA_INDEX_MAGIC_VALUE; //赋值0x001d800000000001ULL</span><br><span class="line">        // isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        // isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();</span><br><span class="line">#else</span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        // isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        // isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        // This write must be performed in a single store in some cases</span><br><span class="line">        // (for example when realizing a class because other threads</span><br><span class="line">        // may simultaneously try to use the class).</span><br><span class="line">        // fixme use atomics here to guarantee single-store and to</span><br><span class="line">        // guarantee memory order w.r.t. the class index table</span><br><span class="line">        // ...but not too atomic because we don&apos;t want to hurt instantiation</span><br><span class="line">        isa = newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>newisa.bits = ISA_INDEX_MAGIC_VALUE; //赋值0x001d800000000001ULL则对应的64位显示的值如下图<br><img src="/images/isa赋值.png" alt="isa赋值后"></p><p>从图中了解到，在使用 ISA_MAGIC_VALUE 设置 isa_t 结构体之后，实际上只是设置了 indexed 以及 magic 这两部分的值。</p><ul><li>indexed 表示 isa_t 的类型<ul><li>0 表示 raw isa，也就是没有结构体的部分，访问对象的 isa 会直接返回一个指向 cls 的指针，也就是在 iPhone 迁移到 64 位系统之前时 isa 的类型。</li><li>1 表示当前 isa 不是指针，但是其中也有 cls 的信息，只是其中关于类的指针都是保存在 shiftcls 中。</li></ul></li><li><p>magic 的值为 0x3b 用于调试器判断当前对象是真的对象还是没有初始化的空间</p></li><li><p>has_cxx_dtor:在设置 indexed 和 magic 值之后，会设置 isa 的 has_cxx_dtor，这一位表示当前对象有 C++ 或者 ObjC 的析构器(destructor)，如果没有析构器就会快速释放内存。</p></li><li><p>shiftcls: 将当前对象对应的类指针存入 isa 结构体中</p><blockquote><p>isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;<br>所有类指针十六进制地址的最后一位都为 8 或者 0<br>将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。</p></blockquote></li></ul><ul><li><p>ISA() 方法<br>因为我们使用结构体取代了原有的 isa 指针，所以要提供一个方法 ISA() 来返回类指针。</p><p>其中 ISA_MASK 是宏定义，这里通过掩码的方式获取类指针：</p><p>#define ISA_MASK 0x00007ffffffffff8ULL<br>inline Class<br>objc_object::ISA()<br>{</p><pre><code>return (Class)(isa.bits &amp; ISA_MASK);//返回64bit中shiftcls位对应的值</code></pre><p>}</p></li></ul><h2 id="其它-bits"><a href="#其它-bits" class="headerlink" title="其它 bits"></a>其它 bits</h2><p>  在 isa_t 中，我们还有一些没有介绍的其它 bits，在这个小结就简单介绍下这些 bits 的作用</p><ul><li>has_assoc<br>对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存</li><li>weakly_referenced<br>对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放</li><li>deallocating<br>对象正在释放内存</li><li>has_sidetable_rc<br>对象的引用计数太大了，存不下</li><li>extra_rc<br>对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，extra_rc 的值就为 9</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>1、前缀：<br>0开头表示8进制，0x或0X开头表示16进制。</p><p>2、后缀：用来表示类型。<br>—— l或L表示long常量<br>—— u或U表示unsigned int常量<br>—— ul、uL、Ul、UL、lU、lu、LU、Lu表示unsigned long常量。（lu可以采用任意顺序和大小写表示）<br>—— ll、LL表示long long 常量。<br>—— ull、Ull、uLL、ULL表示unsigned long long常量。</p><blockquote><p>当希望常量被当作unsigned long long表示就在后面加上后缀ULL</p></blockquote><p>3、对于浮点常量，<br>—— f或F表示float<br>—— l或L表示long double<br>—— 其他都表示double</p><p>4、不带后缀时的规则——尽可能采用小的类型：<br>—— 对于10进制：int-&gt;long-&gt;long long<br>—— 对于8进制或16进制：int-&gt;unsigned int-&gt;long-&gt;unsigned long-&gt;long long -&gt;unsigned long long</p><h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><p>元类是Class对象的类。<br>简单的说：<br>将消息发送给对象时，会在对象的类的方法列表中查找该消息。<br>当你发送消息给一个类时，这个消息在类的元类的方法列表中查找。<br>元类是必不可少的，因为它存储了类的方法Class。Class因为每个类Class都有一个潜在唯一的类方法列表，所以每个方法都必须有一个唯一的元类。意味着所有的Class对象本身都不是同一个类。</p><p>元类具有NSObject元类作为它的类。<br>元类，也是一个对象，元类的class就是NSObject,NSObject的元类是自身。这意味着元类isa上的指针指向NSObject自己（这是它自己的一个实例）。</p><p>code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Class newClass =</span><br><span class="line">    objc_allocateClassPair([NSError class], &quot;RuntimeErrorSubclass&quot;, 0);</span><br><span class="line">class_addMethod(newClass, @selector(report), (IMP)ReportFunction, &quot;v@:&quot;);</span><br><span class="line">objc_registerClassPair(newClass);</span><br><span class="line"></span><br><span class="line">void ReportFunction(id self, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;This object is %p.&quot;, self);</span><br><span class="line">    NSLog(@&quot;Class is %@, and super is %@.&quot;, [self class], [self superclass]);</span><br><span class="line"></span><br><span class="line">    Class currentClass = [self class];</span><br><span class="line">    for (int i = 1; i &lt; 5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;Following the isa pointer %d times gives %p&quot;, i, currentClass);</span><br><span class="line">        currentClass = object_getClass(currentClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;NSObject&apos;s class is %p&quot;, [NSObject class]);</span><br><span class="line">    NSLog(@&quot;NSObject&apos;s meta class is %p&quot;, object_getClass([NSObject class]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用</span><br><span class="line">id instanceOfNewClass =</span><br><span class="line">    [[newClass alloc] initWithDomain:@&quot;someDomain&quot; code:0 userInfo:nil];</span><br><span class="line">[instanceOfNewClass performSelector:@selector(report)];</span><br><span class="line">[instanceOfNewClass release];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在运行时创建一个类只需三个简单的步骤：</span><br><span class="line"></span><br><span class="line">为“类对”分配存储（使用objc_allocateClassPair）。</span><br><span class="line">根据需要将方法和ivars添加到类中（我已经添加了一个方法class_addMethod）。</span><br><span class="line">注册该类，以便可以使用（使用objc_registerClassPair）。</span><br><span class="line"></span><br><span class="line">该函数objc_allocateClassPair只返回一个值：类。另一半就是元类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">打印如下:</span><br><span class="line">This object is 0x10010c810.</span><br><span class="line">Class is RuntimeErrorSubclass, and super is NSError.</span><br><span class="line">Following the isa pointer 1 times gives 0x10010c600</span><br><span class="line">Following the isa pointer 2 times gives 0x10010c630</span><br><span class="line">Following the isa pointer 3 times gives 0x7fff71038480</span><br><span class="line">Following the isa pointer 4 times gives 0x7fff71038480</span><br><span class="line">NSObject&apos;s class is 0x7fff710384a8</span><br><span class="line">NSObject&apos;s meta class is 0x7fff71038480</span><br><span class="line"></span><br><span class="line">通过isa重复的值来查看所到达的地址：</span><br><span class="line"></span><br><span class="line">该对象是地址0x10010c810。</span><br><span class="line">类是地址0x10010c600。</span><br><span class="line">元类是地址0x10010c630。</span><br><span class="line">元类的类（即NSObject元类）是地址0x7fff71038480。</span><br><span class="line">在NSObject元类的类本身。</span><br><span class="line">地址的价值并不重要，只是它展示了从类到元类到NSObject元类的进展。</span><br></pre></td></tr></table></figure></p><p>object_getClass 与 objc_getClass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class cls = [XXObject class];</span><br><span class="line">NSLog(@&quot;%p&quot;,cls);                  //0x1000011a8</span><br><span class="line">NSLog(@&quot;%p&quot;,object_getClass(cls));//0x100001180  </span><br><span class="line">NSLog(@&quot;%p&quot;,objc_getClass([NSStringFromClass(cls)UTF8String]));//0x1000011a8  </span><br><span class="line"></span><br><span class="line">object_getClass 返回 isa指向的类</span><br><span class="line">objc_getClass方法只是单纯地返回了Class</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.isa结构<br>2.元类 元类的概念</p><ul><li>Object_Class</li><li><p>objc_class<br>3.类在内存中的位置，在编译期间就已经确定了<br>4.object_getClass(obj)返回的是obj中的isa指针；</p><p>[obj class]则分两种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> // class方法</span><br><span class="line"> + (Class)class &#123;</span><br><span class="line">    return self;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br><span class="line">Class object_getClass(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>二是当obj为类对象（包括元类和根类以及根元类）时，调用的是类方法：+ (Class)class，返回的结果为其本身。</li><li>一是当obj为实例对象时，[obj class]中class是实例方法：- (Class)class，返回的obj对象中的isa指针；<br><img src="/images/OC-经典类的结构图查找isa.png" alt="OC-经典类的结构图查找isa"></li></ul><p>为了便于理解，修改上图的继承关系 NyanCat-&gt;Cat-&gt;NSObject<br><img src="/images/Objc-经典类的结构图查找isa详解.png" alt="Objc-经典类的结构图查找isa详解"></p><h2 id="阅读链接"><a href="#阅读链接" class="headerlink" title="阅读链接"></a>阅读链接</h2><p><a href="https://github.com/Draveness/analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md" target="_blank" rel="noopener">isa解读</a>  以上图片链接均来自于此链接</p><p><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">关于元类</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本Objc系列的文章，都是笔者在学习的阶段，翻阅他人笔记，自己查看源码记录以加深印象，并非全部原创&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Objc" scheme="https://pattyxp.github.io/tags/Objc/"/>
    
  </entry>
  
  <entry>
    <title>为什么使用copy而不是Strong</title>
    <link href="https://pattyxp.github.io/2018/01/09/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8copy%E8%80%8C%E4%B8%8D%E6%98%AFStrong/"/>
    <id>https://pattyxp.github.io/2018/01/09/为什么使用copy而不是Strong/</id>
    <published>2018-01-09T09:20:30.000Z</published>
    <updated>2018-01-09T11:57:01.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//下面使用打印下指针看下</span><br><span class="line">NSMutableString *str1 = [NSMutableString stringWithFormat:@&quot;iOS&quot;];</span><br><span class="line">NSLog(@&quot;%p&quot;, str1);  //0x7b0c0006e0a0</span><br><span class="line">NSString *str_a1 = str1;</span><br><span class="line">NSLog(@&quot;%p&quot;, str_a1);  //0x7b0c0006e0a0</span><br><span class="line">NSString *str_b1 = [str1 copy];</span><br><span class="line">NSLog(@&quot;%p&quot;, str_b1);  //0xa00000000534f693</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSString *str2 = [NSMutableString stringWithFormat:@&quot;iOS&quot;];</span><br><span class="line">NSLog(@&quot;%p&quot;, str2);     //0x7b0c000776a0</span><br><span class="line">NSString *str_a2 = str2;</span><br><span class="line">NSLog(@&quot;%p&quot;, str_a2);  //0x7b0c000776a0</span><br><span class="line">NSString *str_b2 = [str2 copy];</span><br><span class="line">NSLog(@&quot;%p&quot;, str_b2);  //0xa00000000534f693</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSString *str3 = [NSString stringWithFormat:@&quot;iOS&quot;];</span><br><span class="line">NSLog(@&quot;%p&quot;, str3);   //0xa00000000534f693</span><br><span class="line">NSString *str_a3 = str3;</span><br><span class="line">NSLog(@&quot;%p&quot;, str_a3); //0xa00000000534f693</span><br><span class="line">NSString *str_b3 = [str3 copy];</span><br><span class="line">NSLog(@&quot;%p&quot;, str_b3); //0xa00000000534f693</span><br><span class="line"></span><br><span class="line">//结论:</span><br><span class="line"> 从一个 NSString 进行 copy 后赋值，copy 方法仍旧是浅拷贝</span><br><span class="line"> 从一个 NSMutableString 进行 copy 后赋值，copy 方法是深拷贝</span><br></pre></td></tr></table></figure><p>当令 NSString 对象指针指向一个 NSMutableString 的时候，则会对一个对象进行深复制。这也就是我们一直所说的在一个 Class 的成员是 NSString 类型的时候，修饰属性应该使用 copy ，其实就是在使用 mutable 对象进行赋值的时候，防止 mutable 对象的改变从而影响成员变量。</p><p>源码分析<br><a href="https://searchcode.com/file/12532490/libFoundation/Foundation/NSString.m" target="_blank" rel="noopener">NSString.m</a>中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    if (NSStringClass == Nil)</span><br><span class="line">        NSStringClass = [NSString class];</span><br><span class="line">    return RETAIN(self);</span><br><span class="line">&#125;</span><br><span class="line">- (id)mutableCopyWithZone:(NSZone*)zone &#123;</span><br><span class="line">    return [[NSMutableString allocWithZone:zone] initWithString:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>NSString copy方法，返回的是self自身，属于浅拷贝<br>mutableCopyWithZone方法，返回新初始化的对象NSMutableString，所以是深拷贝</p><p><a href="https://searchcode.com/file/68838008/jni%20w:%20itoa%20runtime%20and%20allocator/Foundation/NSMutableString.m" target="_blank" rel="noopener">NSMutableString.m</a> 中只发现了copyWithZone:和copy:方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(id)copy &#123;</span><br><span class="line">    return [[NSString alloc] initWithString:self];</span><br><span class="line">&#125;</span><br><span class="line">-(id)copyWithZone:(NSZone*)zone &#123;</span><br><span class="line">    return [[NSString allocWithZone:zone] initWithString:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>NSMutableString copy方法，会变成深复制，因为返回的对象如源码所示，调用了 NSString 的全能初始化方法，并且由一个新的 NSString 持有。<br>在源码中并没有重写mutableCopy方法，也没有实现mutableCopyWithZone:方法，所以会调用父类的mutableCopyWithZone。而在父类中 mutableCopyWithZone:方法中调用了 NSMutableString 的全局初始化方法，所以依旧是深复制。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@interface Man : NSObject</span><br><span class="line">@property (nonatomic, strong) NSString *eat;</span><br><span class="line">@property (nonatomic, copy) NSString *drink;</span><br><span class="line">@end</span><br><span class="line">@implementation Man</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">  Man *man = [[Man alloc] init];</span><br><span class="line">  NSMutableString *str = [NSMutableString stringWithFormat:@&quot;山珍海味&quot;];</span><br><span class="line"></span><br><span class="line">  man.eat = str;</span><br><span class="line">  man.drink = str;</span><br><span class="line">  NSLog(@&quot;%@-%@&quot;,man.eat,man.drink); // 山珍海味-山珍海味</span><br><span class="line"></span><br><span class="line">  [str appendString:@&quot;白开水&quot;];</span><br><span class="line">  NSLog(@&quot;%@-%@&quot;,man.eat,man.drink); //山珍海味白开水-山珍海味</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q 经典面试题：为什么 NSString 类型成员变量的修饰属性用 copy 而不是 strong (或 retain ) ？</p><p>A 当我们通过一个 NSMutableString 对 NSString 变量进行赋值，如果 NSString 的 property 是 strong 类型的时候，就会随着 NSMutableString 类型的变量一起变化。<br>strong修饰，仅仅是指针引用，增加了引用计数器</p><h2 id="阅读链接"><a href="#阅读链接" class="headerlink" title="阅读链接"></a>阅读链接</h2><p><a href="http://www.desgard.com/copy/" target="_blank" rel="noopener">http://www.desgard.com/copy/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://pattyxp.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>weak底层源码解析</title>
    <link href="https://pattyxp.github.io/2018/01/09/weak%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://pattyxp.github.io/2018/01/09/weak底层源码解析/</id>
    <published>2018-01-09T06:20:56.000Z</published>
    <updated>2018-01-10T03:12:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文分析是runtime源码 <a href="https://github.com/isaacselement/objc4-706" target="_blank" rel="noopener">objc4-706版本</a><br>OC code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// NSObject *obj = ...;</span><br><span class="line">__weak id weakPtr = obj;</span><br></pre></td></tr></table></figure></p><p>底层转为源码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// NSObject *obj = ...;</span><br><span class="line">objc_initWeak(&amp;weakPtr, obj);</span><br></pre></td></tr></table></figure></p><p>来看下NSObject.mm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_initWeak(id *location, id newObj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 这里传递了三个 bool 数值</span><br><span class="line">    // 使用 template 进行常量参数传递是为了优化性能</span><br><span class="line">    return storeWeak&lt;false/*old*/, true/*new*/, true/*crash*/&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续阅读 storeWeak() 的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">// HaveOld: true - 变量有值</span><br><span class="line">// false - 需要被及时清理，当前值可能为 nil</span><br><span class="line">// HaveNew: true - 需要被分配的新值，当前值可能为 nil</span><br><span class="line">// false - 不需要分配新值</span><br><span class="line">// CrashIfDeallocating: true - 说明 newObj 已经释放或者 newObj 不支持弱引用，该过程需要暂停</span><br><span class="line">// false - 用 nil 替代存储</span><br><span class="line"></span><br><span class="line">template &lt;bool HaveOld, bool HaveNew, bool CrashIfDeallocating&gt;</span><br><span class="line">static id</span><br><span class="line">storeWeak(id *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(HaveOld  ||  HaveNew);</span><br><span class="line">    if (!HaveNew) assert(newObj == nil);</span><br><span class="line">    // 用于标记已经初始化的类</span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">     // 声明新旧辅助表</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line">    // 获取新旧值（存在的话）的辅助表，并且加锁，</span><br><span class="line">    // 如果新旧值辅助表同时存在时，以锁的地址大小排序，防止锁的顺序问题</span><br><span class="line"> retry:</span><br><span class="line">    if (HaveOld) &#123;</span><br><span class="line">        // 如果有旧值的话，通过指针获取目标对象，  Q： 旧值的情况是不是指这个地址*location之前存的值？？？</span><br><span class="line">        // 再以目标对象的地址为索引，取得旧值对应的辅助表</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (HaveNew) &#123;</span><br><span class="line">        // 如果有新值，以新值的地址为索引，取得新值对应的辅助表</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SideTable::lockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    if (HaveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        // 线程冲突处理，</span><br><span class="line">        // 如果有旧值，但 location 指向的对象不为 oldObj，那很可能被其它线程修改过，</span><br><span class="line">        // 解锁并重试</span><br><span class="line">        SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (HaveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        if (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized())</span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">            _class_initialize(_class_getNonMetaClass(cls, (id)newObj));</span><br><span class="line"></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Clean up old value, if any.</span><br><span class="line">    // 从 oldObj 的弱引用条目删除弱引用的地址</span><br><span class="line">    if (HaveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Assign new value, if any.</span><br><span class="line">    // 把弱引用的地址注册到 newObj 的弱引用条目</span><br><span class="line">    if (HaveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table,</span><br><span class="line">                                                      (id)newObj, location,</span><br><span class="line">                                                      CrashIfDeallocating);</span><br><span class="line">        // weak_register_no_lock returns nil if weak store should be rejected</span><br><span class="line"></span><br><span class="line">        // Set is-weakly-referenced bit in refcount table.</span><br><span class="line">        if (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Do not set *location anywhere else. That would introduce a race.</span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // No new value. The storage is not changed.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    return (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li>SideTable 这个结构体 : 主要用于管理对象的引用计数和 weak 表</li><li>&amp;SideTables()[oldObj] : 根据对象的地址在缓存中取出对应的 SideTable 实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在取出实例方法的实现中，使用了 C++ 标准转换运算符 reinterpret_cast ，其表达方式为</p><blockquote><p>reinterpret_cast <new_type> (expression)<br>用来处理无关类型之间的转换。该关键字会产生一个新值，并保证与原参数（expression）拥有完全相同的比特位。</new_type></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="阅读链接"><a href="#阅读链接" class="headerlink" title="阅读链接"></a>阅读链接</h2><p><a href="http://www.desgard.com/weak/" target="_blank" rel="noopener">http://www.desgard.com/weak/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文分析是runtime源码 &lt;a href=&quot;https://github.com/isaacselement/objc4-706&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;objc4-706版本&lt;/a&gt;&lt;br&gt;OC code&lt;br&gt;&lt;figure 
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://pattyxp.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
