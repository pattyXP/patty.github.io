<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温暖的弦</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pattyxp.github.io/"/>
  <updated>2019-02-24T04:40:49.246Z</updated>
  <id>https://pattyxp.github.io/</id>
  
  <author>
    <name>Patty</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git实用命令</title>
    <link href="https://pattyxp.github.io/2019/02/24/Git%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://pattyxp.github.io/2019/02/24/Git实用命令/</id>
    <published>2019-02-24T04:05:38.000Z</published>
    <updated>2019-02-24T04:40:49.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="暂存区-与-HEAD-差异"><a href="#暂存区-与-HEAD-差异" class="headerlink" title="暂存区 与 HEAD 差异"></a>暂存区 与 HEAD 差异</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><h2 id="暂存区与工作区差异"><a href="#暂存区与工作区差异" class="headerlink" title="暂存区与工作区差异"></a>暂存区与工作区差异</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br><span class="line">git diff -- &lt;filename1&gt;  &lt;filename2&gt; 对多个文件比较差异</span><br></pre></td></tr></table></figure><h2 id="暂存区恢复至HEAD一样"><a href="#暂存区恢复至HEAD一样" class="headerlink" title="暂存区恢复至HEAD一样"></a>暂存区恢复至HEAD一样</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD  先将文件恢复至unstaged</span><br></pre></td></tr></table></figure><p>然后可以使用<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status      查看是否已经恢复至工作区了</span><br><span class="line">或者</span><br><span class="line">git diff --cached 可以直接比较暂存区与HEAD的差异</span><br></pre></td></tr></table></figure></p><ul><li>取消暂存区的部分文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD -- &lt;filename1&gt; &lt;filename2&gt;</span><br></pre></td></tr></table></figure><h2 id="工作区恢复至暂存区"><a href="#工作区恢复至暂存区" class="headerlink" title="工作区恢复至暂存区"></a>工作区恢复至暂存区</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt; 在工作区丢弃变更</span><br></pre></td></tr></table></figure><p>然后比较下 暂存区与工作区的差异<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure></p><h2 id="消除最近的几次提交"><a href="#消除最近的几次提交" class="headerlink" title="消除最近的几次提交"></a>消除最近的几次提交</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commitID</span><br></pre></td></tr></table></figure><blockquote><p>commitID是要消除的提交的父节点的id</p></blockquote><h2 id="查看不同提交的指定文件的差异"><a href="#查看不同提交的指定文件的差异" class="headerlink" title="查看不同提交的指定文件的差异"></a>查看不同提交的指定文件的差异</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;branch&gt; &lt;branch&gt; -- &lt;filename&gt;</span><br></pre></td></tr></table></figure><blockquote><p>branch 也可以替换为对应的commitID</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;暂存区-与-HEAD-差异&quot;&gt;&lt;a href=&quot;#暂存区-与-HEAD-差异&quot; class=&quot;headerlink&quot; title=&quot;暂存区 与 HEAD 差异&quot;&gt;&lt;/a&gt;暂存区 与 HEAD 差异&lt;/h2&gt;&lt;figure class=&quot;highlight shel
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>技术栈</title>
    <link href="https://pattyxp.github.io/2019/02/20/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <id>https://pattyxp.github.io/2019/02/20/技术栈/</id>
    <published>2019-02-20T02:50:34.000Z</published>
    <updated>2019-02-20T03:40:49.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OC的技术栈"><a href="#OC的技术栈" class="headerlink" title="OC的技术栈"></a>OC的技术栈</h2><h3 id="RunTime"><a href="#RunTime" class="headerlink" title="RunTime"></a>RunTime</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><img src="/images/技术栈-数据结构.png" alt="技术栈-数据结构"><br>参考文章: <a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/</a></p><h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p><img src="/images/技术栈-方法缓存.png" alt="技术栈-方法缓存"><br><img src="/images/技术栈-类对象与元类对象.png" alt="技术栈-类对象与元类对象"><br><img src="/images/技术栈-消息方法.png" alt="技术栈-消息方法"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"resolveInstanceMethod:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"forwardingTargetForSelector:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"methodSignatureForSelector:"</span>);</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v@:"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"forwardInvocation:"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><img src="/images/技术栈-UI.png" alt="技术栈-UI"></p><h4 id="绘制与离屏渲染"><a href="#绘制与离屏渲染" class="headerlink" title="绘制与离屏渲染"></a>绘制与离屏渲染</h4><p><img src="/images/技术栈-UI渲染.png" alt="技术栈-UI渲染"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;OC的技术栈&quot;&gt;&lt;a href=&quot;#OC的技术栈&quot; class=&quot;headerlink&quot; title=&quot;OC的技术栈&quot;&gt;&lt;/a&gt;OC的技术栈&lt;/h2&gt;&lt;h3 id=&quot;RunTime&quot;&gt;&lt;a href=&quot;#RunTime&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图片瘦身工具推荐</title>
    <link href="https://pattyxp.github.io/2019/01/03/%E5%9B%BE%E7%89%87%E7%98%A6%E8%BA%AB%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <id>https://pattyxp.github.io/2019/01/03/图片瘦身工具推荐/</id>
    <published>2019-01-03T02:13:33.000Z</published>
    <updated>2019-01-03T05:55:22.012Z</updated>
    
    <content type="html"><![CDATA[<p>项目瘦身，实际可以考虑出发的点无非就是资源文件和代码</p><h2 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h2><p>资源文件主要就是图片资源，其他的音频、视频等资源较少</p><p>图片清理包括</p><ul><li>无用的资源文件</li><li>重复的资源文件</li><li>图片压缩</li><li>On-Demand Resource（根据需要从服务端下载）</li></ul><ol><li>无用的资源文件，就是需要将项目内的资源文件和项目内使用到的资源进行对比，差值就是未使用到的资源了</li></ol><p>推荐一个开源的Mac app<em>LSUnusedResources</em>，来进行冗余图片的排查。<br>这个 App 的原理是，对某一文件目录下所有的源代码文件进行扫描，用正则表达式匹配出所有的@”xxx”字符串（会根据不同类型的源代码文件使用不同的匹配规则），形成“使用到的图片的集合”，然后扫描所有的图片文件名，查看哪些图片文件名不在“使用到的图片的集合”中，然后将这些图片文件呈现在结果中。</p><p>但是可能图片命令规范不一致，需要自己确认再删除，以免误删<br>故修改对应的正则，使之满足自己项目即可。</p><ol><li>重复的资源文件</li></ol><p>重复资源（主要指图片）不是指命名重复而是内容相同。<br>fdupes 是Linux下的一个工具，可以在指定的目录及子目录中查找重复的文件。fdupes通过对比文件的大小,MD5签名，以及逐字节比较文件来识别重复内容。</p><p>fdupes安装: brew install fdupes<br>fdupes使用可自行查找</p><ol><li>图片压缩</li></ol><p>ImageOptim是一款优秀的无损图片压缩工具，它通过优化压缩参数，移除无用的文件元数据和不必要的颜色配置来实现图片的无损压缩。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>包瘦身推荐:<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5NzMwODI0MA==&amp;mid=2647761547&amp;idx=1&amp;sn=2f84d8b9eeb134ed0c5cb7142ef0caa9&amp;chksm=8887d9b4bff050a2cc850ab243282f25894cc5eae5596e1b3ad52a6a69de030bbc571d1f74be#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5NzMwODI0MA==&amp;mid=2647761547&amp;idx=1&amp;sn=2f84d8b9eeb134ed0c5cb7142ef0caa9&amp;chksm=8887d9b4bff050a2cc850ab243282f25894cc5eae5596e1b3ad52a6a69de030bbc571d1f74be#rd</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目瘦身，实际可以考虑出发的点无非就是资源文件和代码&lt;/p&gt;
&lt;h2 id=&quot;资源文件&quot;&gt;&lt;a href=&quot;#资源文件&quot; class=&quot;headerlink&quot; title=&quot;资源文件&quot;&gt;&lt;/a&gt;资源文件&lt;/h2&gt;&lt;p&gt;资源文件主要就是图片资源，其他的音频、视频等资源较少&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019Flag</title>
    <link href="https://pattyxp.github.io/2019/01/02/2019Flag/"/>
    <id>https://pattyxp.github.io/2019/01/02/2019Flag/</id>
    <published>2019-01-02T05:49:40.000Z</published>
    <updated>2019-01-02T05:55:19.306Z</updated>
    
    <content type="html"><![CDATA[<p>2019年到了，刚过完元旦，立立Flag<br>回想去年，自己买了好几本技术书籍，就看完了一本，过后也没有再翻阅几遍。<br>懒真的是随着年龄越来越大越严重了，不过今年天气还真是太冷了</p><p>2019年展望<br>1.多看技术书籍，买来的书籍要常翻阅，3个月看完一本不算长吧<br>2.算法学习<br>3.技术栈扩展<br>3.语言:swift学习，写些工具</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019年到了，刚过完元旦，立立Flag&lt;br&gt;回想去年，自己买了好几本技术书籍，就看完了一本，过后也没有再翻阅几遍。&lt;br&gt;懒真的是随着年龄越来越大越严重了，不过今年天气还真是太冷了&lt;/p&gt;
&lt;p&gt;2019年展望&lt;br&gt;1.多看技术书籍，买来的书籍要常翻阅，3个月看完一本
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>atomic引发的思考</title>
    <link href="https://pattyxp.github.io/2019/01/02/atomic%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://pattyxp.github.io/2019/01/02/atomic引发的思考/</id>
    <published>2019-01-02T03:03:58.000Z</published>
    <updated>2019-01-02T05:56:25.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p>大家都知道atomic 代表的原子性操作，</p><p>原子性操作仅仅是针对赋值和读取的操作，objc源码里赋值操作和读取操作，都加上了锁操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    if (offset == 0) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot = (id*) ((char*)self + offset);</span><br><span class="line"></span><br><span class="line">    if (copy) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:nil];</span><br><span class="line">    &#125; else if (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (*slot == newValue) return;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123;</span><br><span class="line">    if (offset == 0) &#123;</span><br><span class="line">        return object_getClass(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Retain release world</span><br><span class="line">    id *slot = (id*) ((char*)self + offset);</span><br><span class="line">    if (!atomic) return *slot;</span><br><span class="line">        </span><br><span class="line">    // Atomic retain release world</span><br><span class="line">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    id value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();</span><br><span class="line">    </span><br><span class="line">    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span><br><span class="line">    return objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这并不能够保证整个对象的线程安全,这里仅仅是在读取和赋值的时候是线程安全的，但是如果在多线程的环境下，却不是线程安全的，为什么呢？<br>举个网上的例子:</p><p>当线程A进行写操作，这时其他线程的读或者写操作会因为该操作而等待。<br>当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获得了在B线程中的值，这就破坏了线程安全，如果有线程C在A线程读操作前release了该属性，那么还会导致程序崩溃。所以仅仅使用atomic并不会使得线程安全，我们还要为线程添加lock来确保线程的安全。</p><h2 id="nonatomic"><a href="#nonatomic" class="headerlink" title="nonatomic"></a>nonatomic</h2><p>对于某个属性来说，声明的时候我们一般是声明为nonatomic 非原子性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) &lt;#type#&gt; &lt;#name#&gt;;</span><br></pre></td></tr></table></figure><h2 id="atomic和nonatomic对比"><a href="#atomic和nonatomic对比" class="headerlink" title="atomic和nonatomic对比"></a>atomic和nonatomic对比</h2><p>atomic和nonatomic用来决定编译器生成的getter和setter是否为原子操作。</p><p>atomic: 系统生成的 getter/setter 会保证 get、set 操作的完整性，不受其他线程影响。但是在多线程环境下不能保证整个对象是线程安全的</p><p>nonatomic: nonatomic返回的对象可能就不是完整的value。但是速度却更快</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;atomic&quot;&gt;&lt;a href=&quot;#atomic&quot; class=&quot;headerlink&quot; title=&quot;atomic&quot;&gt;&lt;/a&gt;atomic&lt;/h2&gt;&lt;p&gt;大家都知道atomic 代表的原子性操作，&lt;/p&gt;
&lt;p&gt;原子性操作仅仅是针对赋值和读取的操作，objc源码
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mmap的KVO</title>
    <link href="https://pattyxp.github.io/2018/08/30/mmap%E7%9A%84KVO/"/>
    <id>https://pattyxp.github.io/2018/08/30/mmap的KVO/</id>
    <published>2018-08-30T02:10:56.000Z</published>
    <updated>2018-08-30T02:47:51.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先来了解下-NSData相关的分类属性和方法"><a href="#先来了解下-NSData相关的分类属性和方法" class="headerlink" title="先来了解下 NSData相关的分类属性和方法"></a>先来了解下 <code>NSData</code>相关的分类属性和方法</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSData</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>, <span class="title">NSSecureCoding</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> length;</span><br><span class="line"><span class="comment">/*返回data对象的首指针*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="keyword">const</span> <span class="keyword">void</span> *bytes <span class="built_in">NS_RETURNS_INNER_POINTER</span>;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSData</span> (<span class="title">NSExtendedData</span>)</span></span><br><span class="line"><span class="comment">/*返回一个ASCII编码格式的字符串，采用的格式是data属性列表的格式*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *description;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*取出data中指定长度的字节存入buffer这个提前声明的数组中*/</span></span><br><span class="line">- (<span class="keyword">void</span>)getBytes:(<span class="keyword">void</span> *)buffer length:(<span class="built_in">NSUInteger</span>)length;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*取出data中指定位置range的字节存入buffer这个提前声明的数组中*/</span></span><br><span class="line">- (<span class="keyword">void</span>)getBytes:(<span class="keyword">void</span> *)buffer range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="mman-h"><a href="#mman-h" class="headerlink" title="mman.h"></a>mman.h</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*取消映射*/</span></span><br><span class="line"><span class="keyword">int</span>munmap(<span class="keyword">void</span> *, size_t) __DARWIN_ALIAS(munmap);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;先来了解下-NSData相关的分类属性和方法&quot;&gt;&lt;a href=&quot;#先来了解下-NSData相关的分类属性和方法&quot; class=&quot;headerlink&quot; title=&quot;先来了解下 NSData相关的分类属性和方法&quot;&gt;&lt;/a&gt;先来了解下 &lt;code&gt;NSData&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>reloadSection的坑</title>
    <link href="https://pattyxp.github.io/2018/07/06/reloadSection%E7%9A%84%E5%9D%91/"/>
    <id>https://pattyxp.github.io/2018/07/06/reloadSection的坑/</id>
    <published>2018-07-06T07:23:30.000Z</published>
    <updated>2018-07-06T07:56:07.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在做需求的时候，之前类似的页面也做过，没有发现在<code>reloadSections</code>的时候有抖动的情况，但是此次就是出现了，没办法，自己的坑自己填</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>第一次在添加<code>self.tableView.estimatedRowHeight = xx;</code> 之后发现已经正常了，开心</p><p>再次操作发现又出现问题了</p><p>网上查了翻资料，有说将高度进行缓存操作，在<code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath</code>进行缓存，在<code>heightForRow</code>方法进行取，取不到再存</p><p>结合两者，终于不抖动了</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>一般情况下，抖动都是因为预估高度和实际高度不对导致的，通过设置预估高度都能达到效果，此次实践发现还有缓存高度的事，真神奇</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在做需求的时候，之前类似的页面也做过，没有发现在&lt;code&gt;reloadSections&lt;/code&gt;的时候有抖动的情况，但是此次就是出现了
      
    
    </summary>
    
    
      <category term="填坑" scheme="https://pattyxp.github.io/tags/%E5%A1%AB%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>WWDC-Notification</title>
    <link href="https://pattyxp.github.io/2018/07/02/WWDC-Notification/"/>
    <id>https://pattyxp.github.io/2018/07/02/WWDC-Notification/</id>
    <published>2018-07-02T13:00:00.000Z</published>
    <updated>2018-07-05T02:04:16.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2018年WWDC召开至今， 围绕User Notification相关的iOS12特性主要<br>针对用户体验带来的分组通知及相关交互，下面围绕以下几点展开说明</p><ul><li>Grouped Notifications</li><li>Notification content extensions</li><li>Notification management</li><li>Provisional authorization</li><li>Critical alerts<a id="more"></a><h3 id="Grouped-Notifications"><a href="#Grouped-Notifications" class="headerlink" title="Grouped Notifications"></a>Grouped Notifications</h3></li></ul><p><img src="/images/WWDC-group1.png" alt="WWDC-group1"></p><p>iOS12 之后</p><p><img src="/images/WWDC-group2.png" alt="WWDC-group2"></p><p>同一APP的通知可被合成一个通知组，点击可以展开组里的通知<br>通知的分组可以采用两种方式实现:</p><ul><li>自动实现 （Automatic grouping）系统根据APP的bundle id 分组，开发者不需要进行额外操作</li><li>线程标识 （Thread identifier） <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本地通知</span></span><br><span class="line"><span class="keyword">let</span> content = <span class="type">UNMutableNotificationContent</span>()</span><br><span class="line">content.title = <span class="string">"New Photo"</span></span><br><span class="line">content.body = <span class="string">"Jane Doe posted a new photo"</span></span><br><span class="line">content.threadIdentifier = <span class="string">"thread-identifier"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程通知</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aps"</span> : &#123;</span><br><span class="line">        <span class="string">"alert"</span> : &#123;</span><br><span class="line">            <span class="string">"title"</span> : <span class="string">"New Photo"</span>,</span><br><span class="line">            <span class="string">"body"</span> : <span class="string">"Jane Doe posted a new photo"</span>,</span><br><span class="line">            <span class="string">"thread-id"</span> : <span class="string">"thread-identifier"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/WWDC-group3.png" alt="WWDC-group3"></p><p>用户可以在设置里控制管理方式<br><img src="/images/WWDC-group4.png" alt="WWDC-group4"><br><img src="/images/WWDC-group5.png" alt="WWDC-group5"></p><h3 id="Notification-content-extensions"><a href="#Notification-content-extensions" class="headerlink" title="Notification content extensions"></a>Notification content extensions</h3><p>此特性在iOS 10就出现了,用于自定义通知视图的样式,在iOS 12上针对此做了提升</p><p><img src="/images/WWDC-group12.png" alt="WWDC-group12"></p><ul><li>在plist中设置属性，会影响通知界面的交互功能</li></ul><p><img src="/images/WWDC-group13.png" alt="WWDC-group13"></p><p><img src="/images/WWDC-group14.png" alt="WWDC-group14"></p><ul><li>默认中间部分交互是没有的，需要在plist表中增加属性<code>UNNotificationExtensionUserInteractionEnabled</code>为<code>YES</code></li></ul><p><img src="/images/WWDC-group15.png" alt="WWDC-group15"></p><ul><li>notificationActions<br><code>notificationActions</code>允许获取用户当前的操作，更新新的操作</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSExtensionContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">12.0</span>, *)</span><br><span class="line">    <span class="keyword">var</span> notificationActions: [<span class="type">UNNotificationAction</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notification Content Extensions</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationViewController</span>: <span class="title">UIViewController</span>, <span class="title">UNNotificationContentExtension</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> response: UNNotificationResponse, completionHandler completion:</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="params">(UNNotificationContentExtensionResponseOption)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> response.actionIdentifier == <span class="string">"like-action"</span> &#123;</span><br><span class="line">            <span class="comment">// Update state...</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> unlikeAction = <span class="type">UNNotificationAction</span>(identifier: <span class="string">"unlike-action"</span>,</span><br><span class="line">                                                             title: <span class="string">"Unlike"</span>, options: [])</span><br><span class="line">                <span class="keyword">let</span> currentActions = extensionContext?.notificationActions</span><br><span class="line">                <span class="keyword">let</span> commentAction = currentActions![<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">let</span> newActions = [ unlikeAction, commentAction ]</span><br><span class="line">                extensionContext?.notificationActions = newActions</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>添加Actions</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> likeAction = <span class="type">UNNotificationAction</span>(identifier: <span class="string">"like-action"</span>,</span><br><span class="line">                                           title: <span class="string">"Like"</span>,</span><br><span class="line">                                         options: [])</span><br><span class="line"><span class="keyword">let</span> commentAction = <span class="type">UNTextInputNotificationAction</span>(identifier: <span class="string">"comment-action"</span>,</span><br><span class="line">                                                       title: <span class="string">"Comment"</span>,</span><br><span class="line">                                                     options: [],</span><br><span class="line">                                        textInputButtonTitle: <span class="string">"Comment"</span>,</span><br><span class="line">                                        textInputPlaceholder: <span class="string">"Type here..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> category = <span class="type">UNNotificationCategory</span>(identifier: <span class="string">"extension-example"</span>,</span><br><span class="line">                                         actions: [ likeAction, commentAction ],</span><br><span class="line">                               intentIdentifiers: [],</span><br><span class="line">                                         options: [])</span><br><span class="line"></span><br><span class="line"><span class="type">UNUserNotificationCenter</span>.current().setNotificationCategories([ category ])</span><br></pre></td></tr></table></figure></li><li><p>处理Actions</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UserNotifications</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppDelegate</span>: <span class="title">UNUserNotificationCenterDelegate</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">userNotificationCenter</span><span class="params">(<span class="number">_</span> center: UNUserNotificationCenter,</span></span></span><br><span class="line"><span class="function"><span class="params">            didReceive response: UNNotificationResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">            withCompletionHandler completionHandler: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Handle action response here</span></span><br><span class="line">            <span class="keyword">if</span> response.actionIdentifier == <span class="string">"like-action"</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                likeLabel?.text = <span class="string">"You liked this photo"</span></span><br><span class="line">                likedPhoto()</span><br><span class="line">            &#125;</span><br><span class="line">            completion(.doNotDismiss)</span><br><span class="line">            completion(.dismiss)</span><br><span class="line">            completion(.dismissAndForward)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动App</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSExtensionContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@available</span>(iOS <span class="number">12.0</span>, *)</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">performNotificationDefaultAction</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UserNotificationsUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationViewController</span>: <span class="title">UIViewController</span>, <span class="title">UNNotificationContentExtension</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@IBOutlet</span> <span class="keyword">var</span> allCommentsButton: <span class="type">UIButton</span>?</span><br><span class="line">        ...</span><br><span class="line">        allCommentsButton?.addTarget(<span class="keyword">self</span>, action: #selector(launchApp), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">        ...</span><br><span class="line">        <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">launchApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">              extensionContext?.performNotificationDefaultAction()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>隐藏通知内容扩展界面<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSExtensionContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">12.0</span>, *)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dismissNotificationContentExtension</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UserNotificationsUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationViewController</span>: <span class="title">UIViewController</span>, <span class="title">UNNotificationContentExtension</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> likeButton: <span class="type">UIButton</span>?</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    likeButton?.addTarget(<span class="keyword">self</span>, action: #selector(likeButtonTapped), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">likeButtonTapped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        likedPhoto()</span><br><span class="line">        extensionContext?.dismissNotificationContentExtension()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>需要注意的是，调用这个 API 并不会移除那条通知，如果需要移除通知可以调用下面的 API<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UNUserNotificationCenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeDeliveredNotifications</span><span class="params">(withIdentifiers identifiers: [String])</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Notification-management"><a href="#Notification-management" class="headerlink" title="Notification management"></a>Notification management</h3><p>为方便用户操作应用的设置通知页面，在推送页面上加入了全新的管理页面方便操作</p><p><img src="/images/WWDC-group6.png" alt="WWDC-group6"></p><ul><li>隐式通知 (Deliver Quietly )    只会显示在通知中心，不会带有声音提醒，应用角标</li><li>显式推送（Deliver Prominently） 显示推送会开启所有的通知选项。</li></ul><p>管理页面的入口有三种方式进入</p><ul><li>系统根据用户操作自动给出<br><img src="/images/WWDC-group7.png" alt="WWDC-group7"></li><li>左滑通知<br><img src="/images/WWDC-group8.png" alt="WWDC-group8"></li><li>点击通知详情<br><img src="/images/WWDC-group9.png" alt="WWDC-group9"></li></ul><p>当然，在新的通知管理页面，iOS12 提供了新的方法可以根据需要自定义，当点击页面的按钮操作<br>可以通过以下方法获取该行为<br><img src="/images/WWDC-group10.png" alt="WWDC-group10"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> UserNotifications</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIApplicationDelegate</span>, <span class="title">UNUserNotificationCenterDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userNotificationCenter</span><span class="params">(<span class="number">_</span> center: UNUserNotificationCenter, openSettingsFor notification: UNNotification? )</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Provisional-authorization"><a href="#Provisional-authorization" class="headerlink" title="Provisional authorization"></a>Provisional authorization</h3><p>ios 12 提供了一种新的授权机制:临时授权<br>给用户推送的消息不需要通过用户授权弹窗，不过只能隐式推送给用户，不带系统声音和角标<br>在代码中只需要设置参数<code>provisional</code>即可</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Requesting Provisional Authorization</span></span><br><span class="line"><span class="keyword">let</span> notificationCenter = <span class="type">UNUserNotificationCenter</span>.current()</span><br><span class="line">    </span><br><span class="line">    notificationCenter.requestAuthorization(</span><br><span class="line">        options:[.badge, .sound, .alert, .provisional]) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Critical-alerts"><a href="#Critical-alerts" class="headerlink" title="Critical alerts"></a>Critical alerts</h3><p>在勿扰模式或关闭铃声的情况下依然可以收到重要的通知或App设置的铃声</p><blockquote><p>此类通知是需要用户里面采取行动的如医疗与健康相关的通知，家庭安全相关的通知，公共安全相关的通知</p></blockquote><p>如果需要设置，需要前往<a href="https://developer.apple.com/contact/request/?notifications-critical-alerts-entitlement/" target="_blank" rel="noopener">申请授权</a></p><p>在通知的设置页面会有单独的设置开关<br><img src="/images/WWDC-group11.png" alt="WWDC-group11"></p><p>如需要设置，在代码中需要设置参数<code>criticalAlert</code>，用户会收到单独的重要提醒授权<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> notificationCenter = <span class="type">UNUserNotificationCenter</span>.current()</span><br><span class="line"></span><br><span class="line">    notificationCenter.requestAuthorization(</span><br><span class="line">        options:[.sound, .badge, .alert, .criticalAlert]) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地重要通知</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Critical alert with default sound</span></span><br><span class="line"><span class="keyword">let</span> content = <span class="type">UNMutableNotificationContent</span>()</span><br><span class="line">content.title = <span class="string">"WARNING: LOW BLOOD SUGAR"</span></span><br><span class="line">content.body = <span class="string">"Glucose level at 57."</span></span><br><span class="line">content.categoryIdentifier = <span class="string">"low-glucose—alert"</span></span><br><span class="line"><span class="comment">// 使用系统默认的重要提醒音</span></span><br><span class="line">content.sound = <span class="type">UNNotificationSound</span>.defaultCritical</span><br><span class="line"><span class="comment">// 使用自定义的重要提醒音和音量</span></span><br><span class="line">content.sound = <span class="type">UNNotificationSound</span>.criticalSoundNamed(@<span class="string">"warning-sound"</span> withAudioVolume: <span class="number">1.00</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程重要通知</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aps"</span> : &#123;</span><br><span class="line">        <span class="string">"sound"</span> : &#123;</span><br><span class="line">            <span class="string">"critical"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"warning-sound.aiff"</span>,</span><br><span class="line">            <span class="string">"volume"</span>: <span class="number">1.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://devstreaming-cdn.apple.com/videos/wwdc/2018/710kz0ncc1u8bfxn6/710/710_whats_new_in_user_notifications.pdf" target="_blank" rel="noopener">https://devstreaming-cdn.apple.com/videos/wwdc/2018/710kz0ncc1u8bfxn6/710/710_whats_new_in_user_notifications.pdf</a></p><p><a href="https://juejin.im/post/5b1b7c3de51d4506ca62d787" target="_blank" rel="noopener">https://juejin.im/post/5b1b7c3de51d4506ca62d787</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2018年WWDC召开至今， 围绕User Notification相关的iOS12特性主要&lt;br&gt;针对用户体验带来的分组通知及相关交互，下面围绕以下几点展开说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Grouped Notifications&lt;/li&gt;
&lt;li&gt;Notification content extensions&lt;/li&gt;
&lt;li&gt;Notification management&lt;/li&gt;
&lt;li&gt;Provisional authorization&lt;/li&gt;
&lt;li&gt;Critical alerts
    
    </summary>
    
    
      <category term="WWDC" scheme="https://pattyxp.github.io/tags/WWDC/"/>
    
  </entry>
  
  <entry>
    <title>YYModel解析</title>
    <link href="https://pattyxp.github.io/2018/06/20/YYModel%E8%A7%A3%E6%9E%90/"/>
    <id>https://pattyxp.github.io/2018/06/20/YYModel解析/</id>
    <published>2018-06-20T06:10:04.000Z</published>
    <updated>2018-06-21T02:51:26.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>Model的定义与实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYTemplateModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> type;   </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span>  *templateNames;      </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span>  *templateId;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>  *items;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYTemplateModel</span></span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)modelContainerPropertyGenericClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">             <span class="string">@"items"</span>: [YYItem <span class="keyword">class</span>]</span><br><span class="line">             &#125;;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)modelCustomPropertyMapper &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">             <span class="string">@"name"</span>: @[<span class="string">@"name"</span>, <span class="string">@"Name"</span>],</span><br><span class="line">             <span class="string">@"templateNames"</span>:@[<span class="string">@"templateName"</span>],         </span><br><span class="line">             <span class="string">@"templateId"</span>:<span class="string">@"id"</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际在使用中，通常是将Model与json进行相互转换</p><h2 id="YYModel-解析流程"><a href="#YYModel-解析流程" class="headerlink" title="YYModel 解析流程"></a>YYModel 解析流程</h2><h3 id="yy-modelToJSONObject-NSObject-YYModel-m-model转为json"><a href="#yy-modelToJSONObject-NSObject-YYModel-m-model转为json" class="headerlink" title="yy_modelToJSONObject (NSObject+YYModel.m)  model转为json"></a>yy_modelToJSONObject (NSObject+YYModel.m)  model转为json</h3><p>实际是对<code>ModelToJSONObjectRecursive</code>封装</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)yy_modelToJSONObject &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Apple said:</span></span><br><span class="line"><span class="comment">     The top level object is an NSArray or NSDictionary.</span></span><br><span class="line"><span class="comment">     All objects are instances of NSString, NSNumber, NSArray, NSDictionary, or NSNull.</span></span><br><span class="line"><span class="comment">     All dictionary keys are instances of NSString.</span></span><br><span class="line"><span class="comment">     Numbers are not NaN or infinity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">id</span> jsonObject = ModelToJSONObjectRecursive(<span class="keyword">self</span>); </span><br><span class="line">    <span class="comment">//对Model进行类型判断，符合指定类型才返回，否则返回nil</span></span><br><span class="line">    <span class="comment">//返回值类型包括 NSString,NSNumber，NSArray,NSDictionary,or NSNull</span></span><br><span class="line">    <span class="keyword">if</span> ([jsonObject isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> jsonObject;</span><br><span class="line">    <span class="keyword">if</span> ([jsonObject isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> jsonObject;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ModelToJSONObjectRecursive"><a href="#ModelToJSONObjectRecursive" class="headerlink" title="ModelToJSONObjectRecursive"></a>ModelToJSONObjectRecursive</h3><p>将Object转为json并返回</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> ModelToJSONObjectRecursive(<span class="built_in">NSObject</span> *model) &#123;</span><br><span class="line">    <span class="comment">//进行基础类型判断，如果满足直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!model || model == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSURL</span> *)model).absoluteString;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSAttributedString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSAttributedString</span> *)model).string;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDate</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> [YYISODateFormatter() stringFromDate:(<span class="keyword">id</span>)model];</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是自定义类型判断</span></span><br><span class="line"></span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model <span class="keyword">class</span>]];</span><br><span class="line">    <span class="comment">//根据model转为YYModelMeta,，此处对modelMeta的获取和设置都有加信号量控制，防止出现线程问题</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!modelMeta || modelMeta-&gt;_keyMappedCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *result = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">64</span>];</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSMutableDictionary</span> *dic = result; <span class="comment">// avoid retain and release in block</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历mapper</span></span><br><span class="line">    [modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!propertyMeta-&gt;_<span class="keyword">getter</span>) <span class="keyword">return</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_isCNumber) &#123; <span class="comment">//匹配CNumber类型</span></span><br><span class="line">            value = ModelCreateNumberFromProperty(model, propertyMeta);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMeta-&gt;_nsType) &#123; <span class="comment">//大部分情况执行</span></span><br><span class="line">            <span class="keyword">id</span> v = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);<span class="comment">//从model获取对应属性propertyMeta的值，赋值给V</span></span><br><span class="line">            value = ModelToJSONObjectRecursive(v); <span class="comment">//对V的类型做判断，如果是基础类型直接返回赋值给value</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeObject: &#123;</span><br><span class="line">                    <span class="keyword">id</span> v = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = ModelToJSONObjectRecursive(v);</span><br><span class="line">                    <span class="keyword">if</span> (value == (<span class="keyword">id</span>)kCFNull) value = <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeClass: &#123;</span><br><span class="line">                    Class v = ((Class (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromClass</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeSEL: &#123;</span><br><span class="line">                    SEL v = ((SEL (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromSelector</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!value) <span class="keyword">return</span>; <span class="comment">//非空判断</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyPath) &#123; </span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *superDic = dic;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *subDic = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *key = propertyMeta-&gt;_mappedToKeyPath[i];</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> == max) &#123; <span class="comment">// end</span></span><br><span class="line">                    <span class="keyword">if</span> (!superDic[key]) superDic[key] = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                subDic = superDic[key];</span><br><span class="line">                <span class="keyword">if</span> (subDic) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ([subDic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                        subDic = subDic.mutableCopy;</span><br><span class="line">                        superDic[key] = subDic;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    subDic = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">                    superDic[key] = subDic;</span><br><span class="line">                &#125;</span><br><span class="line">                superDic = subDic;</span><br><span class="line">                subDic = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//大部分情况</span></span><br><span class="line">            <span class="keyword">if</span> (!dic[propertyMeta-&gt;_mappedToKey]) &#123;</span><br><span class="line">                dic[propertyMeta-&gt;_mappedToKey] = value;  <span class="comment">//dic 赋值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomTransformToDictionary) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> suc = [((<span class="keyword">id</span>&lt;YYModel&gt;)model) modelCustomTransformToDictionary:dic];</span><br><span class="line">        <span class="keyword">if</span> (!suc) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// result = dic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ModelToJSONObjectRecursive</code>方法总结</p><ul><li>判断基础类型，直接返回</li><li>自定义类型，初始化生成<code>YYModelMeta</code>实例</li><li>遍历mapper方法，执行propertyMeta的getter方法，将返回值赋给dic返回</li></ul><h3 id="YYModelMeta初始化"><a href="#YYModelMeta初始化" class="headerlink" title="YYModelMeta初始化"></a>YYModelMeta初始化</h3><p><img src="/images/YYModelMeta初始化.png" alt="YYModelMeta初始化"></p><p><code>- (instancetype)initWithClass:(Class)cls</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithClass:(Class)cls &#123;</span><br><span class="line">    //初始化YYClassInfo</span><br><span class="line">    YYClassInfo *classInfo = [YYClassInfo classInfoWithClass:cls];</span><br><span class="line">    if (!classInfo) return nil;</span><br><span class="line">    self = [super init];</span><br><span class="line">    </span><br><span class="line">    // Get black list 判断当前类是否实现黑名单</span><br><span class="line">    NSSet *blacklist = nil;</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelPropertyBlacklist)]) &#123;</span><br><span class="line">        NSArray *properties = [(id&lt;YYModel&gt;)cls modelPropertyBlacklist]; //获取黑名单数组</span><br><span class="line">        if (properties) &#123; </span><br><span class="line">            blacklist = [NSSet setWithArray:properties]; //赋值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Get white list  判断当前类是否实现白名单</span><br><span class="line">    NSSet *whitelist = nil;</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelPropertyWhitelist)]) &#123;</span><br><span class="line">        NSArray *properties = [(id&lt;YYModel&gt;)cls modelPropertyWhitelist];</span><br><span class="line">        if (properties) &#123;</span><br><span class="line">            whitelist = [NSSet setWithArray:properties];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Get container property&apos;s generic class</span><br><span class="line">    //判断当前类是否实现属性与类对应方法</span><br><span class="line">    NSDictionary *genericMapper = nil;</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelContainerPropertyGenericClass)]) &#123;</span><br><span class="line">        genericMapper = [(id&lt;YYModel&gt;)cls modelContainerPropertyGenericClass];</span><br><span class="line">        if (genericMapper) &#123; //获取到实现的字典</span><br><span class="line">            NSMutableDictionary *tmp = [NSMutableDictionary new]; </span><br><span class="line">            // 遍历字典</span><br><span class="line">            [genericMapper enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">                if (![key isKindOfClass:[NSString class]]) return; //如果key不满足类型，返回</span><br><span class="line">                Class meta = object_getClass(obj); //返回obj的isa所指向的类</span><br><span class="line">                if (!meta) return;</span><br><span class="line">                if (class_isMetaClass(meta)) &#123; //如果是元类</span><br><span class="line">                    tmp[key] = obj;  //赋值</span><br><span class="line">                &#125; else if ([obj isKindOfClass:[NSString class]]) &#123; //如果obj是NSString</span><br><span class="line">                    Class cls = NSClassFromString(obj); //转为Cls</span><br><span class="line">                    if (cls) &#123;</span><br><span class="line">                        tmp[key] = cls; //赋值Cls</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">            genericMapper = tmp; //赋值genericMapper</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Create all property metas. 遍历所有属性含父类，但忽略 NSObject/NSProxy类</span><br><span class="line">    NSMutableDictionary *allPropertyMetas = [NSMutableDictionary new];</span><br><span class="line">    //allPropertyMetas 存储所以属性对应的propertyMeta</span><br><span class="line"></span><br><span class="line">    YYClassInfo *curClassInfo = classInfo;</span><br><span class="line">    //遍历至根类，将所有的属性进行赋值</span><br><span class="line">    while (curClassInfo &amp;&amp; curClassInfo.superCls != nil) &#123; // recursive parse super class, but ignore root class (NSObject/NSProxy)</span><br><span class="line">        for (YYClassPropertyInfo *propertyInfo in curClassInfo.propertyInfos.allValues) &#123;</span><br><span class="line">            if (!propertyInfo.name) continue;</span><br><span class="line">            if (blacklist &amp;&amp; [blacklist containsObject:propertyInfo.name]) continue;</span><br><span class="line">            if (whitelist &amp;&amp; ![whitelist containsObject:propertyInfo.name]) continue;</span><br><span class="line"></span><br><span class="line">            // 根据classInfo propertyInfo genericMapper初始化YYModelPropertyMeta</span><br><span class="line">            _YYModelPropertyMeta *meta = [_YYModelPropertyMeta metaWithClassInfo:classInfo</span><br><span class="line">                                                                    propertyInfo:propertyInfo</span><br><span class="line">                                                                         generic:genericMapper[propertyInfo.name]];</span><br><span class="line">            if (!meta || !meta-&gt;_name) continue;</span><br><span class="line">            if (!meta-&gt;_getter || !meta-&gt;_setter) continue;</span><br><span class="line">            if (allPropertyMetas[meta-&gt;_name]) continue;</span><br><span class="line">            allPropertyMetas[meta-&gt;_name] = meta;</span><br><span class="line">        &#125;</span><br><span class="line">        curClassInfo = curClassInfo.superClassInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    if (allPropertyMetas.count) _allPropertyMetas = allPropertyMetas.allValues.copy;</span><br><span class="line">    </span><br><span class="line">    // create mapper</span><br><span class="line">    NSMutableDictionary *mapper = [NSMutableDictionary new];</span><br><span class="line">    NSMutableArray *keyPathPropertyMetas = [NSMutableArray new];</span><br><span class="line">    NSMutableArray *multiKeysPropertyMetas = [NSMutableArray new];</span><br><span class="line">    </span><br><span class="line">    //实现对应的自定义属性方法</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelCustomPropertyMapper)]) &#123;</span><br><span class="line">        NSDictionary *customMapper = [(id &lt;YYModel&gt;)cls modelCustomPropertyMapper];//获取实现方法的字典</span><br><span class="line">        [customMapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyName, NSString *mappedToKey, BOOL *stop) &#123;</span><br><span class="line">            //获取属性列表中对应属性的meta</span><br><span class="line">            _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName];</span><br><span class="line">            if (!propertyMeta) return; //如果不存在return掉</span><br><span class="line">            [allPropertyMetas removeObjectForKey:propertyName];//如果存在自定义属性，先从属性列表中删除</span><br><span class="line">            </span><br><span class="line">            if ([mappedToKey isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">                  /** 根据上面示例源码</span><br><span class="line">                     mappedToKey:  id</span><br><span class="line">                    */</span><br><span class="line">                if (mappedToKey.length == 0) return;</span><br><span class="line">                </span><br><span class="line">                propertyMeta-&gt;_mappedToKey = mappedToKey; //赋值mappedToKey</span><br><span class="line">                NSArray *keyPath = [mappedToKey componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">                for (NSString *onePath in keyPath) &#123;</span><br><span class="line">                    if (onePath.length == 0) &#123;</span><br><span class="line">                        NSMutableArray *tmp = keyPath.mutableCopy;</span><br><span class="line">                        [tmp removeObject:@&quot;&quot;]; //将空值移除</span><br><span class="line">                        keyPath = tmp;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (keyPath.count &gt; 1) &#123; //对应多个.</span><br><span class="line">                    propertyMeta-&gt;_mappedToKeyPath = keyPath;</span><br><span class="line">                    [keyPathPropertyMetas addObject:propertyMeta];</span><br><span class="line">                &#125;</span><br><span class="line">                propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;</span><br><span class="line">                mapper[mappedToKey] = propertyMeta;</span><br><span class="line">                </span><br><span class="line">                /** mapper</span><br><span class="line">                mapper:</span><br><span class="line">                &#123;</span><br><span class="line">                     id = &quot;&lt;_YYModelPropertyMeta: 0x6040006eb800&gt;&quot;;</span><br><span class="line">                     (</span><br><span class="line">                        templateName</span><br><span class="line">                     ) = &quot;&lt;_YYModelPropertyMeta: 0x604000ae6980&gt;&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                */</span><br><span class="line">            &#125; else if ([mappedToKey isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">                /** 根据上面示例源码</span><br><span class="line">                mappedToKey:</span><br><span class="line">                &lt;__NSSingleObjectArrayI 0x600000204190&gt;(</span><br><span class="line">                    templateName</span><br><span class="line">                )</span><br><span class="line">                */</span><br><span class="line">                NSMutableArray *mappedToKeyArray = [NSMutableArray new];</span><br><span class="line">                for (NSString *oneKey in ((NSArray *)mappedToKey)) &#123;</span><br><span class="line">                    if (![oneKey isKindOfClass:[NSString class]]) continue;</span><br><span class="line">                    if (oneKey.length == 0) continue;</span><br><span class="line">                    </span><br><span class="line">                    NSArray *keyPath = [oneKey componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">                    if (keyPath.count &gt; 1) &#123;</span><br><span class="line">                        [mappedToKeyArray addObject:keyPath];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        [mappedToKeyArray addObject:oneKey];</span><br><span class="line">                        /** mappedToKeyArray:</span><br><span class="line">                        &lt;__NSArrayM 0x60400685ee70&gt;(</span><br><span class="line">                            templateName</span><br><span class="line">                        )</span><br><span class="line">                        */</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    if (!propertyMeta-&gt;_mappedToKey) &#123;</span><br><span class="line">                        propertyMeta-&gt;_mappedToKey = oneKey; //赋值mappedToKey</span><br><span class="line">                        propertyMeta-&gt;_mappedToKeyPath = keyPath.count &gt; 1 ? keyPath : nil;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!propertyMeta-&gt;_mappedToKey) return; //判断如果为空，return</span><br><span class="line">                </span><br><span class="line">                propertyMeta-&gt;_mappedToKeyArray = mappedToKeyArray; //赋值mappedToKeyArray</span><br><span class="line">                [multiKeysPropertyMetas addObject:propertyMeta];// 赋值multiKeysPropertyMetas</span><br><span class="line">                </span><br><span class="line">                propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;</span><br><span class="line">                mapper[mappedToKey] = propertyMeta; </span><br><span class="line">                /**</span><br><span class="line">                mapper:</span><br><span class="line">                &#123;</span><br><span class="line">                         (</span><br><span class="line">                         templateName</span><br><span class="line">                        ) = &quot;&lt;_YYModelPropertyMeta: 0x604000ae6980&gt;&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                */</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [allPropertyMetas enumerateKeysAndObjectsUsingBlock:^(NSString *name, _YYModelPropertyMeta *propertyMeta, BOOL *stop) &#123;</span><br><span class="line">        propertyMeta-&gt;_mappedToKey = name; //赋值_mappedToKey</span><br><span class="line">        propertyMeta-&gt;_next = mapper[name] ?: nil;</span><br><span class="line">        mapper[name] = propertyMeta; //赋值mapper 此时mapper内元素数量是和当前Model的属性数量一致的</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    if (mapper.count) _mapper = mapper; </span><br><span class="line">    if (keyPathPropertyMetas) _keyPathPropertyMetas = keyPathPropertyMetas;</span><br><span class="line">    if (multiKeysPropertyMetas) _multiKeysPropertyMetas = multiKeysPropertyMetas;</span><br><span class="line">    </span><br><span class="line">    _classInfo = classInfo;</span><br><span class="line">    _keyMappedCount = _allPropertyMetas.count;</span><br><span class="line">    _nsType = YYClassGetNSType(cls);</span><br><span class="line">    _hasCustomWillTransformFromDictionary = ([cls instancesRespondToSelector:@selector(modelCustomWillTransformFromDictionary:)]);</span><br><span class="line">    _hasCustomTransformFromDictionary = ([cls instancesRespondToSelector:@selector(modelCustomTransformFromDictionary:)]);</span><br><span class="line">    _hasCustomTransformToDictionary = ([cls instancesRespondToSelector:@selector(modelCustomTransformToDictionary:)]);</span><br><span class="line">    _hasCustomClassFromDictionary = ([cls respondsToSelector:@selector(modelCustomClassForDictionary:)]);</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>YYModelMeta</code>初始化方法总结</p><ul><li>初始化YYClassInfo, 内部初始化会实现superClassInfo的赋值 直到根类</li><li>解析内部实现的方法如黑名单，白名单</li><li>解析方法modelContainerPropertyGenericClass，此方法较常见<br> genericMapper字典存储该方法内对指定字段的替换，如通常情况下是<code>items</code>字段，数组类型，内部包含相同类型的model<br> 比如genericMapper:<br>  {<pre><code>items = YYItem;</code></pre>  }</li><li>while循环，allPropertyMetas字典存储当前classInfo对象的属性，并循环到父类的所有属性（直到superCls != nil）<br>  比如allPropertyMetas:<br>  {<br>  items = “<_yymodelpropertymeta: 0x6000004e1700="">“;<br>  type = “<_yymodelpropertymeta: 0x6000008f7c00="">“;<br>  templateNames = “<_yymodelpropertymeta: 0x6000008a5c02="">“;<br>  templateId =  “<_yymodelpropertymeta: 0x6000008b2a00="">“;<br>  }</_yymodelpropertymeta:></_yymodelpropertymeta:></_yymodelpropertymeta:></_yymodelpropertymeta:></li><li>解析方法modelCustomPropertyMapper<br>  赋值每个propertyMeta的mappedToKey/mappedToKeyPath/next/_mappedToKeyArray<br>  赋值mapper  如<code>mapper[mappedToKey] = propertyMeta;</code></li><li>遍历allPropertyMetas字典 将对应propertyMeta 正确赋值 ，mapper数组添加每个遍历到的propertyMeta保证mapper数组内元素和当前Model的属性一致</li><li>剩余的属性赋值</li></ul><p>此时可以查看到 当前Model的mapper值<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mapper:</span><br><span class="line">&#123;</span><br><span class="line">    items = <span class="string">"&lt;_YYModelPropertyMeta: 0x6000004f3300&gt;"</span>;</span><br><span class="line">    <span class="keyword">id</span> = <span class="string">"&lt;_YYModelPropertyMeta: 0x6000006e9a00&gt;"</span>;</span><br><span class="line">    type = <span class="string">"&lt;_YYModelPropertyMeta: 0x6000008efc80&gt;"</span>;</span><br><span class="line">    (</span><br><span class="line">        templateName,</span><br><span class="line">        templateNames</span><br><span class="line">    ) = <span class="string">"&lt;_YYModelPropertyMeta: 0x6000008eeb00&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>补下照<br><img src="/images/YYModelPropertyMeta初始化.png" alt="YYModelPropertyMeta初始化"></p><p>以上是初始化方法，那么实际使用，就需要开始运用这些属性了</p><p>通常在解析拿到的json数据，调用方法<code>yy_modelWithDictionary</code></p><h3 id="yy-modelWithDictionary-json转Model"><a href="#yy-modelWithDictionary-json转Model" class="headerlink" title="yy_modelWithDictionary  json转Model"></a>yy_modelWithDictionary  json转Model</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)yy_modelWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionary &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dictionary || dictionary == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">nil</span>;  <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span> (![dictionary isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">//不是字典类型，直接返回</span></span><br><span class="line">    </span><br><span class="line">    Class cls = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:cls]; <span class="comment">//获取model对应的YYModelMeta，如果已经初始化，直接从缓存字典获取</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomClassFromDictionary) &#123;</span><br><span class="line">        cls = [cls modelCustomClassForDictionary:dictionary] ?: cls;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *one = [cls new];</span><br><span class="line">    <span class="keyword">if</span> ([one yy_modelSetWithDictionary:dictionary]) <span class="keyword">return</span> one;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部封装<code>yy_modelSetWithDictionary</code><br>方法调用栈如下<br><img src="/images/YYModel解析底层.png" alt="YYModel解析底层"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)yy_modelSetWithDictionary:(<span class="built_in">NSDictionary</span> *)dic &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dic || dic == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(<span class="keyword">self</span>)];</span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_keyMappedCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>; <span class="comment">//如果没有属性，返回</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在这里能修改数据源字典</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomWillTransformFromDictionary) &#123;</span><br><span class="line">        dic = [((<span class="keyword">id</span>&lt;YYModel&gt;)<span class="keyword">self</span>) modelCustomWillTransformFromDictionary:dic];</span><br><span class="line">        <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ModelSetContext context = &#123;<span class="number">0</span>&#125;; <span class="comment">//上下文的几个属性都赋值给context</span></span><br><span class="line">    context.modelMeta = (__bridge <span class="keyword">void</span> *)(modelMeta);</span><br><span class="line">    context.model = (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>);</span><br><span class="line">    context.dictionary = (__bridge <span class="keyword">void</span> *)(dic);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_keyMappedCount &gt;= <span class="built_in">CFDictionaryGetCount</span>((<span class="built_in">CFDictionaryRef</span>)dic)) &#123;</span><br><span class="line">        <span class="built_in">CFDictionaryApplyFunction</span>((<span class="built_in">CFDictionaryRef</span>)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class="line">        <span class="keyword">if</span> (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class="line">            <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class="line">                                 <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="built_in">CFArrayGetCount</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class="line">            <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class="line">                                 <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="built_in">CFArrayGetCount</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_allPropertyMetas,</span><br><span class="line">                             <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, modelMeta-&gt;_keyMappedCount),</span><br><span class="line">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                             &amp;context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123;</span><br><span class="line">        <span class="keyword">return</span> [((<span class="keyword">id</span>&lt;YYModel&gt;)<span class="keyword">self</span>) modelCustomTransformFromDictionary:dic];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ModelSetWithPropertyMetaArrayFunction"><a href="#ModelSetWithPropertyMetaArrayFunction" class="headerlink" title="ModelSetWithPropertyMetaArrayFunction"></a>ModelSetWithPropertyMetaArrayFunction</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Apply function for model property meta, to set dictionary to model.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param _propertyMeta should not be nil, _YYModelPropertyMeta.</span></span><br><span class="line"><span class="comment"> @param _context      _context.model and _context.dictionary should not be nil.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ModelSetWithPropertyMetaArrayFunction(<span class="keyword">const</span> <span class="keyword">void</span> *_propertyMeta, <span class="keyword">void</span> *_context) &#123;</span><br><span class="line">    ModelSetContext *context = _context;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSDictionary</span> *dictionary = (__bridge <span class="built_in">NSDictionary</span> *)(context-&gt;dictionary);</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *propertyMeta = (__bridge _YYModelPropertyMeta *)(_propertyMeta);</span><br><span class="line">    <span class="keyword">if</span> (!propertyMeta-&gt;_<span class="keyword">setter</span>) <span class="keyword">return</span>; <span class="comment">//propertyMeta没有setter方法，返回</span></span><br><span class="line">    <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyArray) &#123;   <span class="comment">// 多个key对应同一属性赋值</span></span><br><span class="line">        value = YYValueForMultiKeys(dictionary, propertyMeta-&gt;_mappedToKeyArray);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyPath) &#123;  <span class="comment">// keyPath赋值</span></span><br><span class="line">        value = YYValueForKeyPath(dictionary, propertyMeta-&gt;_mappedToKeyPath);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = [dictionary objectForKey:propertyMeta-&gt;_mappedToKey];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model = (__bridge <span class="keyword">id</span>)(context-&gt;model);</span><br><span class="line">        ModelSetValueForProperty(model, value, propertyMeta); <span class="comment">//属性赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ModelSetWithDictionaryFunction"><a href="#ModelSetWithDictionaryFunction" class="headerlink" title="ModelSetWithDictionaryFunction"></a>ModelSetWithDictionaryFunction</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ModelSetWithDictionaryFunction(<span class="keyword">const</span> <span class="keyword">void</span> *_key, <span class="keyword">const</span> <span class="keyword">void</span> *_value, <span class="keyword">void</span> *_context) &#123;</span><br><span class="line">    ModelSetContext *context = _context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据上下文结构体 ModelSetContext 取出 _YYModelMeta / _YYModelPropertyMeta / model</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelMeta *meta = (__bridge _YYModelMeta *)(context-&gt;modelMeta);</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *propertyMeta = [meta-&gt;_mapper objectForKey:(__bridge <span class="keyword">id</span>)(_key)];</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model = (__bridge <span class="keyword">id</span>)(context-&gt;model);</span><br><span class="line">    <span class="keyword">while</span> (propertyMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_<span class="keyword">setter</span>) &#123; <span class="comment">//调用对应的setter方法赋值model的value属性</span></span><br><span class="line">            ModelSetValueForProperty(model, (__bridge __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>)_value, propertyMeta);</span><br><span class="line">            <span class="comment">//底层调用msg_send方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        propertyMeta = propertyMeta-&gt;_next;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li>CFArrayApplyFunction<br>为数组内指定范围的每个元素调用一次指定的方法,上面指定的方法有<code>ModelSetWithPropertyMetaArrayFunction</code>/<code>ModelSetWithDictionaryFunction</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体上YYmodel数据解析</p><ul><li>根据cls进行初始化生成model对应的<code>YYModelMeta</code>，包含mapper,里面含有每个属性（YYModelPropertyMeta）</li><li>根据对应的json 与 YYModelMeta 进行相互转换赋值，会进行各种类型及判空处理</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h2&gt;&lt;p&gt;Model的定义与实现&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dispatch系列</title>
    <link href="https://pattyxp.github.io/2018/06/07/Dispatch%E7%B3%BB%E5%88%97/"/>
    <id>https://pattyxp.github.io/2018/06/07/Dispatch系列/</id>
    <published>2018-06-07T01:46:16.000Z</published>
    <updated>2018-06-07T02:48:17.572Z</updated>
    
    <content type="html"><![CDATA[<p>本系列源码地址 <a href="https://opensource.apple.com/tarballs/libdispatch" target="_blank" rel="noopener">libdispatch</a><br>研读版本 <code>libdispatch-339.92.1</code></p><p>思维导图<br><img src="/images/dispatch重要函数.png" alt="dispatch重要函数"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本系列源码地址 &lt;a href=&quot;https://opensource.apple.com/tarballs/libdispatch&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;libdispatch&lt;/a&gt;&lt;br&gt;研读版本 &lt;code&gt;libdispa
      
    
    </summary>
    
    
      <category term="Dispatch" scheme="https://pattyxp.github.io/tags/Dispatch/"/>
    
  </entry>
  
  <entry>
    <title>Objc-protocol实现原理</title>
    <link href="https://pattyxp.github.io/2018/05/22/Objc-protocol%E5%8E%9F%E7%90%86/"/>
    <id>https://pattyxp.github.io/2018/05/22/Objc-protocol原理/</id>
    <published>2018-05-22T09:24:40.000Z</published>
    <updated>2018-05-24T03:29:27.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文直接运行的是runtime Objc4-706版本，debug-objc的target，mac运行</p><p>本篇研究以下问题</p><ul><li>Protocol的实现原理</li></ul><p>若要查看category实现原理，请自行查阅之前的<a href="https://pattyxp.github.io/2018/02/11/Objc-category%E7%AF%87/">博客</a></p><p>源码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt;pig.h</span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">pigProtocol</span></span></span><br><span class="line">- (<span class="keyword">void</span>)updateAge;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Pig</span> : <span class="title">NSObject</span>&lt;<span class="title">pigProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line">+ (<span class="keyword">id</span>)createPig;</span><br><span class="line">- (<span class="keyword">void</span>)updateAge;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">&gt;pig.m</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Pig</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)createPig</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> new];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)updateAge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.age = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"对象age:%@"</span>,<span class="keyword">self</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">&gt;main.m</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Pig *pigObject = [Pig createPig];</span><br><span class="line">        [pigObject updateAge];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先在整个应用中，在main函数打上断点，可以观察到最初函数调用栈如图<br><img src="/images/OC4-init.png" alt="OC4-init"></p><p>在<code>objc-runtime-new.mm</code>文件 L:2284 方法<code>_read_images</code>内有对<code>protocol</code>、<code>category</code>等的赋值操作<br><code>_read_images</code>方法是从当前镜像内加载相应的类及其属性</p><p>在方法内部<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">        Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">        assert(cls);</span><br><span class="line">        NXMapTable *protocol_map = protocols(); <span class="comment">//创建表</span></span><br><span class="line">        <span class="keyword">bool</span> isPreoptimized = hi-&gt;isPreoptimized();</span><br><span class="line">        <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line"></span><br><span class="line">        protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            readProtocol(protolist[i], cls, protocol_map, </span><br><span class="line">                         isPreoptimized, isBundle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>protocols()</code>内部实现是有个静态变量，判断是否存在表，不存在就创建<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NXMapTable *protocols(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> NXMapTable *protocol_map = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    INIT_ONCE_PTR(protocol_map, </span><br><span class="line">                  NXCreateMapTable(NXStrValueMapPrototype, <span class="number">16</span>), </span><br><span class="line">                  NXFreeMapTable(v) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> protocol_map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>_getObjc2ProtocolList</code>获取该路径下的协议列表，此处没有源码<br>下面还有个重要的方法<code>readProtocol</code><br>可以先看下里面的一些变量，这里很多协议都会走这里，如<code>NSCopying</code>、<code>NSCoding</code><br><img src="/images/OC4-protocol.png" alt="OC4-protocol"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readProtocol(protocol_t *newproto, Class protocol_class,</span><br><span class="line">             NXMapTable *protocol_map, </span><br><span class="line">             <span class="keyword">bool</span> headerIsPreoptimized, <span class="keyword">bool</span> headerIsBundle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This is not enough to make protocols in unloaded bundles safe, </span></span><br><span class="line">    <span class="comment">// but it does prevent crashes when looking up unrelated protocols.</span></span><br><span class="line">    auto insertFn = headerIsBundle ? NXMapKeyCopyingInsert : NXMapInsert;</span><br><span class="line"></span><br><span class="line">    protocol_t *oldproto = (protocol_t *)getProtocol(newproto-&gt;mangledName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldproto) &#123;  <span class="comment">//如果存在oldproto 结束</span></span><br><span class="line">        <span class="comment">// Some other definition already won.</span></span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s  "</span></span><br><span class="line">                         <span class="string">"(duplicate of %p)"</span>,</span><br><span class="line">                         newproto, oldproto-&gt;nameForLogging(), oldproto);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (headerIsPreoptimized) &#123;</span><br><span class="line">        <span class="comment">// Shared cache initialized the protocol object itself, </span></span><br><span class="line">        <span class="comment">// but in order to allow out-of-cache replacement we need </span></span><br><span class="line">        <span class="comment">// to add it to the protocol table now.</span></span><br><span class="line"></span><br><span class="line">        protocol_t *cacheproto = (protocol_t *)</span><br><span class="line">            getPreoptimizedProtocol(newproto-&gt;mangledName);</span><br><span class="line">        protocol_t *installedproto;</span><br><span class="line">        <span class="keyword">if</span> (cacheproto  &amp;&amp;  cacheproto != newproto) &#123;</span><br><span class="line">            <span class="comment">// Another definition in the shared cache wins (because </span></span><br><span class="line">            <span class="comment">// everything in the cache was fixed up to point to it).</span></span><br><span class="line">            installedproto = cacheproto;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This definition wins.</span></span><br><span class="line">            installedproto = newproto;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        assert(installedproto-&gt;getIsa() == protocol_class);</span><br><span class="line">        assert(installedproto-&gt;size &gt;= <span class="keyword">sizeof</span>(protocol_t));</span><br><span class="line">        insertFn(protocol_map, installedproto-&gt;mangledName, </span><br><span class="line">                 installedproto);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s"</span>, </span><br><span class="line">                         installedproto, installedproto-&gt;nameForLogging());</span><br><span class="line">            <span class="keyword">if</span> (newproto != installedproto) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s  "</span></span><br><span class="line">                             <span class="string">"(duplicate of %p)"</span>, </span><br><span class="line">                             newproto, installedproto-&gt;nameForLogging(), </span><br><span class="line">                             installedproto);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newproto-&gt;size &gt;= <span class="keyword">sizeof</span>(protocol_t)) &#123; <span class="comment">//如果新协议size大于96 sizeof(protocol_t)=96</span></span><br><span class="line">        <span class="comment">// New protocol from an un-preoptimized image</span></span><br><span class="line">        <span class="comment">// with sufficient storage. Fix it up in place.</span></span><br><span class="line">        <span class="comment">// fixme duplicate protocols from unloadable bundle</span></span><br><span class="line">        newproto-&gt;initIsa(protocol_class);  <span class="comment">// fixme pinned  //初始化isa</span></span><br><span class="line">        insertFn(protocol_map, newproto-&gt;mangledName, newproto);<span class="comment">// 插入协议到指定的protocol_map</span></span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s"</span>,</span><br><span class="line">                         newproto, newproto-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// New protocol from an un-preoptimized image </span></span><br><span class="line">        <span class="comment">// with insufficient storage. Reallocate it.</span></span><br><span class="line">        <span class="comment">// fixme duplicate protocols from unloadable bundle</span></span><br><span class="line">        size_t size = max(<span class="keyword">sizeof</span>(protocol_t), (size_t)newproto-&gt;size);</span><br><span class="line">        protocol_t *installedproto = (protocol_t *)calloc(size, <span class="number">1</span>);</span><br><span class="line">        memcpy(installedproto, newproto, newproto-&gt;size);</span><br><span class="line">        installedproto-&gt;size = (<span class="keyword">typeof</span>(installedproto-&gt;size))size;</span><br><span class="line">        </span><br><span class="line">        installedproto-&gt;initIsa(protocol_class);  <span class="comment">// fixme pinned</span></span><br><span class="line">        insertFn(protocol_map, installedproto-&gt;mangledName, installedproto);</span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s  "</span>, </span><br><span class="line">                         installedproto, installedproto-&gt;nameForLogging());</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s  "</span></span><br><span class="line">                         <span class="string">"(reallocated to %p)"</span>, </span><br><span class="line">                         newproto, installedproto-&gt;nameForLogging(), </span><br><span class="line">                         installedproto);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要监听自己需要的协议如<code>pigProtocol</code>，可以打断点<br><img src="/images/OC4-pigProtol断点.png" alt="OC4-pigProtol断点"><br><img src="/images/OC4-pigProtocol.png" alt="OC4-pigProtocol"></p><p>当协议存储在协议表之后，调用协议，其实就是方法查找的问题，可以看下之前的文章<em>消息的发送与查找</em><br><img src="/images/OC4-pigProtocol查找调用.png" alt="OC4-pigProtocol查找调用"></p><p>此处关于<code>NXMapTable</code>将在下章进行分析</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li><p>calloc<br>  <code>calloc()</code> 函数用来动态地分配内存空间并初始化为 0，其原型为：<br>  <code>void* calloc (size_t num, size_t size);</code></p><p>  <code>calloc()</code> 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</p><p>  【返回值】分配成功返回指向该内存的地址，失败则返回 NULL。</p><p>  <code>calloc()</code> 与 <code>malloc()</code>的一个重要区别是：<code>calloc()</code> 在动态分配完内存后，自动初始化该内存空间为零，而 <code>malloc()</code> 不初始化，里边数据是未知的垃圾数据</p></li><li><p>memcpy<br>  函数原型<code>void *memcpy(void*dest, const void *src, size_t n);</code><br>  由src指向地址为起始地址的连续n个字节的数据复制到以destin指向地址为起始地址的空间内。<br>  【返回值】函数返回一个指向dest的指针</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文直接运行的是runtime Objc4-706版本，debug-objc的target，mac运行&lt;/p&gt;
&lt;p&gt;本篇研究以下问题&lt;/p
      
    
    </summary>
    
    
      <category term="Objc" scheme="https://pattyxp.github.io/tags/Objc/"/>
    
  </entry>
  
  <entry>
    <title>Objc-load调查</title>
    <link href="https://pattyxp.github.io/2018/05/18/Objc-load%E8%B0%83%E6%9F%A5/"/>
    <id>https://pattyxp.github.io/2018/05/18/Objc-load调查/</id>
    <published>2018-05-18T09:28:19.000Z</published>
    <updated>2018-05-25T02:59:32.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇研究以下问题</p><ul><li>load方法调用时机和顺序问题</li><li>多个分类中有load方法是怎么处理的</li><li>为什么load方法不存在方法缓存覆盖问题</li></ul><p>先来看下load方法的加载时机<br>源码主要包含以下类:</p><ul><li>Pig类</li><li>PigCate1</li><li><p>PigCate2<br>每个类都包含<code>load</code>方法,打印当前<code>_cmd</code><br>在每个<code>load</code>处添加断点，函数调用栈如下<br>!(OC4-load)(/images/OC4-load.png)</p></li><li><p>load方法并不需要调用就会执行<br>从方法的调用栈可以知道，此时方法的调用顺序<br><code>load_images</code> 是镜像加载</p><blockquote><p>此处的镜像，一部分是系统准备的一些框架如CoreFoundation，还有很多的动态链接库</p></blockquote></li></ul><h3 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="comment">//判断是否存在load方法</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);<span class="comment">//准备加载load方法的工作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant) //调用load方法</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="prepare-load-methods"><a href="#prepare-load-methods" class="headerlink" title="prepare_load_methods"></a>prepare_load_methods</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> prepare_load_methods(<span class="keyword">const</span> headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);<span class="comment">//获取所有的类的列表</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">        <span class="comment">//remapClass 获取类对应的指针</span></span><br><span class="line">        <span class="comment">//schedule_class_load 递归调用当前(没有调用过load方法的类及其父类)加入列表中，优先加入父类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="comment">//将分类加入到列表中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="schedule-class-load"><a href="#schedule-class-load" class="headerlink" title="schedule_class_load"></a>schedule_class_load</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//保证当前类还没有调用load方法</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    <span class="comment">//优先调用当前类的父类加入到列表中</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将当前cls加入到loadable_classes列表中</span></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保父类的load方法优先于子类调用</p><h3 id="add-class-to-loadable-list"><a href="#add-class-to-loadable-list" class="headerlink" title="add_class_to_loadable_list"></a>add_class_to_loadable_list</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> add_class_to_loadable_list(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked(); <span class="comment">//递归锁</span></span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod(); <span class="comment">//获取cls的load方法</span></span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果当前数组已经存满，需要重新分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (<span class="keyword">struct</span> loadable_class *)</span><br><span class="line">            realloc(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用工作"><a href="#调用工作" class="headerlink" title="调用工作"></a>调用工作</h2><p>下次将重点分析下<code>call_load_methods()</code></p><h3 id="call-load-methods"><a href="#call-load-methods" class="headerlink" title="call_load_methods"></a>call_load_methods</h3><p>当在<code>load_images</code>方法内只调用一次<code>call_load_methods</code>,保证将所有含有load方法的类或分类全部调用load方法，按顺序先执行类方法，然后执行分类方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>; <span class="comment">//保证在load_images方法期间只执行一次该方法</span></span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush(); <span class="comment">//创建autoreleasePool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">//loadable_classes_used是全局静态变量，存储需要调用load方法的类数量</span></span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads(); <span class="comment">//分类加载load方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories); </span><br><span class="line"> </span><br><span class="line">    objc_autoreleasePoolPop(pool);      <span class="comment">//释放autoreleasePool</span></span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="call-class-loads"><a href="#call-class-loads" class="headerlink" title="call_class_loads"></a>call_class_loads</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> call_class_loads(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> loadable_class *classes = loadable_classes;</span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;  <span class="comment">//取出loadable_classes_used</span></span><br><span class="line">    loadable_classes = <span class="literal">nil</span>;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过遍历<code>for循环</code>取出所有已加载的类，取出对应的load方法地址<br>通过load方法的地址直接调用的load方法，而不是通过消息机制来调用的，所以不存在<em>方法覆盖</em>问题</p><h3 id="call-category-loads"><a href="#call-category-loads" class="headerlink" title="call_category_loads"></a>call_category_loads</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> call_category_loads(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, shift;</span><br><span class="line">    <span class="keyword">bool</span> new_categories_added = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> loadable_category *cats = loadable_categories;</span><br><span class="line">    <span class="keyword">int</span> used = loadable_categories_used;</span><br><span class="line">    <span class="keyword">int</span> allocated = loadable_categories_allocated;</span><br><span class="line">    loadable_categories = <span class="literal">nil</span>;</span><br><span class="line">    loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_categories_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        load_method_t load_method = (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123; </span><br><span class="line">            <span class="comment">//一般情况下都是类方法先于分类方法调用，但是万一存在分类先调用，此处保证如果类存在且可以加载，先调用类的方法如下</span></span><br><span class="line">            <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"LOAD: +[%s(%s) load]\n"</span>, </span><br><span class="line">                             cls-&gt;nameForLogging(), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            &#125;</span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compact detached list (order-preserving)</span></span><br><span class="line">    <span class="comment">//将已经执行完load方法的分类数量进行扣除</span></span><br><span class="line">    shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift++; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -= shift; <span class="comment">//减去相应加载完的分类数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy any new +load candidates from the new list to the detached list.</span></span><br><span class="line">    <span class="comment">//如果有新加载的类，则加入list中</span></span><br><span class="line">    new_categories_added = (loadable_categories_used &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">            cats = (<span class="keyword">struct</span> loadable_category *)</span><br><span class="line">                realloc(cats, allocated *</span><br><span class="line">                                  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the new list.</span></span><br><span class="line">    <span class="comment">//将新加载的类进行释放</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories) free(loadable_categories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reattach the (now augmented) detached list. </span></span><br><span class="line">    <span class="comment">// But if there's nothing left to load, destroy the list.</span></span><br><span class="line">    <span class="comment">//如果还有未加载完成的类，则赋值</span></span><br><span class="line">    <span class="comment">//如果都加载完，则清空列表</span></span><br><span class="line">    <span class="keyword">if</span> (used) &#123;</span><br><span class="line">        loadable_categories = cats;</span><br><span class="line">        loadable_categories_used = used;</span><br><span class="line">        loadable_categories_allocated = allocated;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats) free(cats);</span><br><span class="line">        loadable_categories = <span class="literal">nil</span>;</span><br><span class="line">        loadable_categories_used = <span class="number">0</span>;</span><br><span class="line">        loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loadable_categories_used != <span class="number">0</span>) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: %d categories still waiting for +load\n"</span>,</span><br><span class="line">                         loadable_categories_used);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_categories_added;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法调用栈如下<br>!(OC4_load_cate)(/images/OC4_load_cate.png)<br>流程上和加载类的<code>load</code>方法差不多，就不多说了</p><p>至此<code>call_load_methods</code>方法分析的差不多了</p><p>因此，<code>load</code>方法的调用时机可以总结如下</p><blockquote><p>在main方法调用之前，程序调用期间调用一次<br>父类优先子类调用<br>类优先分类</p></blockquote><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul><li>问题1<br>在调用分类的load方法源码中，存在部分理解问题<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有加载过的分类移除 `loadable_categories` 列表</span></span><br><span class="line">shift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cats[i].cat) &#123;</span><br><span class="line">        cats[i-shift] = cats[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shift++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">used -= shift;</span><br></pre></td></tr></table></figure></li></ul><p>在调用过程中，未进入过if条件，所以不知道是什么情况下进行移除操作的<br>假设cats列表存在4个分类<br>cats[0]、cats[1]、cats[2]、cats[3]<br>其中cats[0]、cats[2]的load方法已经加载过，所以相应的cat已经为nil<br>进行上面code执行结果</p><table><thead><tr><th>类</th><th style="text-align:left">条件</th><th style="text-align:center">结果赋值</th></tr></thead><tbody><tr><td>cats[0]</td><td style="text-align:left">加载过</td><td style="text-align:center">shifts=1</td></tr><tr><td>cats[1]</td><td style="text-align:left">未加载过</td><td style="text-align:center">cats[0]=cats[1]</td></tr><tr><td>cats[2]</td><td style="text-align:left">加载过</td><td style="text-align:center">shifts=2</td></tr><tr><td>cats[3]</td><td style="text-align:left">未加载过</td><td style="text-align:center">cats[0]=cats[2]</td></tr></tbody></table><p>经过调查，其实这里可以当做是一张表在操作<br>当未加载过的类，进行赋值操作如 <code>cats[0]=cats[1]</code> ，其实就是把cats[0]进行赋值，<br><code>cats[0]=cats[2]</code> 再次进行赋值，cat[2]的内容赋值给cats[0],之前的cats[1]就被移除了</p><ul><li>问题2<br>此处<code>loadable_categories_used</code>在最开始的时候已经取出赋值给<code>used</code>,然后重新赋为0<br>所以不明白为什么还会存在<code>loadable_categories_used &gt; 0</code>的情况<br>而且还重新开辟空间和赋值<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new_categories_added = (loadable_categories_used &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">            cats = (<span class="keyword">struct</span> loadable_category *)</span><br><span class="line">                realloc(cats, allocated *</span><br><span class="line">                                  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>在同一个镜像里面，<code>load_images</code>里面加入了递归锁<code>recursive_mutex_locker_t lock(loadMethodLock);</code><br>按理，前面<code>loadable_categories_used</code>已经清空了，但是存在一种可能，在<code>+laod</code>方法里面给类添加了分类及其<code>load</code><br>那么<code>loadable_categories_used</code>可能存在大于0的情况</p><h2 id="extennsion"><a href="#extennsion" class="headerlink" title="extennsion"></a>extennsion</h2><p>extension在源码中是找不到的，因为它存在于编译期，是类的一部分<br><em>extension一般用来隐藏类的私有信息</em><br><em>伴随源码产生</em>所以很多系统的类如<code>NSString</code>无法添加extension</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇研究以下问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;load方法调用时机和顺序问题&lt;/li&gt;
&lt;li&gt;多个分类中有load方法是怎么处理的&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="Objc" scheme="https://pattyxp.github.io/tags/Objc/"/>
    
  </entry>
  
  <entry>
    <title>Block的实现</title>
    <link href="https://pattyxp.github.io/2018/05/09/Block%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://pattyxp.github.io/2018/05/09/Block的实现/</id>
    <published>2018-05-09T02:16:02.000Z</published>
    <updated>2018-05-14T09:00:45.955Z</updated>
    
    <content type="html"><![CDATA[<p>在OC当中我们经常使用block，block的结构体如下<a href="http://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="noopener">摘自clang</a>:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_literal_1 &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa; <span class="comment">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor_1 &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;         <span class="comment">// NULL</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;         <span class="comment">// sizeof(struct Block_literal_1)</span></span><br><span class="line">        <span class="comment">// optional helper functions</span></span><br><span class="line">        <span class="keyword">void</span> (*copy_helper)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);     <span class="comment">// IFF (1&lt;&lt;25)</span></span><br><span class="line">        <span class="keyword">void</span> (*dispose_helper)(<span class="keyword">void</span> *src);             <span class="comment">// IFF (1&lt;&lt;25)</span></span><br><span class="line">        <span class="comment">// required ABI.2010.3.16</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *signature;                         <span class="comment">// IFF (1&lt;&lt;30)</span></span><br><span class="line">    &#125; *descriptor;</span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>对此可以看到 block主要由以下部分构成</p><ol><li>isa指针</li><li>flags 用于表示一些附加信息，如block copy之后需要判断使用</li><li>reserved 保留字段</li><li>invoke 函数指针，具体实现地址</li><li>Block_descriptor_1 结构体表示block的一些附加信息，如大小，copy，dispose函数指针以及方法签名等</li><li>imported variables 可能引入的外部变量(或变量的地址)</li></ol><p>block主要有以下三种类型<br>1._NSConcreteGlobalBlock 全局的静态 block，不会访问任何外部变量。<br>2._NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。<br>3._NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。</p><p>下面看下实现</p><h2 id="不引用外部变量"><a href="#不引用外部变量" class="headerlink" title="不引用外部变量"></a>不引用外部变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    block1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上c文件通过clang进行重写，得到如下精简代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*block1)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结下:</p><ul><li>isa 类型是<code>_NSConcreteStackBlock</code>,实际在打印的时候会发现类型是_NSConcreteGlobalBlock<br><img src="/images/block_globalBlock.png" alt="block_globalBlock"><br>这是因为 block 的存储区域，与定义在什么位置、是否引用外部变量、是否作为范围值、是被哪种类型的变量所接收等等相关</li><li><code>__main_block_impl_0</code> 是实际的函数指针，指向<code>__main_block_func_0</code></li><li><code>__main_block_func_0</code> 是函数具体实现地址</li></ul><h2 id="使用外部变量"><a href="#使用外部变量" class="headerlink" title="使用外部变量"></a>使用外部变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    &#125;;</span><br><span class="line">    block1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过clang重写之后<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main1_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main1_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  __main1_block_impl_0(<span class="keyword">void</span> *fp, struct __main1_block_desc_0 *desc, <span class="keyword">int</span> _a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main1_block_func_0(struct __main1_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> a = __cself-&gt;a; <span class="comment">// bound by copy  值拷贝</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main1_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main1_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main1_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (*block1)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main1_block_impl_0((<span class="keyword">void</span> *)__main1_block_func_0, &amp;__main1_block_desc_0_DATA, a));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以观察到:</p><ul><li>isa 指向<code>_NSConcreteStackBlock</code>，分配在栈上，实际打印发现是<code>_NSConcreteMallocBlock</code><br><img src="/images/block_mallocBlock.png" alt="block_mallocBlock"></li><li><code>__main1_block_impl_0</code> 中增加了一个变量 a，在 block 中引用的变量 a 实际是在申明 block 时，被复制到 <code>main_block_impl_0</code> 结构体中的那个变量a的瞬时值被copy到栈上，作为常量供Block使用。这样我们就能理解，在 block 内部修改变量 a 的内容，不会影响外部的实际变量 a</li><li><code>main_block_impl_0</code> 中由于增加了一个变量 a，所以结构体的大小变大了，该结构体大小被写在了 <code>main_block_desc_0</code> 中</li></ul><h2 id="修改上面的源码，在变量前面增加-block-关键字："><a href="#修改上面的源码，在变量前面增加-block-关键字：" class="headerlink" title="修改上面的源码，在变量前面增加__block 关键字："></a>修改上面的源码，在变量前面增加<code>__block</code> 关键字：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __block <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">        a = <span class="number">99</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    block1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"block之后的变量:%d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上c文件通过clang进行重写，得到如下精简代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_a_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_a_0 *a; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_a_0 *a = __cself-&gt;a; <span class="comment">// bound by ref  指针拷贝</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (a-&gt;__forwarding-&gt;a));</span><br><span class="line">  (a-&gt;__forwarding-&gt;a) = <span class="number">99</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;a, (<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_a_0 *)&amp;a, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_a_0), <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="keyword">void</span> (*block1)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, <span class="number">570425344</span>));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"block之后的变量:%d\n"</span>, (a.__forwarding-&gt;a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结下:</p><ul><li>增加新的结构体<code>__Block_byref_a_0</code>，存储了外部引用的变量a</li><li><code>__main_block_impl_0</code>引用的是<code>__Block_byref_a_0</code>结构体，用来改变外部变量a</li><li><code>__Block_byref_i_0</code>结构体带有isa,说明是一个对象</li><li><p>我们需要负责 Block_byref_i_0 结构体相关的内存管理，所以 main_block_desc_0 中增加了 copy 和 dispose 函数指针，对于在调用前后修改相应变量的引用计数。</p></li><li><p>为什么<strong>Block_byref_a_0结构体内使用指向其自身的指针</strong>forwarding<br>源码解析:<br><code>__main_block_func_0</code>使用的都是<code>(a-&gt;__forwarding-&gt;a)</code>，<br><strong>forwarding指针这里的作用就是针对堆的Block,原先栈上的`</strong>forwarding`指向自身结构体，当拷贝到堆上之后，换成指向_NSConcreteMallocBlock上复制之后的<strong>block,然后堆上的变量的</strong>forwarding再指向自己。这样不管<strong>block在堆上还是在栈上，都可以通过(a-&gt;</strong>forwarding-&gt;a)来访问到变量值。</p><p><img src="/images/block_forwarding.png" alt="block_forwarding"></p></li><li><p>NSConcreteStackBlock的例子<br>ARC下见到最多的是_NSConcreteMallocBlock，是因为我们会对Block有赋值操作<br>但是也存在<code>_NSConcreteStackBlock</code></p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> __block <span class="keyword">int</span> temp = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"*******%d %p"</span>,temp ++,&amp;temp);&#125;);</span><br></pre></td></tr></table></figure><p><img src="/images/block_stackBlock.png" alt="block_stackBlock"></p><h2 id="block-copy"><a href="#block-copy" class="headerlink" title="block_copy"></a>block_copy</h2><p>当block经过copy之后，系统会将block拷贝到堆上，此时block属于NSConcreteMallocBlock类型<br><a href="https://opensource.apple.com/source/clang/clang-137/src/projects/compiler-rt/BlocksRuntime/runtime.c" target="_blank" rel="noopener">具体源码在runtime.c</a></p><h2 id="block-的自动拷贝和手动拷贝"><a href="#block-的自动拷贝和手动拷贝" class="headerlink" title="block 的自动拷贝和手动拷贝"></a>block 的自动拷贝和手动拷贝</h2><p>那么 block 何时会 copy 到堆上呢？是显式，还是隐式？</p><ul><li>显式</li></ul><ol><li>在作为属性定义时，用 copy 和 strong 修饰；</li><li>手动调用 [block copy]；</li></ol><p>在开启ARC时，编译器通常会将创建在栈上的 block <strong>自动拷贝</strong>到堆上,除以下情况</p><blockquote><p>block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法；<br>方法/函数在内部已经实现了一份拷贝了 block 参数的代码，或者如果编译器自动拷贝，那么调用者就不需再手动拷贝，比如：</p></blockquote><ul><li>当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li><li>当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li><li>当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝;</li></ul><p>下面是自动拷贝的例子<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^blk_t)(<span class="keyword">int</span>);</span><br><span class="line">blk_t func(<span class="keyword">int</span> rate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ^(<span class="keyword">int</span> count)&#123;<span class="keyword">return</span> rate * count;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处的blk_t获取了局部变量,因此block创建在栈上<br>当func函数返回时，rate脱离作用范围，如果调用者使用时会出现问题。<br>那 ARC 开启的情况呢？运行这个 block 一切正常。和我们的预期结果不一样，ARC 到底给 block 施了什么魔法？</p><p>我们将上面的代码进行反编译<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _func(<span class="keyword">int</span> arg0) &#123;</span><br><span class="line">    rax = objc_retainBlock(__NSConcreteStackBlock);</span><br><span class="line">    rax = [rax autorelease];</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ___func_block_invoke(<span class="keyword">int</span> arg0, <span class="keyword">int</span> arg1) &#123;</span><br><span class="line">    rax = *(int32_t *)(arg0 + <span class="number">0x20</span>) * arg1;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中调用方法<code>objc_retainBlock</code><br>查看runtime源码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_retainBlock(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)_Block_copy(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处调用了<code>_Block_copy</code>，此处实现将block从栈上拷贝到堆上，保证了返回后的 block 仍然可以正确执行。<br>查看block源码发现内部还调用<code>_Block_object_assign</code>将对象赋值给block的结构体成员变量并持有该对象</p><h2 id="变量的copy"><a href="#变量的copy" class="headerlink" title="变量的copy"></a>变量的copy</h2><ul><li><p>block引用外部变量，默认是将变量进行copy，因此在block内部对变量的修改不会影响外部的使用<br><img src="/images/block的实现_外部变量.png" alt="block的实现_外部变量"></p></li><li><p><code>__block</code>引用外部变量，默认是将变量的地址进行copy<br><img src="/images/block的实现_外部变量2.png" alt="block的实现_外部变量2"></p></li></ul><h2 id="不看源码看结果（block截获局部变量）"><a href="#不看源码看结果（block截获局部变量）" class="headerlink" title="不看源码看结果（block截获局部变量）"></a>不看源码看结果（block截获局部变量）</h2><ul><li><p>普通版</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)block0</span><br><span class="line">&#123;</span><br><span class="line">    blk_t blk;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        blk = ^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">            [array addObject:obj];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"array count: = %zd"</span>,[array count]);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    blk([[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    blk([[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     array count: = 1</span></span><br><span class="line"><span class="comment">     array count: = 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>__weak</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)block1</span><br><span class="line">&#123;</span><br><span class="line">    blk_t blk;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="keyword">id</span> __<span class="keyword">weak</span> array2 = array;</span><br><span class="line">        blk = [^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">            [array2 addObject:obj];</span><br><span class="line">            <span class="comment">//如果打开这句话，两个数组都有值，array被blk持有，array2不为nil</span></span><br><span class="line"><span class="comment">//            NSLog(@"array count: = %zd",[array count]);</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"array2 count: = %zd"</span>,[array2 count]);</span><br><span class="line">        &#125;<span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    blk([[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    blk([[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     array2 count: = 0</span></span><br><span class="line"><span class="comment">     array2 count: = 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//array 在该变量作用域结束的同时被释放、废弃，nil被赋值在附有__weak修饰符的变量array2 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在上面方法的基础上添加 <code>__block</code>修饰array2 结果同理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)block2</span><br><span class="line">&#123;</span><br><span class="line">    blk_t blk;</span><br><span class="line">    &#123;</span><br><span class="line">        id array = [[NSMutableArray alloc] init];</span><br><span class="line">        __block id __weak array2 = array;</span><br><span class="line">        blk = [^(id obj)&#123;</span><br><span class="line">            [array2 addObject:obj];</span><br><span class="line">            NSLog(@&quot;array2 count: = %zd&quot;,[array2 count]);</span><br><span class="line">        &#125;copy];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    blk([[NSObject alloc] init]);</span><br><span class="line">    blk([[NSObject alloc] init]);</span><br><span class="line">    /*</span><br><span class="line">     array2 count: = 0</span><br><span class="line">     array2 count: = 0</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>__unsafe_unretained</code>修饰局部变量</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)block3</span><br><span class="line">&#123;</span><br><span class="line">    blk_t blk;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> array2 = array;</span><br><span class="line">        blk = [^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">            [array2 addObject:obj];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"array2 count: = %zd"</span>,[array2 count]);</span><br><span class="line">        &#125;<span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    blk([[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    blk(@<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     第一次调用blk()的时候，array2是数组，添加obj成功</span></span><br><span class="line"><span class="comment">     当第2次调用blk()的时候，array2是个野指针,不能添加数据，崩溃</span></span><br><span class="line"><span class="comment">     __unsafe_unretained修饰符的变量 与指针相同，和__strong或__weak修饰符不一样的处理，使用的时候需要注意不要通过野指针访问已被废弃的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用计数的变化</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">id</span> block_obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"****block_obj = [%@ , %p] "</span>,block_obj , &amp;block_obj);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"****obj = [%@ , %p]"</span> , obj , &amp;obj);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retain count:%zd\n"</span>,_objc_rootRetainCount(block_obj)); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retain count:%zd\n"</span>,_objc_rootRetainCount(obj)); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"***Block中****block_obj = [%@ , %p] "</span>,block_obj , &amp;block_obj);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"***Block中****obj = [%@ , %p]"</span> , obj , &amp;obj);</span><br><span class="line">&#125;;</span><br><span class="line">myBlock();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retain count:%zd\n"</span>,_objc_rootRetainCount(block_obj)); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retain count:%zd\n"</span>,_objc_rootRetainCount(obj)); <span class="comment">//3</span></span><br></pre></td></tr></table></figure></li></ul><p>可以看到两个对象的指针在block前后变化了，可以证实对象都被拷贝到了堆上<br><code>myBlock()</code>执行前后两个对象的<code>retainCount</code>的变化 :<br>obj经过从栈上拷贝到堆上之后 引用计数为1 -&gt;  3<br><code>__block</code>修饰的变量block_obj，引用计数没有发生变化 1 -&gt; 1</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>1.上面的普通版例子,block没有进行copy,理论上是处于栈上的，但array是有值的，说明block确实进行了copy赋值到堆上，为什么呢<br>解答:<br>在将block0通过Hopper Disassembler 工具将代码进行反编译，得到如下code<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> -[BlockViewController block0](<span class="keyword">void</span> * self, <span class="keyword">void</span> * _cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var_98 = objc_retainBlock(__NSConcreteStackBlock);</span><br><span class="line">    var_A0 = var_18;</span><br><span class="line">    __tsan_write8(var_18);</span><br><span class="line">    var_18 = var_98;</span><br><span class="line">    [var_90 release];</span><br><span class="line">    objc_storeStrong(var_88, <span class="number">0x0</span>);</span><br><span class="line">    objc_storeStrong(var_20, <span class="number">0x0</span>);</span><br><span class="line">    __tsan_read8(var_A0);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>var_98 = objc_retainBlock(__NSConcreteStackBlock);</code>，内部执行<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a heap based copy of a Block or simply add a reference to an existing one.</span></span><br><span class="line"><span class="comment">// This must be paired with Block_release to recover memory, even when running</span></span><br><span class="line"><span class="comment">// under Objective-C Garbage Collection.</span></span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *aBlock)</span><br></pre></td></tr></table></figure></p><p>将block从栈拷贝到了堆上，因此栈上的变量也被一起拷贝到了堆上,block进行clang重写之后得到block实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  id <span class="built_in">array</span>;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, id _array, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="built_in">array</span>(_array) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself, id obj) &#123;</span><br><span class="line">  id <span class="built_in">array</span> = __cself-&gt;<span class="built_in">array</span>; <span class="comment">// bound by copy</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="built_in">array</span>, (<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">blk_t</span> blk;</span><br><span class="line">        &#123;</span><br><span class="line">            id <span class="built_in">array</span> = ((NSMutableArray *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((NSMutableArray *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSMutableArray"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">            blk = ((<span class="keyword">void</span> (*)(id))&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, <span class="built_in">array</span>, <span class="number">570425344</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法里<code>__main_block_impl_0</code>传入的参数<code>array</code>是方法定义的<code>array(_array)</code>，传入array的指针而不是内存地址，所以没办法改变array本身<br>block 调用了 copy 方法，在 <code>_Block_object_assign</code> 中，将 array 赋值给 block 成员变量并持有。所以上面代码可以正常运行，打印出来的 array count 依次递增。</p><p>猜想一下array的retain值<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> blk_t blk;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"array retain count:%zd\n"</span>,_objc_rootRetainCount(array));<span class="comment">//1</span></span><br><span class="line">    blk = ^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">        [array addObject:obj];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"array retain count:%zd\n"</span>,_objc_rootRetainCount(array)); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.下面例子的blk结构体 存储了Person类的实例对象person, bound by copy ，但是一般来说bound by copy是代表的值引用，为什么在block内部对person的eat字段的改变可以改变到block外部的结果，感觉像是bound by ref<br>此处不知道怎么验证block内部的Person实例对象是和block外是一样的<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">person.eat = <span class="string">@"山珍海味"</span>;</span><br><span class="line">blk_t blk = [</span><br><span class="line">               ^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">                   person.eat = <span class="string">@"牛肉"</span>;</span><br><span class="line">               &#125;<span class="keyword">copy</span>];</span><br><span class="line">  </span><br><span class="line">blk(@<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person.eat);</span><br></pre></td></tr></table></figure></p><p>首先blk在执行<code>copy</code>将person对象从栈拷贝到了堆上，引起了对象的引用计数的变化</p><p>下面看下clang之后的c++源码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  Person *person; <span class="comment">//引用的外部变量</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, Person *_person, <span class="keyword">int</span> flags=<span class="number">0</span>) : person(_person) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself, id obj) &#123;</span><br><span class="line">  Person *person = __cself-&gt;person; <span class="comment">// bound by copy</span></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;person, (<span class="keyword">void</span>*)src-&gt;person, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;person, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        Person *person = ((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"Person"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(id, SEL, NSString *))(<span class="keyword">void</span> *)objc_msgSend)((id)person, sel_registerName(<span class="string">"setEat:"</span>), (NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main_0a2365_mi_0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">blk_t</span> blk = (<span class="keyword">blk_t</span>)((id (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((<span class="keyword">void</span> (*)(id))&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, person, <span class="number">570425344</span>)), sel_registerName(<span class="string">"copy"</span>));</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSNumber *(*)(Class, SEL, <span class="keyword">int</span>))(<span class="keyword">void</span> *)objc_msgSend)(objc_getClass(<span class="string">"NSNumber"</span>), sel_registerName(<span class="string">"numberWithInt:"</span>), <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main_0a2365_mi_2,((NSString *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)person, sel_registerName(<span class="string">"eat"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在main里面的blk闭包中的__main_block_impl_0结构体，初始化如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">blk_t</span> blk = (<span class="keyword">blk_t</span>)((id (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((<span class="keyword">void</span> (*)(id))&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, person, <span class="number">570425344</span>)), sel_registerName(<span class="string">"copy"</span>));</span><br><span class="line"></span><br><span class="line">impl.isa = &amp;_NSConcreteMallocBlock;</span><br><span class="line">impl.Flags = <span class="number">570425344</span>;</span><br><span class="line">impl.FuncPtr = __main_block_impl_0; </span><br><span class="line">Desc = &amp;__main_block_desc_0_DATA;</span><br><span class="line">*person = person;</span><br></pre></td></tr></table></figure></p><p>__main_block_impl_0结构体就是这样把自动变量捕获进来的</p><p><code>__main_block_copy_0</code> 和 <code>__main_block_dispose_0</code>函数实现将捕获的外部变量进行retain和dispose<br>BLOCK_FIELD_IS_OBJECT 标识符代表此处捕获的是OC对象<br>如果是BLOCK_FIELD_IS_BYREF  代表捕获的是__block自动变量</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在ARC环境下，block捕获了外部变量，都会对变量进行copy,<br><code>__block</code>修饰的变量,会被捕获到Block内部持有</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="noopener">https://blog.devtang.com/2013/07/28/a-look-inside-blocks/</a><br><a href="http://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="noopener">http://clang.llvm.org/docs/Block-ABI-Apple.html</a><br><a href="http://www.saitjr.com/ios/advance-block.html" target="_blank" rel="noopener">http://www.saitjr.com/ios/advance-block.html</a><br>《Pro Multithreading and Memory Management for iOS and OS X with ARC》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在OC当中我们经常使用block，block的结构体如下&lt;a href=&quot;http://clang.llvm.org/docs/Block-ABI-Apple.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘自clang&lt;/a&gt;:&lt;br&gt;&lt;fig
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactiveObjc-RACChannel</title>
    <link href="https://pattyxp.github.io/2018/04/02/ReactiveObjc-RACChannel/"/>
    <id>https://pattyxp.github.io/2018/04/02/ReactiveObjc-RACChannel/</id>
    <published>2018-04-02T06:10:56.000Z</published>
    <updated>2018-05-18T03:34:01.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RACChannel"><a href="#RACChannel" class="headerlink" title="RACChannel"></a>RACChannel</h2><p>在 RAC 的世界中，消息不仅仅会单向流动，也存在双向流动，对应到 OC，如viewModel的属性和View的属性相互影响,这就体现出 RACChannel的作用,从概念上讲，RACChannel可以看作是双向连接，由两个可控制的信号并行工作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACChannel</span>&lt;<span class="title">ValueType</span>&gt; : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACChannelTerminal&lt;ValueType&gt; *leadingTerminal;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACChannelTerminal&lt;ValueType&gt; *followingTerminal;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p> RACChannel 和 RACChannelTerminal 息息相关</p><h3 id="RACChannelTerminal"><a href="#RACChannelTerminal" class="headerlink" title="RACChannelTerminal"></a>RACChannelTerminal</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACChannelTerminal</span>&lt;<span class="title">ValueType</span>&gt; : <span class="title">RACSignal</span>&lt;<span class="title">ValueType</span>&gt; &lt;<span class="title">RACSubscriber</span>&gt;</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init __attribute__((unavailable(<span class="string">"Instantiate a RACChannel instead"</span>)));</span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">nullable</span> ValueType)value;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// The values for this terminal.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;ValueType&gt; *values;</span><br><span class="line"><span class="comment">/// A subscriber will will send values to the other terminal.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;RACSubscriber&gt; otherTerminal;</span><br></pre></td></tr></table></figure><p>RACChannelTerminal 既可以发送信号，也可以订阅信号</p><ul><li>初始化<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithValues:(RACSignal *)values otherTerminal:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)otherTerminal &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(values != <span class="literal">nil</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(otherTerminal != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_values = values;</span><br><span class="line">_otherTerminal = otherTerminal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>其中 values、otherTerminal 分别表示 RACChannelTerminal 的两个端点。在订阅者调用 -subscribeNext: 等方法发起订阅时，实际上订阅的是self.values 信号；如果向当前端点发送消息，会使用 self.otherTerminal 来发送消息，不是使用 self.values 的订阅者来发送消息</p><ul><li>RACSignal<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span>.values subscribe:subscriber]; <span class="comment">//实际被订阅的是values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>执行<code>RACReplaySubject</code>对象的<code>subscribe</code>方法,向订阅者发送values</p><ul><li>遵循<code>RACSubscriber</code> 协议<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">[<span class="keyword">self</span>.otherTerminal sendNext:value]; <span class="comment">//实际调用self.otherTerminal 发送消息</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h3 id="RACChannel-初始化"><a href="#RACChannel-初始化" class="headerlink" title="RACChannel 初始化"></a>RACChannel 初始化</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// We don't want any starting value from the leadingSubject, but we do want</span></span><br><span class="line"><span class="comment">// error and completion to be replayed.</span></span><br><span class="line">RACReplaySubject *leadingSubject = [[RACReplaySubject replaySubjectWithCapacity:<span class="number">0</span>] setNameWithFormat:<span class="string">@"leadingSubject"</span>];</span><br><span class="line">RACReplaySubject *followingSubject = [[RACReplaySubject replaySubjectWithCapacity:<span class="number">1</span>] setNameWithFormat:<span class="string">@"followingSubject"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate errors and completion to everything.</span></span><br><span class="line">[[leadingSubject ignoreValues] subscribe:followingSubject];</span><br><span class="line">[[followingSubject ignoreValues] subscribe:leadingSubject];</span><br><span class="line"></span><br><span class="line">_leadingTerminal = [[[RACChannelTerminal alloc] initWithValues:leadingSubject otherTerminal:followingSubject] setNameWithFormat:<span class="string">@"leadingTerminal"</span>];</span><br><span class="line">_followingTerminal = [[[RACChannelTerminal alloc] initWithValues:followingSubject otherTerminal:leadingSubject] setNameWithFormat:<span class="string">@"followingTerminal"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>RACReplaySubject 将之前发送的值都进行保存，订阅的时候会向当前的订阅者遍历调用之前接收到的values<br>根据传入的参数capacity，<br><code>leadingSubject</code>的capacity为0, 不需要订阅的时候就执行消息发送<br><code>followingSubject</code>的capacity为1,需要在订阅的时候执行最新一次接收的值，供外部订阅需要初始值</p></li><li><p>leadingSubject 和 followingSubject 相互订阅<br>默认都接收Completed和Error信号，防止任一信号结束另一个还在执行的问题</p></li></ul><h3 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h3><p>RACChannel 采用了双向绑定的思想，在使用过程中，一般通过它的子类 RACKVOChannel 实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACChannelTo(<span class="keyword">self</span>,nameA) = RACChannelTo(<span class="keyword">self</span>,nameB);</span><br><span class="line"><span class="keyword">self</span>.nameA = <span class="string">@"John"</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"nameA:%@-nameB:%@"</span>,<span class="keyword">self</span>.nameA,<span class="keyword">self</span>.nameB);</span><br></pre></td></tr></table></figure><ul><li><p>源码<br><code>RACChannelTo</code>是宏，<code>RACChannelTo(self,nameA)</code>展开</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RACKVOChannel alloc] initWithTarget:<span class="keyword">self</span> keyPath:<span class="string">@"nameA"</span> nilValue:<span class="literal">nil</span>][<span class="string">@"followingTerminal"</span>]</span><br></pre></td></tr></table></figure></li><li><p>作用<br>为nameA和nameB 分别创建了channelA和channelB<br>调用channelA[@”followingTerminal”] = channelB[@”followingTerminal”]</p></li></ul><p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameA:John-nameB:John</span><br></pre></td></tr></table></figure></p><ul><li>实现原理<br>覆写下面两个方法，实现双向绑定<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RACKVOChannel</span> (<span class="title">RACChannelTo</span>)</span></span><br><span class="line"></span><br><span class="line">- (RACChannelTerminal *)objectForKeyedSubscript:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(key != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">RACChannelTerminal *terminal = [<span class="keyword">self</span> valueForKey:key];</span><br><span class="line"><span class="built_in">NSCAssert</span>([terminal isKindOfClass:RACChannelTerminal.class], <span class="string">@"Key \"%@\" does not identify a channel terminal"</span>, key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> terminal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(RACChannelTerminal *)otherTerminal forKeyedSubscript:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(otherTerminal != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">RACChannelTerminal *selfTerminal = [<span class="keyword">self</span> objectForKeyedSubscript:key];</span><br><span class="line">[otherTerminal subscribe:selfTerminal];</span><br><span class="line">[[selfTerminal skip:<span class="number">1</span>] subscribe:otherTerminal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>内部实际是对 <code>followingTerminal</code>相互订阅,在反向绑定的时候就可以skip:1来节约性能</p><h2 id="RACChannel-扩展"><a href="#RACChannel-扩展" class="headerlink" title="RACChannel 扩展"></a>RACChannel 扩展</h2><p>这些函数都会返回一个对应的RACChannelTerminal,可以定制使用结合</p><ul><li>[NSUserDefaults rac_channelTerminalForKey:]</li><li>[UIDatePicker rac_newDateChannelWithNilValue:]</li><li>[UISegmentedControl rac_newSelectedSegmentIndexChannelWithNilValue:]</li><li>[UISlider rac_newValueChannelWithNilValue:]</li><li>[UITextField rac_newTextChannel:]</li></ul><h2 id="RAC相关的宏"><a href="#RAC相关的宏" class="headerlink" title="RAC相关的宏"></a>RAC相关的宏</h2><ul><li><code>RAC(TARGET, [KEYPATH, [NIL_VALUE]])</code></li></ul><p>EXAMPLES:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RAC(<span class="keyword">self</span>, objectProperty) = objectSignal;</span><br><span class="line">RAC(<span class="keyword">self</span>, stringProperty, <span class="string">@"foobar"</span>) = stringSignal;</span><br><span class="line">RAC(<span class="keyword">self</span>, integerProperty, @<span class="number">42</span>) = integerSignal;</span><br></pre></td></tr></table></figure></p><p>RAC()总是出现在等号左边，等号右边是一个RACSignal，表示的意义是将一个对象的一个属性和一个signal绑定，signal每产生一个value（id类型），都会自动执行：<code>[TARGET setValue:value ?: NIL_VALUE forKeyPath:KEYPATH];</code></p><ul><li><code>RACObserve(TARGET, KEYPATH)</code> :观察TARGET的KEYPATH属性，相当于KVO，产生一个RACSignal<br>EXAMPLES:<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *selfSignal = RACObserve(<span class="keyword">self</span>, arrayController.items);</span><br><span class="line"></span><br><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">   RACSignal *signal3 = [anotherSignal flattenMap:^(<span class="built_in">NSArrayController</span> *arrayController) &#123;</span><br><span class="line">       <span class="comment">// Avoids a retain cycle because of RACObserve implicitly referencing self.</span></span><br><span class="line">       @strongify(<span class="keyword">self</span>);</span><br><span class="line">       <span class="keyword">return</span> RACObserve(arrayController, items);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure></li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="noopener">http://blog.sunnyxx.com/2014/03/06/rac_1_macros/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RACChannel&quot;&gt;&lt;a href=&quot;#RACChannel&quot; class=&quot;headerlink&quot; title=&quot;RACChannel&quot;&gt;&lt;/a&gt;RACChannel&lt;/h2&gt;&lt;p&gt;在 RAC 的世界中，消息不仅仅会单向流动，也存在双向流动，对应到 OC，如
      
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="https://pattyxp.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveObjc-RACCommand</title>
    <link href="https://pattyxp.github.io/2018/03/26/ReactiveObjc-RACCommand/"/>
    <id>https://pattyxp.github.io/2018/03/26/ReactiveObjc-RACCommand/</id>
    <published>2018-03-26T02:57:28.000Z</published>
    <updated>2018-05-18T03:34:08.405Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文源码为 ReactiveObjc 3.1.0 版本</p><p>在ReactiveObjc 世界中，不仅仅存在RACSignal这样的信号，还存在一些绑定关系的操作集合，比如按钮的点击事件，按钮点击的时候，事物操作事先就定义好了，RACCommand 可以应用于此</p><h2 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACCommand</span>&lt;<span class="title">__contravariant</span> <span class="title">InputType</span>, <span class="title">__covariant</span> <span class="title">ValueType</span>&gt; : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;RACSignal&lt;ValueType&gt; *&gt; *executionSignals;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;<span class="built_in">NSNumber</span> *&gt; *executing;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;<span class="built_in">NSNumber</span> *&gt; *enabled;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;<span class="built_in">NSError</span> *&gt; *errors;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSignalBlock:(RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input))signalBlock;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEnabled:(<span class="keyword">nullable</span> RACSignal&lt;<span class="built_in">NSNumber</span> *&gt; *)enabledSignal signalBlock:(RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input))signalBlock;</span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)execute:(<span class="keyword">nullable</span> InputType)input;</span><br></pre></td></tr></table></figure><p>RACCommand 继承自NSObject，是一个对象，但是可以用于创建和订阅信号</p><p>对外声明包含四个属性</p><ul><li><p>executionSignals<br>属于高阶信号，需要进行降级操作,通常使用 flatten，switchToLatest，concat<br>如果在允许Concurrent并发的RACCommand中一般使用flatten。<br>在不允许Concurrent并发的RACCommand中一般使用switchToLatest</p></li><li><p>executing:当前RACCommand是否在执行</p></li><li><p>enabled:RACCommand是否可用</p></li><li><p>errors:RACCommand执行过程中产生的错误信号</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACCommand</span> () </span>&#123;</span><br><span class="line"><span class="comment">// Atomic backing variable for `allowsConcurrentExecution`.</span></span><br><span class="line"><span class="keyword">volatile</span> uint32_t _allowsConcurrentExecution;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A subject that sends added execution signals.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSubject *addedExecutionSignalsSubject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A subject that sends the new value of `allowsConcurrentExecution` whenever it changes.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSubject *allowsConcurrentExecutionSubject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `enabled`, but without a hop to the main thread.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Values from this signal may arrive on any thread.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal *immediateEnabled;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The signal block that the receiver was initialized with.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSignal * (^signalBlock)(<span class="keyword">id</span> input);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><ul><li>allowsConcurrentExecution :是否允许并发执行<br>定义类型是volatile</li></ul><p>在使用时 重写 get 和 set方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark Properties</span><br><span class="line"></span><br><span class="line">- (BOOL)allowsConcurrentExecution &#123;</span><br><span class="line">return _allowsConcurrentExecution != 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setAllowsConcurrentExecution:(BOOL)allowed &#123;</span><br><span class="line">if (allowed) &#123;</span><br><span class="line">OSAtomicOr32Barrier(1, &amp;_allowsConcurrentExecution); //原子运算，保证只执行一次</span><br><span class="line">&#125; else &#123;</span><br><span class="line">OSAtomicAnd32Barrier(0, &amp;_allowsConcurrentExecution);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[self.allowsConcurrentExecutionSubject sendNext:@(_allowsConcurrentExecution)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>RACCommand 对外暴露两个初始化方法和一个execute方法</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithSignalBlock:(RACSignal * (^)(id input))signalBlock &#123;</span><br><span class="line">    return [self initWithEnabled:nil signalBlock:signalBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用 initWithEnabled:signalBlock 方法，对 executionSignals，executing，enabled，errors的初始化<br>初始化方法比较复杂，内部创建了7个高阶信号，如果先简略信号的创建，实现如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithEnabled:(RACSignal *)enabledSignal signalBlock:(RACSignal&lt;<span class="keyword">id</span>&gt; * (^)(<span class="keyword">id</span> input))signalBlock &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_addedExecutionSignalsSubject = [RACSubject new];</span><br><span class="line">_signalBlock = [signalBlock <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">_executionSignals = ...;</span><br><span class="line">_errors = ...;</span><br><span class="line">RACSignal *immediateExecuting = ...;</span><br><span class="line">_executing = ...;</span><br><span class="line">RACSignal *moreExecutionsAllowed = ...;</span><br><span class="line">_immediateEnabled =...;</span><br><span class="line">_enabled = ...;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>immediateExecuting 表示当前是否有任务在执行<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *immediateExecuting = [[[[<span class="keyword">self</span>.addedExecutionSignalsSubject</span><br><span class="line">flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line"><span class="keyword">return</span> [[[signal</span><br><span class="line">catchTo:[RACSignal empty]]</span><br><span class="line">then:^&#123;</span><br><span class="line"><span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:@<span class="number">-1</span>];</span><br><span class="line">&#125;]</span><br><span class="line">startWith:@<span class="number">1</span>];</span><br><span class="line">&#125;]</span><br><span class="line">scanWithStart:@<span class="number">0</span> reduce:^(<span class="built_in">NSNumber</span> *running, <span class="built_in">NSNumber</span> *next) &#123;</span><br><span class="line"><span class="keyword">return</span> @(running.integerValue + next.integerValue);</span><br><span class="line">&#125;]</span><br><span class="line">map:^(<span class="built_in">NSNumber</span> *count) &#123;</span><br><span class="line"><span class="keyword">return</span> @(count.integerValue &gt; <span class="number">0</span>);</span><br><span class="line">&#125;]</span><br><span class="line">startWith:@NO];</span><br></pre></td></tr></table></figure></li></ul><p>1.flattenMap 将每一个信号的开始和结束的时间点转换成 1 和 -1 两个信号<br>    catchTo: 将捕获到的错误信号都返回 RACEmptySignal空信号,当信号发送完毕，执行then方法的block生成RACReturnSignal信号,发送-1.<br>    startWith 先发送1，然后执行原信号<br>2.scanWithStart 初始化值为0，累加原信号发出的所有的值<br>3.map 将大于0的信号转为 YES<br>4.startWith 在信号序列最前面加入 @NO，表示在最开始时，没有任何动作在执行。</p><p><a href="https://pattyxp.github.io/2018/03/24/ReactiveObjc-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C/">具体方法的实现分析查看</a></p><p>整个流程如下<a href="https://github.com/Draveness/analyze/blob/43d828b6f516a57e12eeff69913ff49cc94a0f36/contents/ReactiveObjC/RACCommand.md" target="_blank" rel="noopener">图片来源</a><br><img src="/images/ImmediateExecutingSignal.png" alt="ImmediateExecutingSignal"></p><ul><li>moreExecutionsAllowed 判断是否允许并发执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *moreExecutionsAllowed = [RACSignal</span><br><span class="line">if:[self.allowsConcurrentExecutionSubject startWith:@NO]</span><br><span class="line">then:[RACSignal return:@YES]</span><br><span class="line">else:[immediateExecuting not]];</span><br></pre></td></tr></table></figure></li></ul><p>如果允许并发执行，那么执行then操作，否则执行else操作<br>else操作是对 immediateExecuting 取反</p><ul><li>executionSignals<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_executionSignals = [[[self.addedExecutionSignalsSubject</span><br><span class="line">  map:^(RACSignal *signal) &#123;</span><br><span class="line">    return [signal catchTo:[RACSignal empty]];</span><br><span class="line">  &#125;]</span><br><span class="line">  deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">  setNameWithFormat:@&quot;%@ -executionSignals&quot;, self];</span><br></pre></td></tr></table></figure></li></ul><p>map 函数操作是对信号进行变换,当接收到错误信号会返回空信号<br>executionSignals 将返回的信号都派发到在主线程中。</p><p>catchTo方法<a href="https://pattyxp.github.io/2018/03/24/ReactiveObjc-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C/">此文有介绍</a></p><ul><li>executing信号 :判断是否正在执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_executing = [[[[[immediateExecuting</span><br><span class="line">deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">// This is useful before the first value arrives on the main thread.</span><br><span class="line">startWith:@NO]</span><br><span class="line">distinctUntilChanged]</span><br><span class="line">replayLast]</span><br><span class="line">setNameWithFormat:@&quot;%@ -executing&quot;, self];</span><br></pre></td></tr></table></figure></li></ul><p>信号在主线程执行，<br>内部调用distinctUntilChanged,初始值为NO，当值变化的时候，通过 replayLast方法 生成 <code>[RACReplaySubject replaySubjectWithCapacity:1]</code>保存最新值的信号，不关心过去的值<br>返回热信号 RACMulticastConnection</p><ul><li>enabled : 判断RACCommand对象是否能够执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_immediateEnabled = [[[[RACSignal</span><br><span class="line">combineLatest:@[ enabledSignal, moreExecutionsAllowed ]]</span><br><span class="line">and]</span><br><span class="line">takeUntil:self.rac_willDeallocSignal]</span><br><span class="line">replayLast];</span><br><span class="line"></span><br><span class="line">_enabled = [[[[[self.immediateEnabled</span><br><span class="line">take:1]</span><br><span class="line">concat:[[self.immediateEnabled skip:1] deliverOn:RACScheduler.mainThreadScheduler]]</span><br><span class="line">distinctUntilChanged]</span><br><span class="line">replayLast]</span><br><span class="line">setNameWithFormat:@&quot;%@ -enabled&quot;, self];</span><br></pre></td></tr></table></figure></li></ul><p>依赖于私有信号immediateEnabled<br>这里涉及到了combineLatest:的变换操作，<a href="https://pattyxp.github.io/2018/03/24/ReactiveObjc-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C/">这个操作在这里有介绍</a>。combineLatest:的作用就是把后面数组里面传入的每个信号，不管是谁发送出来一个信号，都会把数组里面所有信号的最新的值组合到一个RACTuple里面。immediateEnabled会把每个RACTuple里面的元素都进行逻辑and运算，这样immediateEnabled信号里面装的也都是BOOL值了。<br>当前 RACCommand 执行 dealloc 之后就不会执行<code>self.rac_willDeallocSignal</code>信号</p><p>_enabled 与 enabledSignal、moreExecutionsAllowed、rac_willDeallocSignal 都有关系</p><p>immediateEnabled 在每次原信号发送消息时都会重新计算<br>_enabled 有点差别,调用了<code>-distinctUntilChanged</code>方法，所以如果连续几次值相同就不会再次发送任何消息。<br>调用skip:方法，第一个值以后的每个值都发送在主线程上<br>-take:1和 -concat: 第一个值在一订阅的时候就发送出去了，同订阅者所在线程一致。</p><ul><li>errors 信号初始化<br>RACCommand 能将error信号进行收集统一处理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACMulticastConnection *errorsConnection = [[[self.addedExecutionSignalsSubject</span><br><span class="line">  flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line">    return [[signal</span><br><span class="line">      ignoreValues]</span><br><span class="line">      catch:^(NSError *error) &#123;</span><br><span class="line">        return [RACSignal return:error];</span><br><span class="line">      &#125;];</span><br><span class="line">  &#125;]</span><br><span class="line">  deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">  publish];</span><br><span class="line"></span><br><span class="line">_errors = [errorsConnection.signal setNameWithFormat:@&quot;%@ -errors&quot;, self];</span><br><span class="line">[errorsConnection connect];</span><br></pre></td></tr></table></figure></li></ul><p>内部调用 ignoreValues/catch 方法 进行信号转换<br>将addedExecutionSignalsSubject 内原信号的错误信息都返回 RACReturnSignal对象</p><ul><li>execute 执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)execute:(id)input &#123;</span><br><span class="line"></span><br><span class="line">//判断能够执行任务</span><br><span class="line">BOOL enabled = [[self.immediateEnabled first] boolValue];</span><br><span class="line">if (!enabled) &#123;</span><br><span class="line"></span><br><span class="line">NSError *error = [NSError errorWithDomain:RACCommandErrorDomain code:RACCommandErrorNotEnabled userInfo:@&#123;</span><br><span class="line">NSLocalizedDescriptionKey: NSLocalizedString(@&quot;The command is disabled and cannot be executed&quot;, nil),</span><br><span class="line">RACUnderlyingCommandErrorKey: self</span><br><span class="line">&#125;];</span><br><span class="line">//如果不能执行，直接返回 Error信号</span><br><span class="line">return [RACSignal error:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据初始化时候的signalBlock产生信号</span><br><span class="line">RACSignal *signal = self.signalBlock(input);</span><br><span class="line">NSCAssert(signal != nil, @&quot;nil signal returned from signal block for value: %@&quot;, input);</span><br><span class="line"></span><br><span class="line">//将冷信号转为热信号</span><br><span class="line">RACMulticastConnection *connection = [[signal</span><br><span class="line">subscribeOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">multicast:[RACReplaySubject subject]];</span><br><span class="line"></span><br><span class="line">//只有在此处对 addedExecutionSignalsSubject对象进行操作 ，生产信息</span><br><span class="line">[self.addedExecutionSignalsSubject sendNext:connection.signal];</span><br><span class="line"></span><br><span class="line">// 将 RACSignal 和 RACReplaySubject 进行连接</span><br><span class="line">[connection connect];</span><br><span class="line">return [connection.signal setNameWithFormat:@&quot;%@ -execute: %@&quot;, self, RACDescription(input)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 signalBlock 返回一个 RACSignal 之后，会将当前信号包装成一个 RACMulticastConnection，然后调用 -sendNext: 方法发送到 addedExecutionSignalsSubject 上，执行 -connect 方法订阅原有的信号，最后返回。</p><ul><li>事例</li></ul><p>通常 RACCommand 特别适合网络请求或者 UI相关操作上，可以结合MVVM模式进行使用，<a href="https://github.com/Draveness/analyze/blob/43d828b6f516a57e12eeff69913ff49cc94a0f36/contents/ReactiveObjC/RACCommand.md" target="_blank" rel="noopener">来源</a><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(<span class="built_in">NSNumber</span> * _Nullable input) &#123;</span><br><span class="line"><span class="comment">// block1</span></span><br><span class="line"><span class="keyword">return</span> [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line"><span class="comment">// block2</span></span><br><span class="line"><span class="built_in">NSInteger</span> integer = [input integerValue];</span><br><span class="line">[subscriber sendNext:@(integerValue)];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;];</span><br><span class="line">[[command.executionSignals switchToLatest] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line"><span class="comment">//block3</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"value:%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[command execute:@<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p><p>订阅 executionSignals和错误信号 来获取请求结果<br>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value:1</span><br></pre></td></tr></table></figure></p><p>分析下流程</p><ol><li>先创建 RACCommand 对象，将入参进行copy<code>[signalBlock copy]</code><br>  初始化内部的信号</li><li>执行<code>[[command.executionSignals switchToLatest]</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)switchToLatest &#123;</span><br><span class="line">// block4</span><br><span class="line">return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">// block5</span><br><span class="line">RACMulticastConnection *connection = [self publish]; //产生热信号</span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [[connection.signal</span><br><span class="line">flattenMap:^(RACSignal *x) &#123;  //对原信号进行变换</span><br><span class="line"></span><br><span class="line">NSCAssert(x == nil || [x isKindOfClass:RACSignal.class], @&quot;-switchToLatest requires that the source signal (%@) send signals. Instead we got: %@&quot;, self, x);</span><br><span class="line"></span><br><span class="line">return [x takeUntil:[connection.signal concat:[RACSignal never]]];</span><br><span class="line">&#125;]</span><br><span class="line">subscribe:subscriber];</span><br><span class="line"></span><br><span class="line">RACDisposable *connectionDisposable = [connection connect];</span><br><span class="line">return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line">[connectionDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -switchToLatest&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>此处执行 block4,产生新的信号，将block进行copy</li><li><p>对<code>[[command.executionSignals switchToLatest] subscribeNext]</code><br>  执行subscribeNext操作，此处将 switchToLatest产生的信号执行订阅操作，调用信号的 didSubscriber闭包, 此处执行 block5<br> 通过<code>flattenMap</code>对热信号的signal进行变换操作产生新的信号signal1</p><p> <code>[x takeUntil:[connection.signal concat:[RACSignal never]]];</code><br> 先执行<code>concat</code>方法产生新的信号signal2，<code>takeUntil</code>会一直订阅signal2，signal2如果没有收到新值会一直执行<code>sendNext</code>直到signal2有新值会取消订阅信号x，向订阅者发送<code>sendCompleted</code></p><p> 执行<code>[connection connect];</code><br>5.执行<code>execute</code>方法，<code>RACSignal *signal = self.signalBlock(input);</code>调用初始化command时候保存的闭包,此处执行 block1<br> 执行<code>[self.addedExecutionSignalsSubject sendNext:connection.signal];</code><br> 接着执行<code>[connection connect];</code></p></li><li>执行block2</li><li>执行block3</li></ol><ul><li>注意<br>1.如果此处在末尾添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[command execute:@2];</span><br><span class="line">[command execute:@3];</span><br></pre></td></tr></table></figure></li></ul><p>那么只能收到第一个打印结果<code>value:1</code><br>因为RACCommand 默认是非并发执行的，需要等待命令执行结束才能执行下一次操作，所以在<code>execute</code>方法内部，每次都会判断是否可以执行任务，第二次执行的时候进入if条件语句，返回 Error信号，不打印内容</p><p>2.如果此处在末尾添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[RACScheduler.mainThreadScheduler afterDelay:0.1</span><br><span class="line">                                    schedule:^&#123;</span><br><span class="line">                                        [command execute:@2];</span><br><span class="line">                                    &#125;];</span><br><span class="line">[RACScheduler.mainThreadScheduler afterDelay:0.2</span><br><span class="line">                                    schedule:^&#123;</span><br><span class="line">                                        [command execute:@3];</span><br><span class="line">                                    &#125;];</span><br></pre></td></tr></table></figure></p><p>可以收到打印结果<br>每次执行execute方法， executionSignals 中发送了新的信号时，switchToLatest 方法返回的信号都会订阅这个最新的信号，这里也就保证了每次都会打印出最新的信号中的值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RACCommand 将外部的变量 InputType 转换成了使用 RACSignal 包裹的 ValueType 对象。<br>从 -execute: 方法中获得输入InputType，最后以向信号发送消息的方式，向订阅者推送结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文源码为 ReactiveObjc 3.1.0 版本&lt;/p&gt;
&lt;p&gt;在ReactiveObjc 世界中
      
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="https://pattyxp.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveObjc 常用的变换操作</title>
    <link href="https://pattyxp.github.io/2018/03/24/ReactiveObjc-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C/"/>
    <id>https://pattyxp.github.io/2018/03/24/ReactiveObjc-常用的变换操作/</id>
    <published>2018-03-24T08:47:45.000Z</published>
    <updated>2018-05-18T03:34:29.329Z</updated>
    
    <content type="html"><![CDATA[<p>本文源码为 ReactiveObjc 3.1.0 版本</p><p>除了入门篇介绍的一些常用方法，本篇来介绍下过滤和组合相关的方法底层实现</p><ul><li>filter</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)filter:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^ <span class="keyword">id</span> (<span class="keyword">id</span> value) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (block(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -filter:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用flattenMap方法，在上篇已经介绍过了，此处略过。<br>如果满足筛选条件的即返回原信号的值，否则原信号的值被“吞”掉，返回空的信号 RACEmptySignal</p><ul><li>ignoreValues<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)ignoreValues &#123;</span><br><span class="line">    return [[self filter:^(id _) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -ignoreValues&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>ignoreValues 方法是对 filter 方法的封装，原信号的值都会被变换成empty空信号</p><ul><li>ignore:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)ignore:(id)value &#123;</span><br><span class="line">    return [[self filter:^ BOOL (id innerValue) &#123;</span><br><span class="line">        return innerValue != value &amp;&amp; ![innerValue isEqual:value];</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -ignore: %@&quot;, self.name, [value rac_description]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>对入参的value进行判断，当原信号和value不同的时候 返回原信号</p><ul><li>distinctUntilChanged<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)distinctUntilChanged &#123;</span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">        __block <span class="keyword">id</span> lastValue = <span class="literal">nil</span>;</span><br><span class="line">        __block <span class="built_in">BOOL</span> initial = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ^(<span class="keyword">id</span> x, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!initial &amp;&amp; (lastValue == x || [x isEqual:lastValue])) <span class="keyword">return</span> [<span class="keyword">class</span> empty];</span><br><span class="line"></span><br><span class="line">            initial = <span class="literal">NO</span>;</span><br><span class="line">            lastValue = x;</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:x];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -distinctUntilChanged"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>每次变换中都记录一下原信号上一次发送过来的值，并与这一次进行比较，如果是相同的值，返回empty信号。只有和原信号上一次发送的值不同，变换后的新信号才把这个值发送出来。</p><ul><li>take<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)take:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">__block <span class="built_in">NSUInteger</span> taken = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ^ <span class="keyword">id</span> (<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">if</span> (taken &lt; count) &#123;</span><br><span class="line">++taken;</span><br><span class="line"><span class="keyword">if</span> (taken == count) *stop = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -take: %lu"</span>, <span class="keyword">self</span>.name, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>take:实现也非常简单，借助bind函数来实现的。<br>入参的count是原信号取值的个数,在bind的闭包中,taken计数从0开始取原信号的值,当taken取到count个数的时候，就停止取值。</p><ul><li>takeLast<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)takeLast:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *valuesTaken = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:count];</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">[valuesTaken addObject:x ? : RACTupleNil.tupleNil];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (valuesTaken.count &gt; count) &#123;</span><br><span class="line">[valuesTaken removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> value <span class="keyword">in</span> valuesTaken) &#123;</span><br><span class="line">[subscriber sendNext:value == RACTupleNil.tupleNil ? <span class="literal">nil</span> : value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -takeLast: %lu"</span>, <span class="keyword">self</span>.name, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>和take相反，先将接受到的值都存储在可变数组valuesTaken上，当数组的数量超过入参count的值，就将之前的数据进行移除<br>订阅完成之后，通过for循环一次次的发送值<br>注:<br>1.如果值是空的RACTupleNil.tupleNil，就发送nil<br>2.如果原信号一直没有completed，那么takeLast:就一直没法发出任何信号来。</p><ul><li>takeUntilBlock<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)takeUntilBlock:(BOOL (^)(id x))predicate &#123;</span><br><span class="line">NSCParameterAssert(predicate != nil);</span><br><span class="line"></span><br><span class="line">Class class = self.class;</span><br><span class="line"></span><br><span class="line">return [[self bind:^&#123;</span><br><span class="line">return ^ id (id value, BOOL *stop) &#123;</span><br><span class="line">if (predicate(value)) return nil;</span><br><span class="line"></span><br><span class="line">return [class return:value];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -takeUntilBlock:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>内部也是借助bind方法实现，根据传入的predicate闭包作为筛选条件，如果predicate( )闭包满足条件，那么新信号置为nil,停止发送新信号.</p><ul><li>takeWhileBlock<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)takeWhileBlock:(BOOL (^)(id x))predicate &#123;</span><br><span class="line">NSCParameterAssert(predicate != nil);</span><br><span class="line"></span><br><span class="line">return [[self takeUntilBlock:^ BOOL (id x) &#123;</span><br><span class="line">return !predicate(x);</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -takeWhileBlock:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>内部调用takeUntilBlock，只是判断条件和之相反<br>如果满足条件，返回 非空的值，<br>如果不满足条件 返回 nil，停止发送新信号</p><ul><li>takeUntil<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)takeUntil:(RACSignal *)signalTrigger &#123;</span><br><span class="line">return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">void (^triggerCompletion)(void) = ^&#123;</span><br><span class="line">[disposable dispose];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RACDisposable *triggerDisposable = [signalTrigger subscribeNext:^(id _) &#123;</span><br><span class="line">triggerCompletion();</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">triggerCompletion();</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:triggerDisposable];</span><br><span class="line"></span><br><span class="line">if (!disposable.disposed) &#123;</span><br><span class="line">RACDisposable *selfDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[disposable dispose];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:selfDisposable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return disposable;</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -takeUntil: %@&quot;, self.name, signalTrigger];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>产生一个新信号，在新信号中 订阅原信号，只要原信号没有销毁就会一直执行 <code>sendNext</code> ,<br>当入参signalTrigger调用sendNext,那么就会触发triggerCompletion<br>取消原信号，向新产生的信号发送sendCompleted</p><ul><li>skip<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)skip:(NSUInteger)skipCount &#123;</span><br><span class="line">Class class = self.class;</span><br><span class="line"></span><br><span class="line">return [[self bind:^&#123;</span><br><span class="line">__block NSUInteger skipped = 0;</span><br><span class="line"></span><br><span class="line">return ^(id value, BOOL *stop) &#123;</span><br><span class="line">if (skipped &gt;= skipCount) return [class return:value];</span><br><span class="line"></span><br><span class="line">skipped++;</span><br><span class="line">return class.empty;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -skip: %lu&quot;, self.name, (unsigned long)skipCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>借助bind方法，判断执行的次数，如果满足skipCount次数，则发送原信号，否则发送空信号</p><p>skip方法和take方法是补全关系，take是取前几次，skip是跳过前面几次</p><ul><li>skipUntilBlock</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)skipUntilBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(predicate != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">__block <span class="built_in">BOOL</span> skipping = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ^ <span class="keyword">id</span> (<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">if</span> (skipping) &#123;</span><br><span class="line"><span class="keyword">if</span> (predicate(value)) &#123;</span><br><span class="line">skipping = <span class="literal">NO</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -skipUntilBlock:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>skipUntilBlock 和 takeUntilBlock 实现类似<br>以入参 predicate()闭包判断，如果满足条件，skipping = NO,原信号发送的每个值都原封不动的发送出去。<br>不满足条件的时候，即会一直skip原信号的值</p><ul><li>skipWhileBlock<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)skipWhileBlock:(BOOL (^)(id x))predicate &#123;</span><br><span class="line">NSCParameterAssert(predicate != nil);</span><br><span class="line"></span><br><span class="line">return [[self skipUntilBlock:^ BOOL (id x) &#123;</span><br><span class="line">return !predicate(x);</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -skipWhileBlock:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>skipWhileBlock 方法底层调用skipUntilBlock ,只是判断条件是 不满足predicate()闭包</p><ul><li>catch<br>高阶操作，是因为这里原信号发生错误之后，错误会升阶成一个信号。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)catch:(RACSignal * (^)(NSError *error))catchBlock &#123;</span><br><span class="line">NSCParameterAssert(catchBlock != NULL);</span><br><span class="line"></span><br><span class="line">return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACSerialDisposable *catchDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">RACSignal *signal = catchBlock(error);</span><br><span class="line">NSCAssert(signal != nil, @&quot;Expected non-nil signal from catch block on %@&quot;, self);</span><br><span class="line">catchDisposable.disposable = [signal subscribe:subscriber];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[catchDisposable dispose];</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -catch:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当对原信号进行订阅的时候，如果出现错误，会去执行catchBlock()闭包，入参为刚刚产生的error。catchBlock( )闭包产生的是一个新的RACSignal，并再次用之前的订阅者订阅该信号。</p><ul><li>catchTo<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)catchTo:(RACSignal *)signal &#123;</span><br><span class="line">    return [[self catch:^(NSError *error) &#123;</span><br><span class="line">        return signal;</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -catchTo: %@&quot;, self.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>底层调用catch方法,实际是对catch方法的封装,如果订阅发生错误，都返回入参signal</p><ul><li>then<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)then:(RACSignal * (^)(void))block &#123;</span><br><span class="line">    NSCParameterAssert(block != nil);</span><br><span class="line"></span><br><span class="line">    return [[[self</span><br><span class="line">        ignoreValues]</span><br><span class="line">        concat:[RACSignal defer:block]]</span><br><span class="line">        setNameWithFormat:@&quot;[%@] -then:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>将操作进行延迟到 原信号发送完毕之后，再执行block闭包</p><ul><li>defer<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)defer:(RACSignal * (^)(void))block &#123;</span><br><span class="line">    NSCParameterAssert(block != NULL);</span><br><span class="line"></span><br><span class="line">    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        return [block() subscribe:subscriber];</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;+defer:&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当defer返回的新信号被订阅的时候，才会执行入参block( )闭包，block产生信号，订阅者订阅block产生的信号</p><ul><li>startWith<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)startWith:(id)value &#123;</span><br><span class="line">return [[[self.class return:value]</span><br><span class="line">concat:self]</span><br><span class="line">setNameWithFormat:@&quot;[%@] -startWith: %@&quot;, self.name, RACDescription(value)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>先通过return方法产生 RACReturnSignal,发送产生value，然后这个信号发送完毕之后接上原信号。得到的新的信号就是在原信号前面新加了一个值。</p><ul><li>scanWithStart:reduceWithIndex<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)scanWithStart:(<span class="keyword">id</span>)startingValue reduceWithIndex:(<span class="keyword">id</span> (^)(<span class="keyword">id</span>, <span class="keyword">id</span>, <span class="built_in">NSUInteger</span>))reduceBlock &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(reduceBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">        __block <span class="keyword">id</span> running = startingValue;</span><br><span class="line">        __block <span class="built_in">NSUInteger</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            running = reduceBlock(running, value, index++);</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:running];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -scanWithStart: %@ reduceWithIndex:"</span>, <span class="keyword">self</span>.name, [startingValue rac_description]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>内部调用bind方法<br>原信号的每个信号都会由变换函数reduceBlock( )进行变换<br>初始值是入参startingValue,然后index进行自增</p><p>事例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">                      &#123;</span><br><span class="line">                          [subscriber sendNext:@1];</span><br><span class="line">                          [subscriber sendNext:@2];</span><br><span class="line">                          [subscriber sendNext:@4];</span><br><span class="line">                          return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                          &#125;];</span><br><span class="line">                      &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalB = [signalA scanWithStart:@(2) reduceWithIndex:^id(NSNumber * running, NSNumber * next, NSUInteger index) &#123;</span><br><span class="line">    return @(running.intValue * next.intValue + index);</span><br><span class="line">&#125;];</span><br><span class="line">[signalB subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2    // 2 * 1 + 0 = 2</span><br><span class="line">5    // 2 * 2 + 1 = 5</span><br><span class="line">22  // 5 * 4 + 2 = 22</span><br></pre></td></tr></table></figure></p><ul><li>scanWithStart:reduce<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)scanWithStart:(<span class="keyword">id</span>)startingValue reduce:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> running, <span class="keyword">id</span> next))reduceBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(reduceBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span></span><br><span class="line">scanWithStart:startingValue</span><br><span class="line">reduceWithIndex:^(<span class="keyword">id</span> running, <span class="keyword">id</span> next, <span class="built_in">NSUInteger</span> index) &#123;</span><br><span class="line"><span class="keyword">return</span> reduceBlock(running, next);</span><br><span class="line">&#125;]</span><br><span class="line">setNameWithFormat:<span class="string">@"[%@] -scanWithStart: %@ reduce:"</span>, <span class="keyword">self</span>.name, RACDescription(startingValue)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>内部是对 <code>scanWithStart:reduceWithIndex</code> 方法的简化,返回的是入参 reduceBlock ，不进行自增</p><ul><li><p>combineLatestWith<br>从名字就可以看到，是将两个信号进行组合<br>当只接收到一个信号的时候，return<br>当收到两个信号的时候，将两者进行打包<code>RACTuplePack(lastSelfValue, lastOtherValue)</code>,然后发送给订阅者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)combineLatestWith:(RACSignal *)signal &#123;</span><br><span class="line">NSCParameterAssert(signal != nil);</span><br><span class="line"></span><br><span class="line">return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">__block id lastSelfValue = nil;</span><br><span class="line">__block BOOL selfCompleted = NO;</span><br><span class="line"></span><br><span class="line">__block id lastOtherValue = nil;</span><br><span class="line">__block BOOL otherCompleted = NO;</span><br><span class="line"></span><br><span class="line">void (^sendNext)(void) = ^&#123;</span><br><span class="line">@synchronized (disposable) &#123;</span><br><span class="line">if (lastSelfValue == nil || lastOtherValue == nil) return;</span><br><span class="line">[subscriber sendNext:RACTuplePack(lastSelfValue, lastOtherValue)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RACDisposable *selfDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line">@synchronized (disposable) &#123;</span><br><span class="line">lastSelfValue = x ?: RACTupleNil.tupleNil;</span><br><span class="line">sendNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">@synchronized (disposable) &#123;</span><br><span class="line">selfCompleted = YES;</span><br><span class="line">if (otherCompleted) [subscriber sendCompleted];//只有两者都完成，才会发送完成信号</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">RACDisposable *otherDisposable = [signal subscribeNext:^(id x) &#123;</span><br><span class="line">@synchronized (disposable) &#123;</span><br><span class="line">lastOtherValue = x ?: RACTupleNil.tupleNil;</span><br><span class="line">sendNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">@synchronized (disposable) &#123;</span><br><span class="line">otherCompleted = YES;</span><br><span class="line">if (selfCompleted) [subscriber sendCompleted]; //只有两者都完成，才会发送完成信号</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:otherDisposable];</span><br><span class="line"></span><br><span class="line">return disposable;</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -combineLatestWith: %@&quot;, self.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>combineLatest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)combineLatest:(id&lt;NSFastEnumeration&gt;)signals &#123;</span><br><span class="line">return [[self join:signals block:^(RACSignal *left, RACSignal *right) &#123;</span><br><span class="line">return [left combineLatestWith:right];</span><br><span class="line">&#125;] setNameWithFormat:@&quot;+combineLatest: %@&quot;, signals];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>combineLatest:的实现就是把入参数组里面的每个信号都调用一次join: block:方法。传入的闭包是把两个信号combineLatestWith:一下。combineLatest:的实现就是2个操作的组合。</p><ul><li>join:block<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ (__kindof RACStream *)join:(id&lt;NSFastEnumeration&gt;)streams block:(RACStream * (^)(id, id))block &#123;</span><br><span class="line">RACStream *current = nil;</span><br><span class="line">  // 第一步</span><br><span class="line">for (RACStream *stream in streams) &#123;</span><br><span class="line">if (current == nil) &#123;</span><br><span class="line">current = [stream map:^(id x) &#123;</span><br><span class="line">return RACTuplePack(x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">current = block(current, stream);</span><br><span class="line">&#125;</span><br><span class="line">  // 第二步</span><br><span class="line">if (current == nil) return [self empty];</span><br><span class="line"></span><br><span class="line">return [current map:^(RACTuple *xs) &#123;</span><br><span class="line"></span><br><span class="line">NSMutableArray *values = [[NSMutableArray alloc] init];</span><br><span class="line">    //第三步</span><br><span class="line">while (xs != nil) &#123;</span><br><span class="line">[values insertObject:xs.last ?: RACTupleNil.tupleNil atIndex:0];</span><br><span class="line">xs = (xs.count &gt; 1 ? xs.first : nil);</span><br><span class="line">&#125;</span><br><span class="line">    //第四步</span><br><span class="line">return [RACTuple tupleWithObjectsFromArray:values];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>此方法将当前信号流遍历<br>1.先依次打包信号流，首先将第一个信号打包成元组，然后将第一个元组和第二个信号传入block执行，依次类推，知道所有的信号都打包了<br>block操作返回信号，类似于zip，将两个信号进行压缩，只有两个信号都执行完毕才会将最新的值打包出去<br>2.如果current为空，返回空信号<br>3.这一步是把之前第一步打包出来的结果，还原回原信号的过程。经过第一步的循环之后，current会是类似这个样子，(((1), 2), 3)，第三步就是为了把这种多重元组解出来，每个信号流都依次按照顺序放在数组里。注意观察current的特点，最外层的元组，是一个值和一个元组，所以从最外层的元组开始，一层一层往里“剥”。while循环每次都取最外层元组的last，即那个单独的值，插入到数组的第0号位置，然后取出first即是里面一层的元组。然后依次循环。由于每次都插入到数组0号的位置，类似于链表的头插法，最终数组里面的顺序肯定也保证是原信号的顺序<br>4.把还原成原信号顺序 的数组 包装成元组，返回给map操作的闭包<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)tupleWithObjectsFromArray:(<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> tupleWithObjectsFromArray:array convertNullsToNils:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)tupleWithObjectsFromArray:(<span class="built_in">NSArray</span> *)array convertNullsToNils:(<span class="built_in">BOOL</span>)convert &#123;</span><br><span class="line">    RACTuple *tuple = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (convert) &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *newArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:array.count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> array) &#123;</span><br><span class="line">            [newArray addObject:(object == <span class="built_in">NSNull</span>.null ? RACTupleNil.tupleNil : object)];</span><br><span class="line">        &#125;</span><br><span class="line">        tuple.backingArray = newArray;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tuple.backingArray = [array <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tuple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>入参convert为NO，将array进行copy 返回元组</p><ul><li>switchToLatest</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)switchToLatest &#123;</span><br><span class="line"><span class="comment">// block4</span></span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"><span class="comment">// block5</span></span><br><span class="line">RACMulticastConnection *connection = [<span class="keyword">self</span> publish]; <span class="comment">//产生热信号</span></span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [[connection.signal</span><br><span class="line">flattenMap:^(RACSignal *x) &#123;  <span class="comment">//对原信号进行变换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSCAssert</span>(x == <span class="literal">nil</span> || [x isKindOfClass:RACSignal.class], <span class="string">@"-switchToLatest requires that the source signal (%@) send signals. Instead we got: %@"</span>, <span class="keyword">self</span>, x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [x takeUntil:[connection.signal concat:[RACSignal never]]];</span><br><span class="line">&#125;]</span><br><span class="line">subscribe:subscriber];</span><br><span class="line"></span><br><span class="line">RACDisposable *connectionDisposable = [connection connect];</span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line">[connectionDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -switchToLatest"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switchToLatest只能用在高阶信号,通过<code>[self publish];</code>产生热信号<br><code>connection.signal</code> 是 RACSubject 类型, 通过<code>flattenMap</code>方法对信号进行变换<br><code>connection.signal</code>会先<code>concat:</code>一个never信号,</p><p>flattenMap:变换中x是一个信号，对x进行takeUntil:变换，效果就是下一个信号到来之前，x会一直发送信号，一旦下一个信号到来，x就会被取消订阅，开始订阅新的信号。</p><ul><li>zipWith 和 concat</li><li>reduceEach / flattenMap / map /<br><a href="https://pattyxp.github.io/2018/03/12/ReactiveObjc%E5%85%A5%E9%97%A8/">请看这篇文章</a></li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.jianshu.com/p/707ece08257e" target="_blank" rel="noopener">https://www.jianshu.com/p/707ece08257e</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文源码为 ReactiveObjc 3.1.0 版本&lt;/p&gt;
&lt;p&gt;除了入门篇介绍的一些常用方法，本篇来介绍下过滤和组合相关的方法底层实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filter&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="https://pattyxp.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>记录一次坑</title>
    <link href="https://pattyxp.github.io/2018/03/22/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%9D%91/"/>
    <id>https://pattyxp.github.io/2018/03/22/记录一次坑/</id>
    <published>2018-03-22T02:02:47.000Z</published>
    <updated>2018-08-16T07:24:33.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="坑一"><a href="#坑一" class="headerlink" title="坑一"></a>坑一</h2><p>这真是一次莫名其妙的经历<br>场景如下:<br>有一个页面，底下有个按钮，之前都测试的OK,莫名其妙的突然之间不管点击什么地方，都会走按钮的逻辑，检查发现按钮的点击区域没有扩大，甚至点击返回按钮都被触动按钮点击事件，同样的页面，如果没有显示这个按钮一切逻辑倒是正常的，找同事看了下，笑话说如果真的是这样的效果，能做到也不容易啊</p><p>后面发现可能是我电脑缓存的问题，于是把相关的库和工程的缓存都给清理了下，世界清静了 ~ ~ ~</p><h2 id="坑二"><a href="#坑二" class="headerlink" title="坑二"></a>坑二</h2><p>更新Alfred (3.6.1), 原先好好的锁屏功能<code>lock</code> 无法识别了，每次都打开QQ的联系人列表，一直没搞明白，后来查到是因为QQ的联系人列表快捷键冲突的问题导致的（哎，当时怎么没往那方面去思考呢~），修改QQ的联系人快捷键，直接废弃好了，反正感觉不常用，终于可以快捷键锁屏了,速度比之前版本快多了  ~ ~ ~ </p><h2 id="坑三"><a href="#坑三" class="headerlink" title="坑三"></a>坑三</h2><p>UITextView的光标竟然不显示颜色，看着好奇怪，网上有说是因为背景色和光标颜色(默认白色)一致导致的，结果我修改了背景颜色也没起作用，需要设置光标颜色<code>textView.tintColor</code></p><h2 id="坑四"><a href="#坑四" class="headerlink" title="坑四"></a>坑四</h2><p>大坑来了，iOS8上面，在一个controller.xib里面放入一个view空页面，在空情况下去加载显示，点击的时候crash了<br>日志是说dealloc了，没有去持有，点击事件就不能正确发送了<br>在xib里面存在两个view，且共同显示在一个视图的时候，就不正常，强持有这个view不行，强持有按钮也不行，空页面在加载的时候就被释放了，单独拖出来放在新建的view下面就OK了，真是第一次被这个问题坑到了，本来想着简单点就不去创建新的页面，反而引发这个没想到的问题，好吧，记下来</p><h2 id="坑五"><a href="#坑五" class="headerlink" title="坑五"></a>坑五</h2><p>在一个页面，刷新section0，但是如果当前tableView还没有调用过<code>reload Data</code>，没有存在<code>section0</code>,那么直接刷新<code>section 0</code>是会直接闪退的，啊哦，这个是分的两个接口，接口请求回来的时机，不好把握，自测没有测到，也没有想得如此周到，怪自己不小心啊</p><h2 id="坑六"><a href="#坑六" class="headerlink" title="坑六"></a>坑六</h2><p>在切换分支的时候，重新install,遇到个error<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  - Running pre install hooks</span><br><span class="line">[!] The <span class="string">'Pods-xxxx'</span> target has frameworks with conflicting <span class="symbol">names:</span> xxx.framework.</span><br></pre></td></tr></table></figure></p><p>没办法，<code>pod cache clean</code>也不管用，还是老老实实的不使用本地的path</p><h2 id="坑七"><a href="#坑七" class="headerlink" title="坑七"></a>坑七</h2><p>在pods安装的时候，遇到了历史问题 <code>library not found for -lToast</code><br>问题是没有使用过它，没有引入过这个pod啊，所以 按照网上说的方法都不对，<br>最后搜索的时候，倒是发现其在某一处有在Tagets/Build Settings<br><img src="/images/library_error.png" alt="library_error"></p><p>删除历史遗留下来的不需要的库即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;坑一&quot;&gt;&lt;a href=&quot;#坑一&quot; class=&quot;headerlink&quot; title=&quot;坑一&quot;&gt;&lt;/a&gt;坑一&lt;/h2&gt;&lt;p&gt;这真是一次莫名其妙的经历&lt;br&gt;场景如下:&lt;br&gt;有一个页面，底下有个按钮，之前都测试的OK,莫名其妙的突然之间不管点击什么地方，都会走按钮
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactiveObjc-RACSubject</title>
    <link href="https://pattyxp.github.io/2018/03/20/ReactiveObjc-RACSubject/"/>
    <id>https://pattyxp.github.io/2018/03/20/ReactiveObjc-RACSubject/</id>
    <published>2018-03-20T08:36:31.000Z</published>
    <updated>2018-05-18T03:34:24.110Z</updated>
    
    <content type="html"><![CDATA[<p>本文源码为 ReactiveObjc 3.1.0 版本</p><h2 id="RACSubject"><a href="#RACSubject" class="headerlink" title="RACSubject"></a>RACSubject</h2><p>RACSubject 继承自 RACSignal，主要用于将非 RAC 的对象桥接到 RAC ，属于可变信号</p><blockquote><p>A subject can be thought of as a signal that you can manually control by sending next, completed, and error.They’re most helpful in bridging the non-RAC world to RAC, since they let you<br>manually control the sending of events.</p></blockquote><p>RACSubject 与子类<br><img src="/images/RACSubject.png" alt="RACSubject与子类关系"></p><p>RACSubject 对外提供的接口只有两个，遵循<racsubscriber>协议<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACSubject</span>&lt;<span class="title">ValueType</span>&gt; : <span class="title">RACSignal</span>&lt;<span class="title">ValueType</span>&gt; &lt;<span class="title">RACSubscriber</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Returns a new subject.</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)subject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redeclaration of the RACSubscriber method. Made in order to specify a generic type.</span></span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">nullable</span> ValueType)value;</span><br></pre></td></tr></table></figure></racsubscriber></p><ul><li>举例子<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscriber 1</span></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1st Sub: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscriber 2</span></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2nd Sub: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscriber 3</span></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3rd Sub: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">3</span>];</span><br><span class="line">[subject sendCompleted];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 2018-01-17 14:14:56.437059+0800 ReactiveObjcTest[270:1821989] 1st Sub: 1</span></span><br><span class="line"><span class="comment"> 2018-01-17 14:14:56.437269+0800 ReactiveObjcTest[270:1821989] 1st Sub: 2</span></span><br><span class="line"><span class="comment"> 2018-01-17 14:14:56.437387+0800 ReactiveObjcTest[270:1821989] 2nd Sub: 2</span></span><br><span class="line"><span class="comment"> 2018-01-17 14:14:56.437594+0800 ReactiveObjcTest[270:1821989] 1st Sub: 3</span></span><br><span class="line"><span class="comment"> 2018-01-17 14:14:56.438327+0800 ReactiveObjcTest[270:1821989] 2nd Sub: 3</span></span><br><span class="line"><span class="comment"> 2018-01-17 14:14:56.438564+0800 ReactiveObjcTest[270:1821989] 3rd Sub: 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> RACSubject 是时间相关的，它在发送消息时只会向已订阅的订阅者推送消息。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul><p>当调用sendNext方法<br>内部遍历当前数组内的subscriber，发送消息，和父类的不同就是可以先订阅，再发送信息，能否接收到消息取决于订阅的时间<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">[<span class="keyword">self</span> enumerateSubscribersUsingBlock:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendNext:value];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="热信号-和-冷信号"><a href="#热信号-和-冷信号" class="headerlink" title="热信号 和 冷信号"></a>热信号 和 冷信号</h2><p>在 <a href="https://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-1.html" target="_blank" rel="noopener">细说ReactiveCocoa的冷信号与热信号（一）</a> 详细分析了冷热信号的特点：<br>&gt;<br>热信号是主动的，即使你没有订阅事件，它仍然会时刻推送。而冷信号是被动的，只有当你订阅的时候，它才会发送消息。<br>热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息。而冷信号只能一对一，当有不同的订阅者，消息会从新完整发送。</p><p>在RAC中，RACSignal 属于冷信号， 每个订阅者会收到所有的消息<br>RACSubject 属于热信号，消息的接收取决于订阅的时间</p><p>从上面的例子中，可以观察到，由于 subscribeNext 调用时机不同，收到的消息内容序列不一样</p><ul><li>调用 subscribeNext 方法, 产生 RACSubscriber</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSignal.m</span><br><span class="line">- (RACDisposable *)subscribeNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))nextBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(nextBlock != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:<span class="literal">NULL</span> completed:<span class="literal">NULL</span>];</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写 <code>subscribe</code> 方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(subscriber != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="keyword">self</span> disposable:disposable];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> *subscribers = <span class="keyword">self</span>.subscribers;</span><br><span class="line"><span class="keyword">@synchronized</span> (subscribers) &#123;</span><br><span class="line">[subscribers addObject:subscriber];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:[RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (subscribers) &#123;</span><br><span class="line"><span class="comment">// Since newer subscribers are generally shorter-lived, search</span></span><br><span class="line"><span class="comment">// starting from the end of the list.</span></span><br><span class="line"><span class="built_in">NSUInteger</span> index = [subscribers indexOfObjectWithOptions:<span class="built_in">NSEnumerationReverse</span> passingTest:^ <span class="built_in">BOOL</span> (<span class="keyword">id</span>&lt;RACSubscriber&gt; obj, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">return</span> obj == subscriber;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index != <span class="built_in">NSNotFound</span>) [subscribers removeObjectAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line">&#125;]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的作用</p><ul><li>产生 RACPassthroughSubscriber 实例</li><li>将生成的 subscriber 添加入 RACSubject 拥有的数组里</li><li>创建 disposable对象，在当前 subscriber 销毁时，将 自身从数组中移除</li></ul><ul><li>sendNext</li></ul><p>由于 RACSubject 遵循了<racsubscriber>协议<br>所以可以调用 sendNext 等一系列方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">[<span class="keyword">self</span> enumerateSubscribersUsingBlock:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendNext:value];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">[<span class="keyword">self</span>.disposable dispose];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> enumerateSubscribersUsingBlock:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendCompleted &#123;</span><br><span class="line">[<span class="keyword">self</span>.disposable dispose];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> enumerateSubscribersUsingBlock:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></racsubscriber></p><p>以上方法都是调用forin 遍历自身的subscribes数组，调用block<br>这里会向每个 subscriber 都调用block<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enumerateSubscribersUsingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))block &#123;</span><br><span class="line"><span class="built_in">NSArray</span> *subscribers;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>.subscribers) &#123;</span><br><span class="line">subscribers = [<span class="keyword">self</span>.subscribers <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber <span class="keyword">in</span> subscribers) &#123;</span><br><span class="line">block(subscriber);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上方法为了防止发生资源竞争，都采用 <code>@synchronized</code> 来进行加锁</p><p>关于 RACSubject 基本介绍到这里就差不多了</p><p>下面看下子类</p><h2 id="RACBehaviorSubject"><a href="#RACBehaviorSubject" class="headerlink" title="RACBehaviorSubject"></a>RACBehaviorSubject</h2><blockquote><p>A behavior subject sends the last value it received when it is subscribed to.</p></blockquote><p>订阅时会向 订阅者发送最新的消息</p><p>声明如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACBehaviorSubject</span>&lt;<span class="title">ValueType</span>&gt; : <span class="title">RACSubject</span>&lt;<span class="title">ValueType</span>&gt;</span></span><br><span class="line"><span class="comment">/// Creates a new behavior subject with a default value. If it hasn't received</span></span><br><span class="line"><span class="comment">/// any values when it gets subscribed to, it sends the default value.</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)behaviorSubjectWithDefaultValue:(<span class="keyword">nullable</span> ValueType)value;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><ul><li>初始化<br>提供一个类方法，创建一个带有默认值的 subject ，如果订阅后没有收到任何值就会返回默认值</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)behaviorSubjectWithDefaultValue:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">RACBehaviorSubject *subject = [<span class="keyword">self</span> subject];</span><br><span class="line">subject.currentValue = value;</span><br><span class="line"><span class="keyword">return</span> subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重写了 subscribe 方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">RACDisposable *subscriptionDisposable = [<span class="keyword">super</span> subscribe:subscriber]; <span class="comment">//将subscriber 添加入自身的数组</span></span><br><span class="line"></span><br><span class="line">RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">[subscriber sendNext:<span class="keyword">self</span>.currentValue]; <span class="comment">//发送最新的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line">[schedulingDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>重写了 sendNext 方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.currentValue = value;  <span class="comment">//设置 最新的值</span></span><br><span class="line">[<span class="keyword">super</span> sendNext:value];     <span class="comment">//向数组内每个订阅者都发送最新的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事例</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RACBehaviorSubject *subject = [RACBehaviorSubject behaviorSubjectWithDefaultValue:@<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  [subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"1st Sub: %@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  [subject sendNext:@<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  [subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"2nd Sub: %@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  [subject sendNext:@<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Subscriber 3</span></span><br><span class="line">  [subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"3rd Sub: %@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  [subject sendNext:@<span class="number">3</span>];</span><br><span class="line">  [subject sendCompleted];</span><br></pre></td></tr></table></figure><p>将上面例子的 RACSubject 替换为 RACBehaviorSubject<br>打印log如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1st Sub: 10</span><br><span class="line">1st Sub: 1</span><br><span class="line">2nd Sub: 1</span><br><span class="line">1st Sub: 2</span><br><span class="line">2nd Sub: 2</span><br><span class="line">3rd Sub: 2</span><br><span class="line">1st Sub: 3</span><br><span class="line">2nd Sub: 3</span><br><span class="line">3rd Sub: 3</span><br></pre></td></tr></table></figure></p><p>当第一个调用subscribeNext 方法时候，会向生成的RACSubscriber 对象发送当前最新的值，默认值为@10，[subscriber sendNext:self.currentValue];接收到之后执行nextBlock,<code>NSLog(@&quot;1st Sub: %@&quot;, x);</code> 后面流程都一致此处省略</p><h2 id="RACReplaySubject"><a href="#RACReplaySubject" class="headerlink" title="RACReplaySubject"></a>RACReplaySubject</h2><p>订阅时会向 订阅者发送以前所有的消息</p><p>对外声明一个类方法，创建带有给定容量的 subject<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACReplaySubject</span>&lt;<span class="title">ValueType</span>&gt; : <span class="title">RACSubject</span>&lt;<span class="title">ValueType</span>&gt;</span></span><br><span class="line"><span class="comment">/// Creates a new replay subject with the given capacity. A capacity of</span></span><br><span class="line"><span class="comment">/// RACReplaySubjectUnlimitedCapacity means values are never trimmed.</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)replaySubjectWithCapacity:(<span class="built_in">NSUInteger</span>)capacity;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACReplaySubject</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> capacity;</span><br><span class="line"><span class="comment">// These properties should only be modified while synchronized on self.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSMutableArray</span> *valuesReceived;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> hasCompleted;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> hasError;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>内部valuesReceived，存储了收到了value，使用 synchronized 避免线程竞争</p><ul><li>初始化方法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)replaySubjectWithCapacity:(<span class="built_in">NSUInteger</span>)capacity &#123;</span><br><span class="line"><span class="keyword">return</span> [(RACReplaySubject *)[<span class="keyword">self</span> alloc] initWithCapacity:capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCapacity:(<span class="built_in">NSUInteger</span>)capacity &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_capacity = capacity;</span><br><span class="line">_valuesReceived = (capacity == RACReplaySubjectUnlimitedCapacity ? [<span class="built_in">NSMutableArray</span> array] : [<span class="built_in">NSMutableArray</span> arrayWithCapacity:capacity]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>根据入参 capacity 来初始化 内部的属性可变数组 valuesReceived</p><p>下面是遵循协议的方法</p><ul><li>sendNext<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">[<span class="keyword">self</span>.valuesReceived addObject:value ?: RACTupleNil.tupleNil];</span><br><span class="line">[<span class="keyword">super</span> sendNext:value];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.capacity != RACReplaySubjectUnlimitedCapacity &amp;&amp; <span class="keyword">self</span>.valuesReceived.count &gt; <span class="keyword">self</span>.capacity) &#123;</span><br><span class="line">[<span class="keyword">self</span>.valuesReceived removeObjectsInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="keyword">self</span>.valuesReceived.count - <span class="keyword">self</span>.capacity)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>将参数 value 添加入数组 ，调用父类的方法，发送消息，向内部所以的订阅者都发送消息<br>如果数组的数量超过初始化时的限制，将之前数据移除</p><ul><li><code>[self.valuesReceived addObject:value ?: RACTupleNil.tupleNil];</code><br>当value为空，需要包装为 RACTupleNil</li></ul><ul><li><p>sendCompleted</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendCompleted &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.hasCompleted = <span class="literal">YES</span>;</span><br><span class="line">[<span class="keyword">super</span> sendCompleted];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sendError</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendError:(<span class="built_in">NSError</span> *)e &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.hasError = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">self</span>.error = e;</span><br><span class="line">[<span class="keyword">super</span> sendError:e];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>subscribe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">for (id value in self.valuesReceived) &#123;</span><br><span class="line">if (compoundDisposable.disposed) return;</span><br><span class="line"></span><br><span class="line">[subscriber sendNext:(value == RACTupleNil.tupleNil ? nil : value)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (compoundDisposable.disposed) return;</span><br><span class="line"></span><br><span class="line">if (self.hasCompleted) &#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125; else if (self.hasError) &#123;</span><br><span class="line">[subscriber sendError:self.error];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">RACDisposable *subscriptionDisposable = [super subscribe:subscriber];</span><br><span class="line">[compoundDisposable addDisposable:subscriptionDisposable];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[compoundDisposable addDisposable:schedulingDisposable];</span><br><span class="line"></span><br><span class="line">return compoundDisposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过for循环 向 当前的subscriber 对象发送数组 valuesReceived 内的每个元素， 如果当前收到发送完成信号或者失败信号，就调用sendCompleted或者sendError方法</li></ul></li><li><p>事例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RACReplaySubject *subject = [RACReplaySubject subject];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1st Subscriber: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2nd Subscriber: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3rd Subscriber: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@<span class="number">3</span>];</span><br><span class="line">[subject sendCompleted];</span><br></pre></td></tr></table></figure></li></ul><p>打印log<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1st Subscriber: 1</span><br><span class="line">2nd Subscriber: 1</span><br><span class="line">1st Subscriber: 2</span><br><span class="line">2nd Subscriber: 2</span><br><span class="line">3rd Subscriber: 1</span><br><span class="line">3rd Subscriber: 2</span><br><span class="line">1st Subscriber: 3</span><br><span class="line">2nd Subscriber: 3</span><br><span class="line">3rd Subscriber: 3</span><br></pre></td></tr></table></figure></p><p>当第一次调用subscribeNext 方法，会向当前生成的订阅对象RACSubscriber 发送所有的值，一开始数据为空，不会发送sendNext,将当前的subscriber对象 添加入subscribers数组<br>当第二次调用subscribeNext 方法, 会向当前生成的订阅对象RACSubscriber 发送所有的值，目前 valuesReceived内只有1，因此打印<code>NSLog(@&quot;2nd Subscriber: %@&quot;, x);</code>后续操作省略</p><h2 id="RACGroupedSignal"><a href="#RACGroupedSignal" class="headerlink" title="RACGroupedSignal"></a>RACGroupedSignal</h2><p>分组信号，用来实现 RACSignal 的分组功能</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A grouped signal is used by -[RACSignal groupBy:transform:].</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACGroupedSignal</span> : <span class="title">RACSubject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// The key shared by the group.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt; key;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)signalWithKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)key;</span><br></pre></td></tr></table></figure><ul><li><p>初始化<br>初始化含有key属性的 Subject</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)signalWithKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)key &#123;</span><br><span class="line">RACGroupedSignal *subject = [<span class="keyword">self</span> subject];</span><br><span class="line">subject.key = key;</span><br><span class="line"><span class="keyword">return</span> subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事例<br>配合groupBy:transform:方法返回 RACGroupedSignal对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">                         &#123;</span><br><span class="line">                             [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">                             [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">                             [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">                             [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">                             [subscriber sendNext:@<span class="number">5</span>];</span><br><span class="line">                             [subscriber sendCompleted];</span><br><span class="line">                             <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                                 <span class="built_in">NSLog</span>(<span class="string">@"signal dispose"</span>);</span><br><span class="line">                             &#125;];</span><br><span class="line">                         &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalGroup = [signalA groupBy:^<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;(<span class="built_in">NSNumber</span> *object) &#123;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">return</span> object.integerValue &gt; <span class="number">3</span> ? <span class="string">@"good"</span> : <span class="string">@"bad"</span>;</span><br><span class="line">           &#125; transform:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> * object) &#123;</span><br><span class="line">                         <span class="keyword">return</span> @(object.integerValue * <span class="number">10</span>);</span><br><span class="line">          &#125;];</span><br><span class="line">[[[signalGroup filter:^<span class="built_in">BOOL</span>(RACGroupedSignal *value) &#123;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">return</span> [(<span class="built_in">NSString</span> *)value.key isEqualToString:<span class="string">@"good"</span>];</span><br><span class="line">          &#125;] flatten]subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">                         <span class="built_in">NSLog</span>(<span class="string">@"subscribeNext: %@"</span>, x);</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure></li></ul><p>filter 方法用于过滤<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)filter:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^ <span class="keyword">id</span> (<span class="keyword">id</span> value) &#123;</span><br><span class="line"><span class="keyword">if</span> (block(value)) &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line">&#125;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -filter:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果满足过滤条件<code>block(value)</code>，就返回 <code>[class return:value]</code>RACReturnSignal，否则返回<code>class.empty</code> RACEmptySignal<br>RACReturnSignal.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RACReturnSignal *signal = [[self alloc] init];</span><br><span class="line">signal-&gt;_value = value;</span><br></pre></td></tr></table></figure></p><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>RACTuple 元组类,类似NSArray,用来包装值</p><ul><li>flattenMap （RACStream）</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)flattenMap:(RACStream * (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">        <span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="keyword">id</span> stream = block(value) ?: [<span class="keyword">class</span> empty];</span><br><span class="line">            <span class="built_in">NSCAssert</span>([stream isKindOfClass:RACStream.class], <span class="string">@"Value returned from -flattenMap: is not a stream: %@"</span>, stream);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> stream;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -flattenMap:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RACChannelTerminal-双向绑定"><a href="#RACChannelTerminal-双向绑定" class="headerlink" title="RACChannelTerminal 双向绑定"></a>RACChannelTerminal 双向绑定</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface RACChannelTerminal&lt;ValueType&gt; : RACSignal&lt;ValueType&gt; &lt;RACSubscriber&gt;</span><br><span class="line"></span><br><span class="line">- (instancetype)init __attribute__((unavailable(&quot;Instantiate a RACChannel instead&quot;)));</span><br><span class="line"></span><br><span class="line">// Redeclaration of the RACSubscriber method. Made in order to specify a generic type.</span><br><span class="line">- (void)sendNext:(nullable ValueType)value;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>它和RACSubject一样，既继承自RACSignal，同样又遵守RACSubscriber协议。虽然具有RACSubject的发送和接收信号的特性，但是它依旧是冷信号，因为它无法一对多，它发送信号还是只能一对一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self == nil) return nil;</span><br><span class="line"></span><br><span class="line">    RACReplaySubject *leadingSubject = [[RACReplaySubject replaySubjectWithCapacity:0] setNameWithFormat:@&quot;leadingSubject&quot;];</span><br><span class="line">    RACReplaySubject *followingSubject = [[RACReplaySubject replaySubjectWithCapacity:1] setNameWithFormat:@&quot;followingSubject&quot;];</span><br><span class="line"></span><br><span class="line">    [[leadingSubject ignoreValues] subscribe:followingSubject];</span><br><span class="line">    [[followingSubject ignoreValues] subscribe:leadingSubject];</span><br><span class="line"></span><br><span class="line">    _leadingTerminal = [[[RACChannelTerminal alloc] initWithValues:leadingSubject otherTerminal:followingSubject] setNameWithFormat:@&quot;leadingTerminal&quot;];</span><br><span class="line">    _followingTerminal = [[[RACChannelTerminal alloc] initWithValues:followingSubject otherTerminal:leadingSubject] setNameWithFormat:@&quot;followingTerminal&quot;];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入参 values 其实是 RACReplaySubject 对象，所以内部订阅<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">return [self.values subscribe:subscriber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>订阅 RACChannelTerminal 过程实际是订阅 RACReplaySubject 对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line">[self.otherTerminal sendNext:value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sendError:(NSError *)error &#123;</span><br><span class="line">[self.otherTerminal sendError:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sendCompleted &#123;</span><br><span class="line">[self.otherTerminal sendCompleted];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>self.otherTerminal也是RACReplaySubject类型的，RACChannelTerminal管道两边都是RACReplaySubject类型的信号。当RACChannelTerminal开始sendNext，sendError，sendCompleted是调用的管道另外一个RACReplaySubject进行这些对应操作。<br>通常应用场景是在MVVM设计模式的View 和 ViewModel 中</p><p>例如登录界面</p><h2 id="冷热信号的转换"><a href="#冷热信号的转换" class="headerlink" title="冷热信号的转换"></a>冷热信号的转换</h2><p>由于冷信号是一对一，有些情况的局限的，比如网络请求，<br>如果使用RACSignal ,那么每次订阅，都会执行一遍信号创建时候的block进行发送信号,操作太频繁反而会浪费资源，故此如果能够将多次订阅转为一次执行，就利用到了热信号，一对多的关系，将冷信号转为热信号,无论有多少个订阅者，无论订阅多少次，只发送一次，这里需要使用  RACMulticastConnection<br>在<a href="https://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-2.html" target="_blank" rel="noopener">细说ReactiveCocoa的冷信号与热信号（二）：为什么要区分冷热信号</a>一文有详细说明</p><h3 id="RACMulticastConnection"><a href="#RACMulticastConnection" class="headerlink" title="RACMulticastConnection"></a>RACMulticastConnection</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface RACMulticastConnection&lt;__covariant ValueType&gt; : NSObject</span><br><span class="line"></span><br><span class="line">/// The multicasted signal.</span><br><span class="line">@property (nonatomic, strong, readonly) RACSignal&lt;ValueType&gt; *signal;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)connect;</span><br><span class="line"></span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)autoconnect RAC_WARN_UNUSED_RESULT;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>对外只申明一个RACSignal类型的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface RACMulticastConnection () &#123;</span><br><span class="line">RACSubject *_signal;  //RACSubject 类型的信号</span><br><span class="line">int32_t volatile _hasConnected;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly, strong) RACSignal *sourceSignal; //原信号是 RACSignal类型</span><br><span class="line">@property (strong) RACSerialDisposable *serialDisposable;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>内部存储了RACSignal 原信号 和 RACSubject 类型的 signal</p><p>初始化方法是私有的，官方不建议使用此方法进行初始化，而是推荐使用 RACSignal的实例方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (RACMulticastConnection *)publish &#123;</span><br><span class="line">RACSubject *subject = [[RACSubject subject] setNameWithFormat:@&quot;[%@] -publish&quot;, self.name];</span><br><span class="line">RACMulticastConnection *connection = [self multicast:subject];</span><br><span class="line">return connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACMulticastConnection *)multicast:(RACSubject *)subject &#123;</span><br><span class="line">[subject setNameWithFormat:@&quot;[%@] -multicast: %@&quot;, self.name, subject.name];</span><br><span class="line">RACMulticastConnection *connection = [[RACMulticastConnection alloc] initWithSourceSignal:self subject:subject];</span><br><span class="line">return connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个方法都会返回 RACMulticastConnection 对象，self是当前的原信号<br>publish 方法 将 原信号进行广播， 是对 multicast 方法的封装<br>multicast 方法需要入参 RACSubject 类型的对象</p><ul><li><p>初始化 赋值操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithSourceSignal:(RACSignal *)source subject:(RACSubject *)subject &#123;</span><br><span class="line">NSCParameterAssert(source != nil);</span><br><span class="line">NSCParameterAssert(subject != nil);</span><br><span class="line"></span><br><span class="line">self = [super init];</span><br><span class="line"></span><br><span class="line">_sourceSignal = source;</span><br><span class="line">_serialDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">_signal = subject;</span><br><span class="line"></span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="comment">// block 1</span></span><br><span class="line">    [subscriber sendNext:@<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] publish];</span><br><span class="line"></span><br><span class="line">[connection.signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">// block 2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"value: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[connection.signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"value: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[connection connect];</span><br></pre></td></tr></table></figure></li></ul><p>RACMulticastConnection 需要调用connect 方法去触发 订阅操作<br><a href="https://draveness.me/racconnection" target="_blank" rel="noopener">图片来源</a><br><img src="/images/RACMutiConnection.png" alt="RACMutiConnection"></p><ul><li>connect 连接方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)connect &#123;</span><br><span class="line">BOOL shouldConnect = OSAtomicCompareAndSwap32Barrier(0, 1, &amp;_hasConnected);</span><br><span class="line"></span><br><span class="line">if (shouldConnect) &#123;</span><br><span class="line">self.serialDisposable.disposable = [self.sourceSignal subscribe:_signal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return self.serialDisposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OSAtomicCompareAndSwap32Barrier，它是原子运算的操作符，主要用于Compare and swap，原型如下：</p><p><code>bool OSAtomicCompareAndSwap32Barrier( int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue );</code></p><p>关键字volatile只确保每次获取volatile变量时都是从内存加载变量，而不是使用寄存器里面的值，但是它不保证代码访问变量是正确的。</p><p>1.如果应该连接，执行<code>[self.sourceSignal subscribe:_signal];</code><br>此处 <code>self.suourceSignal</code> 属于 RACDynamicSignal 类型，<br>方法原型<code>- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber</code><br>2.执行 <code>subscribe</code>方法触发执行sourceSignal 信号创建时候的入参block<br>于是此处执行 <code>[subscriber sendNext:@10];</code> 发送消息<br>3.subscriber是初始化时候<code>subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</code> ，转发给RACPassthroughSubscriber 内部的innerSubscriber去执行<br>4.消息的订阅者是 _signal ，即 RACSubject, 于是向 RACSubject 对象发送 <code>sendNext</code><br>5.RACSubject 内部会去遍历自身的数组subscribers,逐一去发送消息<code>[subscriber sendNext:value];</code></p><p>打印<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReactiveObjcTest[<span class="number">15369</span>:<span class="number">1888001</span>] value: <span class="number">10</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-26</span> <span class="number">17</span>:<span class="number">22</span>:<span class="number">57.366415</span>+<span class="number">0800</span> ReactiveObjcTest[<span class="number">15369</span>:<span class="number">1888001</span>] value: <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>connect 方法通过 <code>subscribe</code>方法 将 RACSignal 和 RACSubject 进行连接<br>此外还有一个方法用于连接两者的关系</p><ul><li><p>autoconnect</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)autoconnect &#123;</span><br><span class="line">__block volatile int32_t subscriberCount = 0;</span><br><span class="line"></span><br><span class="line">return [[RACSignal</span><br><span class="line">createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">OSAtomicIncrement32Barrier(&amp;subscriberCount);</span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [self.signal subscribe:subscriber];</span><br><span class="line">RACDisposable *connectionDisposable = [self connect];</span><br><span class="line"></span><br><span class="line">return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line"></span><br><span class="line">if (OSAtomicDecrement32Barrier(&amp;subscriberCount) == 0) &#123;</span><br><span class="line">[connectionDisposable dispose];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;]</span><br><span class="line">setNameWithFormat:@&quot;[%@] -autoconnect&quot;, self.signal.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    // block 1</span><br><span class="line">    [subscriber sendNext:@10];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;] publish];</span><br><span class="line"></span><br><span class="line">[connection.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    // block 2</span><br><span class="line">    NSLog(@&quot;value: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[connection.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    // block 3</span><br><span class="line">    NSLog(@&quot;value: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *hotSignal = connection.autoconnect;</span><br><span class="line">[hotSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    // block4</span><br><span class="line">    NSLog(@&quot;value: %@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li></ul><p>具体步骤:<br>1.首先connection信号创建时候将block1进行copy<br>2.<code>[connection.signal subscribeNext]</code>执行将消息的订阅者存入RACSubject 对象的内部数组RACSubscribers<br>2.调用 autoconnect 时候创建新的信号hotSignal，先将block进行保存<br>3.<code>[hotSignal subscribeNext]</code> 执行的时候，调用hotsignal创建时候的block，那么会调用 autoconnect 方法内部的createSignal方法的block,执行<br><code>RACDisposable *subscriptionDisposable = [self.signal subscribe:subscriber];</code><br>signal对象是RACSubject类型，此方法将subscriber添加入 RACSubject 的内部数组里<br>4.执行<code>RACDisposable *connectionDisposable = [self connect];</code> 将建立 signal和 RACSubject 的关系</p><p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-03-26 17:54:44.798500+0800 ReactiveObjcTest[15468:1900659] value: 10</span><br><span class="line">2018-03-26 17:54:47.543048+0800 ReactiveObjcTest[15468:1900659] value: 10</span><br><span class="line">2018-03-26 17:54:48.918772+0800 ReactiveObjcTest[15468:1900659] value: 10</span><br></pre></td></tr></table></figure></p><p>在调用connect方法，前面已经执行一次<code>subscribe</code>方法,在 autoConnect 方法的返回信号对象第一次被订阅时，就会建立连接</p><p>除了调用<code>publish</code> 和 <code>multicast</code>方法之外，还有下面几个方法用于将 RACSignal 转换为 RACMulticastConnection</p><ul><li><ul><li>(RACSignal<valuetype> *)replay;</valuetype></li></ul></li><li><ul><li>(RACSignal<valuetype> *)replayLast;</valuetype></li></ul></li><li><ul><li>(RACSignal<valuetype> *)replayLazily;</valuetype></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RACSubject 继承自 RACSignal ，但是内部存储了一些遵循 RACSubscriber协议的对象，将原有的不可变信号转为可变信号，在实际情况下运用非常方便</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文源码为 ReactiveObjc 3.1.0 版本&lt;/p&gt;
&lt;h2 id=&quot;RACSubject&quot;&gt;&lt;a href=&quot;#RACSubject&quot; class=&quot;headerlink&quot; title=&quot;RACSubject&quot;&gt;&lt;/a&gt;RACSubject&lt;/h2&gt;&lt;p&gt;RAC
      
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="https://pattyxp.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveObjc-RACSequence</title>
    <link href="https://pattyxp.github.io/2018/03/15/ReactiveObjc-RACSequence/"/>
    <id>https://pattyxp.github.io/2018/03/15/ReactiveObjc-RACSequence/</id>
    <published>2018-03-15T07:12:30.000Z</published>
    <updated>2018-05-18T03:34:18.470Z</updated>
    
    <content type="html"><![CDATA[<p>本文源码为 ReactiveObjc 3.1.0 版本</p><h2 id="RACSequence"><a href="#RACSequence" class="headerlink" title="RACSequence"></a>RACSequence</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACSequence</span>&lt;<span class="title">__covariant</span> <span class="title">ValueType</span>&gt; : <span class="title">RACStream</span> &lt;<span class="title">NSCoding</span>, <span class="title">NSCopying</span>, <span class="title">NSFastEnumeration</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) ValueType head;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) RACSequence&lt;ValueType&gt; *tail;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;ValueType&gt; *array;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSEnumerator</span>&lt;ValueType&gt; *objectEnumerator;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;ValueType&gt; *eagerSequence;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;ValueType&gt; *lazySequence;</span><br></pre></td></tr></table></figure><p>RACSequence 主要由两部分组成， head 和 tail, head是一个 数字， tail 是 流RACSequence 的形式</p><p>先来了解下 RACSequence 相关的子类<br><img src="RACSequence子类结构图.png" alt="RACSequence子类结构图"></p><blockquote><p>此图来自 <img src="https://github.com/Draveness/analyze/blob/43d828b6f516a57e12eeff69913ff49cc94a0f36/contents/ReactiveObjC/RACSequence.md" alt="Draveness博客"></p></blockquote><p>这里，和RACSignal类似，获取 head 和 tail 的方法需要被子类重写<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)head &#123;</span><br><span class="line"><span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"%s must be overridden by subclasses"</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSequence *)tail &#123;</span><br><span class="line"><span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"%s must be overridden by subclasses"</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>empty<br>返回 RACEmptySequence 实例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSequence *)empty &#123;</span><br><span class="line"><span class="keyword">return</span> RACEmptySequence.empty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>return<br>返回 RACUnarySequence 实例，将传入的参数作为 head，tail 返回 nil</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSequence *)<span class="keyword">return</span>:(<span class="keyword">id</span>)value &#123;</span><br><span class="line"><span class="keyword">return</span> [RACUnarySequence <span class="keyword">return</span>:value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (RACUnarySequence *)<span class="keyword">return</span>:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">RACUnarySequence *sequence = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">sequence.head = value;</span><br><span class="line"><span class="keyword">return</span> [sequence setNameWithFormat:<span class="string">@"+return: %@"</span>, RACDescription(value)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark RACSequence</span></span><br><span class="line"></span><br><span class="line">- (RACSequence *)tail &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>bind</p></li></ul><p>调用内部 bind:passingThroughValuesFromSequence:方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (RACSequence *)bind:(RACSequenceBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">RACSequenceBindBlock bindBlock = block();</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:bindBlock passingThroughValuesFromSequence:<span class="literal">nil</span>] setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSequence *)bind:(RACSequenceBindBlock)bindBlock passingThroughValuesFromSequence:(RACSequence *)passthroughSequence &#123;</span><br><span class="line"></span><br><span class="line">__block RACSequence *valuesSeq = <span class="keyword">self</span>;</span><br><span class="line">__block RACSequence *current = passthroughSequence;</span><br><span class="line">__block <span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">RACSequence *sequence = [RACDynamicSequence sequenceWithLazyDependency:^ <span class="keyword">id</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (current.head == <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (stop) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> value = valuesSeq.head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (value == <span class="literal">nil</span>) &#123;</span><br><span class="line">stop = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">current = (<span class="keyword">id</span>)bindBlock(value, &amp;stop);</span><br><span class="line"><span class="keyword">if</span> (current == <span class="literal">nil</span>) &#123;</span><br><span class="line">stop = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">valuesSeq = valuesSeq.tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSCAssert</span>([current isKindOfClass:RACSequence.class], <span class="string">@"-bind: block returned an object that is not a sequence: %@"</span>, current);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125; headBlock:^(<span class="keyword">id</span> _) &#123;</span><br><span class="line"><span class="keyword">return</span> current.head;</span><br><span class="line">&#125; tailBlock:^ <span class="keyword">id</span> (<span class="keyword">id</span> _) &#123;</span><br><span class="line"><span class="keyword">if</span> (stop) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [valuesSeq bind:bindBlock passingThroughValuesFromSequence:current.tail];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">sequence.name = <span class="keyword">self</span>.name;</span><br><span class="line"><span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>内部创建 RACDynamicSequence 实例返回</p><p>创建RACDynamicSequence</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSequence *)sequenceWithLazyDependency:(<span class="keyword">id</span> (^)(<span class="keyword">void</span>))dependencyBlock headBlock:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> dependency))headBlock tailBlock:(RACSequence *(^)(<span class="keyword">id</span> dependency))tailBlock &#123;</span><br><span class="line">  ...</span><br><span class="line">RACDynamicSequence *seq = [[RACDynamicSequence alloc] init];</span><br><span class="line">seq.headBlock = [headBlock <span class="keyword">copy</span>];</span><br><span class="line">seq.tailBlock = [tailBlock <span class="keyword">copy</span>];</span><br><span class="line">seq.dependencyBlock = [dependencyBlock <span class="keyword">copy</span>];</span><br><span class="line">seq.hasDependency = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建好 RACDynamicSequence 之后，获取 head</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)head &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">id</span> untypedHeadBlock = <span class="keyword">self</span>.headBlock;</span><br><span class="line"><span class="keyword">if</span> (untypedHeadBlock == <span class="literal">nil</span>) <span class="keyword">return</span> _head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.hasDependency) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.dependencyBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">_dependency = <span class="keyword">self</span>.dependencyBlock();</span><br><span class="line"><span class="keyword">self</span>.dependencyBlock = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> (^headBlock)(<span class="keyword">id</span>) = untypedHeadBlock;</span><br><span class="line">_head = headBlock(_dependency);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">id</span> (^headBlock)(<span class="keyword">void</span>) = untypedHeadBlock;</span><br><span class="line">_head = headBlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.headBlock = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">return</span> _head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么这里获取head之后，将headBlock 、dependencyBlock 均清空了下次怎么办<br>解惑:<br>第一次获取head时候，如果已经获取到，headBlock 、dependencyBlock  清空<br>第二次获取head时候，headBlock 已经为空，所以直接返回第一次获取的结果，不需要再次赋值</p></blockquote><p>获取tail,和 head 获取方法同理<br>获取的 tail 依赖 tailBlock 和 dependencyBlock, 最后返回的tail 执行返回 RACSequence对象<br><code>return [valuesSeq bind:bindBlock passingThroughValuesFromSequence:current.tail];</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (RACSequence *)tail &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">id</span> untypedTailBlock = <span class="keyword">self</span>.tailBlock;</span><br><span class="line"><span class="keyword">if</span> (untypedTailBlock == <span class="literal">nil</span>) <span class="keyword">return</span> _tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.hasDependency) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.dependencyBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">_dependency = <span class="keyword">self</span>.dependencyBlock();</span><br><span class="line"><span class="keyword">self</span>.dependencyBlock = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RACSequence * (^tailBlock)(<span class="keyword">id</span>) = untypedTailBlock;</span><br><span class="line">_tail = tailBlock(_dependency);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">RACSequence * (^tailBlock)(<span class="keyword">void</span>) = untypedTailBlock;</span><br><span class="line">_tail = tailBlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_tail.name == <span class="literal">nil</span>) _tail.name = <span class="keyword">self</span>.name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.tailBlock = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">return</span> _tail;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面通过更具体的代码来了解bind方法使用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *sequence = [RACSequence sequenceWithHeadBlock:^<span class="keyword">id</span> _Nullable&#123;</span><br><span class="line">    <span class="keyword">return</span> @<span class="number">1</span>;</span><br><span class="line">&#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">    <span class="keyword">return</span>  [RACSequence sequenceWithHeadBlock:^<span class="keyword">id</span> _Nullable&#123;</span><br><span class="line">        <span class="keyword">return</span> @<span class="number">2</span>;</span><br><span class="line">    &#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">        <span class="keyword">return</span> [RACSequence <span class="keyword">return</span>:@<span class="number">3</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSequence *bindSequence = [sequence bind:^RACSequenceBindBlock _Nonnull&#123;</span><br><span class="line">    <span class="keyword">return</span> ^(<span class="built_in">NSNumber</span> *value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"RACSequenceBindBlock: %@"</span>, value);</span><br><span class="line">        value = @(value.integerValue * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> [RACSequence <span class="keyword">return</span>:value];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"BindSequence:  head=(%@) tail=(%@)"</span>, bindSequence.head, bindSequence.tail);</span><br></pre></td></tr></table></figure></p><p>log 获取的 head 有值，获取的 tail 是 RACSequence对象，值暂时都是unresolved<br><code>BindSequence:  head=(2) tail=(&lt;RACDynamicSequence: 0x600000098560&gt;{ name = , head = (unresolved), tail = (unresolved) })</code></p><p>上面的流程中，执行bind方法的block是惰性的， 只有在获取 RACSequence 对象的head以及tail的时候才会执行 LazyDependency,在 LazyDependency内部将value 执行bindBlock(value, &amp;stop),返回 RACUnarySequence 对象 最后通过head属性取出值</p><blockquote><p>注意:<br>在整个 ReactiveCocoa 中，所有的 RACSequence 对象在默认情况下都是惰性的，序列中的值只有在真正需要使用时才会被展开，在其他时间都是 unresolved。</p></blockquote><ul><li>lazySequence 和 eagerSequence</li></ul><p>打印下上面例子的这两个属性值<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *sequence = [RACSequence sequenceWithHeadBlock:^<span class="keyword">id</span> _Nullable&#123;</span><br><span class="line">       <span class="keyword">return</span> @<span class="number">1</span>;</span><br><span class="line">   &#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">       <span class="keyword">return</span>  [RACSequence sequenceWithHeadBlock:^<span class="keyword">id</span> _Nullable&#123;</span><br><span class="line">           <span class="keyword">return</span> @<span class="number">2</span>;</span><br><span class="line">       &#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">           <span class="keyword">return</span> [RACSequence <span class="keyword">return</span>:@<span class="number">3</span>];</span><br><span class="line">       &#125;];</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   RACSequence *bindSequence = [sequence bind:^RACSequenceBindBlock _Nonnull&#123;</span><br><span class="line">       <span class="keyword">return</span> ^(<span class="built_in">NSNumber</span> *value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"RACSequenceBindBlock: %@"</span>, value);</span><br><span class="line">           value = @(value.integerValue * <span class="number">2</span>);</span><br><span class="line">           <span class="keyword">return</span> [RACSequence <span class="keyword">return</span>:value];</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"BindSequence: lazySequence=(%@)"</span>, bindSequence.lazySequence);</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"BindSequence: eagerSequence=(%@)"</span>, bindSequence.eagerSequence);</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"BindSequence: lazySequence=(%@)"</span>, bindSequence.lazySequence);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BindSequence: lazySequence=(&lt;RACDynamicSequence: 0x6000000971b0&gt;&#123; name = , head = (unresolved), tail = (unresolved) &#125;)</span><br><span class="line">BindSequence: eagerSequence=(&lt;RACEagerSequence: 0x600000223ec0&gt;&#123; name = , array = (</span><br><span class="line">    2,</span><br><span class="line">    4,</span><br><span class="line">    6</span><br><span class="line">) &#125;)</span><br><span class="line">BindSequence: lazySequence=(&lt;RACDynamicSequence: 0x6000000971b0&gt;&#123; name = , head = 2, tail = &lt;RACDynamicSequence: 0x600000095040&gt;&#123; name = , head = 4, tail = &lt;RACDynamicSequence: 0x6040000939c0&gt;&#123; name = , head = 6, tail = (null) &#125; &#125; &#125;)</span><br></pre></td></tr></table></figure><p>可以看到 lazySequence 一开始还是unresolved ，调用 eagerSequence 之后，lazySequence 就不再是 unresolved</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (RACSequence *)lazySequence &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSequence *)eagerSequence &#123;</span><br><span class="line"><span class="keyword">return</span> [RACEagerSequence sequenceWithArray:<span class="keyword">self</span>.array offset:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RACArraySequence.m</span></span><br><span class="line">+ (RACSequence *)sequenceWithArray:(<span class="built_in">NSArray</span> *)array offset:(<span class="built_in">NSUInteger</span>)offset &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(offset &lt;= array.count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (offset == array.count) <span class="keyword">return</span> <span class="keyword">self</span>.empty;</span><br><span class="line"></span><br><span class="line">RACArraySequence *seq = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">seq-&gt;_backingArray = [array <span class="keyword">copy</span>];</span><br><span class="line">seq-&gt;_offset = offset;</span><br><span class="line"><span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eager从字面上也可以了解到，就是提前获取所有的数据</p><p>获取eagerSequence方法里面，有个参数<code>self.array</code><br>调用的是RACSequence的方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">[array addObject:obj];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [array <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印self<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">po self</span><br><span class="line">&lt;RACDynamicSequence: 0x604000095cc0&gt;&#123; name = , head = 2, tail =</span><br><span class="line">&lt;RACDynamicSequence: 0x600000282ee0&gt;&#123; name = , head = 4, tail =</span><br><span class="line">&lt;RACDynamicSequence: 0x600000282ad0&gt;&#123; name = , head = 6, tail = (null) &#125; &#125; &#125;</span><br></pre></td></tr></table></figure></p><p>好奇 array的obj是怎么来的，查看调用栈<br>RACSequence 有属性array，遵循协议 NSFastEnumeration ，因此执行forin的时候调用以下方法<br><code>- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id *)stackbuf count:(NSUInteger)len</code><br>该方法遍历获取 self ，通过<br><code>RACSequence *(^getSequence)(void) = ^{        return (__bridge RACSequence *)(void *)state-&gt;state;    };</code> 将当前对象内部的每一项state转化为sequence,然后获取head</p><ul><li>RACSequence 和 RACSignal</li></ul><p>两者存在区别，但是也可以相互转化</p><ul><li><p>RACSequence 转化为 RACSignal</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *sequence = @[@1,@2,@3].rac_sequence;</span><br><span class="line">RACSignal *signal = sequence.signal;</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;signal: %@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> signal: 1</span><br><span class="line"> signal: 2</span><br><span class="line"> signal: 3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>下面看下具体实现源码</p><p>内部是重新创建返回 RACSignal 通过递归调用 RACScheduler block方法，向 RACSubscriber 发送sendNext 直到结束</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  - (RACSignal *)signal &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> signalWithScheduler:[RACScheduler scheduler]] setNameWithFormat:<span class="string">@"[%@] -signal"</span>, <span class="keyword">self</span>.name];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> - (RACSignal *)signalWithScheduler:(RACScheduler *)scheduler &#123;</span><br><span class="line"> <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"> __block RACSequence *sequence = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> [scheduler scheduleRecursiveBlock:^(<span class="keyword">void</span> (^reschedule)(<span class="keyword">void</span>)) &#123;</span><br><span class="line"> <span class="keyword">if</span> (sequence.head == <span class="literal">nil</span>) &#123;</span><br><span class="line"> [subscriber sendCompleted];</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> [subscriber sendNext:sequence.head];</span><br><span class="line"> sequence = sequence.tail;</span><br><span class="line"> reschedule();</span><br><span class="line"> &#125;];</span><br><span class="line"> &#125;] setNameWithFormat:<span class="string">@"[%@] -signalWithScheduler: %@"</span>, <span class="keyword">self</span>.name, scheduler];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>RACSignal 转化为 RACSequence</p></li></ul><p>内部创建 RACArraySequence ，收集到发出的所有信号<br>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">      [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">      [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">      [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">      [subscriber sendCompleted];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, signal.toArray.rac_sequence);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   &lt;RACArraySequence: 0x600000222ca0&gt;&#123; name = , array = (</span></span><br><span class="line"><span class="comment">   1,</span></span><br><span class="line"><span class="comment">   2,</span></span><br><span class="line"><span class="comment">   3</span></span><br><span class="line"><span class="comment">   ) &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure></p><ul><li>Map 、 Filter 、 flattenMap</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array=@[@(<span class="number">2</span>),@(<span class="number">5</span>),@(<span class="number">7</span>),@(<span class="number">15</span>)];</span><br><span class="line">  RACSequence *sequences = [array rac_sequence];</span><br><span class="line">  <span class="keyword">id</span> mapData = [sequences map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">      <span class="keyword">return</span> @([value integerValue] * <span class="number">2</span>);</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"序列Map之后的数据:%@"</span>,[mapData array]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">id</span> filterData = [sequences filter:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">      <span class="keyword">return</span> [value integerValue]%<span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"序列Filter之后的数据:%@"</span>,[filterData array]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  RACSequence *flatmapData = [sequences flattenMap:^__kindof RACSequence * _Nullable(<span class="keyword">id</span>  _Nullable value) &#123;</span><br><span class="line">       <span class="keyword">if</span> ([value integerValue]%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> [RACSequence sequenceWithHeadBlock:^<span class="keyword">id</span> _Nullable&#123;</span><br><span class="line">               <span class="keyword">return</span> value;</span><br><span class="line">           &#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">           &#125;];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> [RACSequence empty];</span><br><span class="line">   &#125;];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"先map再filter之后的数据:%@"</span>, flatmapData.eagerSequence);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">序列Map之后的数据:(</span></span><br><span class="line"><span class="comment">    4,</span></span><br><span class="line"><span class="comment">    10,</span></span><br><span class="line"><span class="comment">    14,</span></span><br><span class="line"><span class="comment">    30</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">序列Filter之后的数据:(</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> &lt;RACEagerSequence: 0x6040002241c0&gt;&#123; name = , array = (</span></span><br><span class="line"><span class="comment"> 2</span></span><br><span class="line"><span class="comment"> ) &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><ul><li>初始化<br>内部实际返回 RACDynamicSequence 对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSequence *)sequenceWithHeadBlock:(id (^)(void))headBlock tailBlock:(RACSequence&lt;id&gt; *(^)(void))tailBlock &#123;</span><br><span class="line">return [[RACDynamicSequence sequenceWithHeadBlock:headBlock tailBlock:tailBlock] setNameWithFormat:@&quot;+sequenceWithHeadBlock:tailBlock:&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文源码为 ReactiveObjc 3.1.0 版本&lt;/p&gt;
&lt;h2 id=&quot;RACSequence&quot;&gt;&lt;a href=&quot;#RACSequence&quot; class=&quot;headerlink&quot; title=&quot;RACSequence&quot;&gt;&lt;/a&gt;RACSequence&lt;/h2&gt;&lt;f
      
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="https://pattyxp.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveObjc入门</title>
    <link href="https://pattyxp.github.io/2018/03/12/ReactiveObjc%E5%85%A5%E9%97%A8/"/>
    <id>https://pattyxp.github.io/2018/03/12/ReactiveObjc入门/</id>
    <published>2018-03-12T09:40:55.000Z</published>
    <updated>2018-05-18T03:34:37.346Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文源码为 ReactiveObjc 3.1.0 版本</p><p>ReactiveCocoa 开源已久，实现非常高效，对应OC中各种不同的设计模式，如代理响应，观察者模式，通知等模式的输入，都可以抽象为信号，让组件对自己的行为进行控制，简化控制器的负担。<br>本文作为系列开篇，先介绍最核心的 信号流 RACStream</p><p>RACStream 属于抽象类，两个子类分别是 RACSignal 和 RACSequence<br><img src="/images/RACStream大概.png" alt="RAC-stream"></p><p>两者虽然都继承自RACStream,拥有父类的很多共同的特性，但是差异在于 推驱动 和 拉驱动的方式</p><ul><li>RACSignal : 推驱动， 每次当信号中出现新的数据，主动发送给所有的订阅者</li><li>RACSequence : 拉驱动，每次出现新的数据，并不会通知当前的订阅对象，而是当订阅者再次需要使用 RACSequence 对象才会去获取最新的数据，由使用者自己去拉取新数据</li></ul><p>本文先介绍 RACSignal 相关的信息</p><h2 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h2><p>RACStream作为抽象类，在实现内部抛出异常</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (__kindof RACStream *)empty &#123;</span><br><span class="line"><span class="built_in">NSString</span> *reason = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ must be overridden by subclasses"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd)];</span><br><span class="line"><span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInternalInconsistencyException</span> reason:reason userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (__kindof RACStream *)bind:(RACStreamBindBlock (^)(<span class="keyword">void</span>))block;</span><br><span class="line">+ (__kindof RACStream *)<span class="keyword">return</span>:(<span class="keyword">id</span>)value;</span><br><span class="line">- (__kindof RACStream *)concat:(RACStream *)stream;</span><br><span class="line">- (__kindof RACStream *)zipWith:(RACStream *)stream;</span><br></pre></td></tr></table></figure><p>RACStream 需要子类实现这些方法，否则抛出异常<br>RACStream的分类Operations，定义了许多方法，只要子类实现以上的抽象方法，这些分类方法都能使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">id</span> stream = block(value) ?: [<span class="keyword">class</span> empty];</span><br><span class="line"><span class="built_in">NSCAssert</span>([stream isKindOfClass:RACStream.class], <span class="string">@"Value returned from -flattenMap: is not a stream: %@"</span>, stream);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> stream;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -flattenMap:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (__kindof RACStream *)flatten</span><br><span class="line">- (__kindof RACStream *)map:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> value))block</span><br><span class="line">- (__kindof RACStream *)mapReplace:(<span class="keyword">id</span>)object</span><br><span class="line">- (__kindof RACStream *)combinePreviousWithStart:(<span class="keyword">id</span>)start reduce:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> previous, <span class="keyword">id</span> next))reduceBlock</span><br><span class="line">- (__kindof RACStream *)filter:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> value))block</span><br><span class="line">- (__kindof RACStream *)ignore:(<span class="keyword">id</span>)value</span><br><span class="line">- (__kindof RACStream *)reduceEach:(RACReduceBlock)reduceBlock</span><br><span class="line">- (__kindof RACStream *)startWith:(<span class="keyword">id</span>)value</span><br><span class="line">- (__kindof RACStream *)skip:(<span class="built_in">NSUInteger</span>)skipCount</span><br><span class="line">- (__kindof RACStream *)take:(<span class="built_in">NSUInteger</span>)count</span><br><span class="line">+ (__kindof RACStream *)join:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)streams block:(RACStream * (^)(<span class="keyword">id</span>, <span class="keyword">id</span>))block</span><br><span class="line">+ (__kindof RACStream *)zip:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)streams</span><br><span class="line">+ (__kindof RACStream *)zip:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)streams reduce:(RACGenericReduceBlock)reduceBlock</span><br><span class="line">+ (__kindof RACStream *)concat:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)streams</span><br><span class="line">- (__kindof RACStream *)scanWithStart:(<span class="keyword">id</span>)startingValue reduce:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> running, <span class="keyword">id</span> next))reduceBlock</span><br><span class="line">- (__kindof RACStream *)scanWithStart:(<span class="keyword">id</span>)startingValue reduceWithIndex:(<span class="keyword">id</span> (^)(<span class="keyword">id</span>, <span class="keyword">id</span>, <span class="built_in">NSUInteger</span>))reduceBlock</span><br><span class="line">- (__kindof RACStream *)takeUntilBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate</span><br><span class="line">- (__kindof RACStream *)takeWhileBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate</span><br><span class="line">- (__kindof RACStream *)skipUntilBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate</span><br><span class="line">- (__kindof RACStream *)skipWhileBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate</span><br><span class="line">- (__kindof RACStream *)distinctUntilChanged</span><br></pre></td></tr></table></figure><p>RACSignal继承自RACStream<br>下面简单介绍部分常用的方法，在 RACSignal (RACStream)</p><ul><li>return<br>通过传入NSObject类型的value,返回RACSignal对象，完成了UIKit -&gt; ReactiveCocoa<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)<span class="keyword">return</span>:(<span class="keyword">id</span>)value &#123;</span><br><span class="line"><span class="keyword">return</span> [RACReturnSignal <span class="keyword">return</span>:value];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>RACSignal是一个类簇，return 方法虽然返回的是 RACSignal 但是内部实际返回 RACReturnSignal<br>同样的在创建实例时，可能会返回 RACDynamicSignal、RACEmptySignal、RACErrorSignal 和 RACReturnSignal 对象<br>如return方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACReturnSignal.m</span><br><span class="line">+ (RACSignal *)<span class="keyword">return</span>:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">RACReturnSignal *signal = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">signal-&gt;_value = value;</span><br><span class="line"></span><br><span class="line"><span class="meta">#ifdef DEBUG</span></span><br><span class="line">[signal setNameWithFormat:<span class="string">@"+return: %@"</span>, value];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="keyword">return</span> signal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面结合实例讲解下信号订阅的过程<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposble * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"signal %@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><ul><li><p>createSignal 创建信号<br>createSignal 实际返回RACDynamicSignal对象，将block存储在唯一的属性_didSubscribe上</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)createSignal:(RACDisposble * (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line">RACDynamicSignal *signal = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">signal-&gt;_didSubscribe = [didSubscribe <span class="keyword">copy</span>];</span><br><span class="line"><span class="keyword">return</span> [signal setNameWithFormat:<span class="string">@"+createSignal:"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>subscribeNext<br>信号创建之后，调用subscribeNext 返回RACDisposble ，还生成一个 RACSubscriber 对象，向这个对象发送消息 -sendNext: 时，就向所有的订阅者发送消息。</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposble *)subscribeNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))nextBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(nextBlock != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:<span class="literal">NULL</span> completed:<span class="literal">NULL</span>];</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>创建RACSubscriber 消息的订阅者</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)subscriberWithNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))next error:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *error))error completed:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completed &#123;</span><br><span class="line">RACSubscriber *subscriber = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line"></span><br><span class="line">subscriber-&gt;_next = [next <span class="keyword">copy</span>];</span><br><span class="line">subscriber-&gt;_error = [error <span class="keyword">copy</span>];</span><br><span class="line">subscriber-&gt;_completed = [completed <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>subscribe<br>创建的RACSubscriber实例需要订阅,subscribe:方法需要被RACSignal的子类实现，如 RACDynamicSignal</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">RACSignal.m</span><br><span class="line">- (RACDisposble *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"><span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"This method must be overridden by subclasses"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RACDynamicSignal.m</span><br><span class="line">- (RACDisposble *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(subscriber != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将subscriber，signal，disposable绑定</span></span><br><span class="line">subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="keyword">self</span> disposable:disposable];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.didSubscribe != <span class="literal">NULL</span>) &#123; <span class="comment">//self.didSubscribe是初始化RACSignal时候赋值block</span></span><br><span class="line">RACDisposble *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">      <span class="comment">//schedule即执行block()，也就是下面的内容</span></span><br><span class="line">RACDisposble *innerDisposable = <span class="keyword">self</span>.didSubscribe(subscriber);<span class="comment">//将订阅者传进去执行结果</span></span><br><span class="line">[disposable addDisposable:innerDisposable];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:schedulingDisposable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>subscribe方法作用:<br>1.创建RACCompoundDisposable<br>2.创建RACPassthroughSubscriber 一个私有的类，只有一个实例初始化方法，内部分别持有属性innerSubscriber消息的订阅者，signal信号，disposable订阅者的销毁对象,遵循RACSubscriber协议，内部会执行sendNext，sendError，sendCompleted方法，实际会将消息转发给真正的订阅者innerSubscriber</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACPassthroughSubscriber</span> : <span class="title">NSObject</span> &lt;<span class="title">RACSubscriber</span>&gt;</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSubscriber:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber signal:(RACSignal *)signal disposable:(RACCompoundDisposable *)disposable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;RACSubscriber&gt; innerSubscriber;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">unsafe_unretained</span>, <span class="keyword">readonly</span>) RACSignal *signal;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACCompoundDisposable *disposable;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">self</span>.innerSubscriber sendNext:value];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>3.RACScheduler.subscriptionScheduler是一个全局的变量<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (RACScheduler *)subscriptionScheduler &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="keyword">static</span> RACScheduler *subscriptionScheduler;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">subscriptionScheduler = [[RACSubscriptionScheduler alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> subscriptionScheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建RACDynamicSignal的时候，存储了didSubscribe，接着执行 schedule 的block方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RACScheduler.currentScheduler == <span class="literal">nil</span>) <span class="keyword">return</span> [<span class="keyword">self</span>.backgroundScheduler schedule:block];</span><br><span class="line"></span><br><span class="line">block();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着执行block()也就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RACDisposble *innerDisposable = self.didSubscribe(subscriber);//将订阅者传进去执行结果</span><br><span class="line">[disposable addDisposable:innerDisposable];</span><br></pre></td></tr></table></figure></p><ul><li><p>调用self.didSubscribe(subscriber)对订阅者发送消息，执行了闭包block<br><code>[subscriber sendNext:@4];</code></p></li><li><p>sendNext</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark RACSubscriber</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">void</span> (^nextBlock)(<span class="keyword">id</span>) = [<span class="keyword">self</span>.next <span class="keyword">copy</span>];</span><br><span class="line"><span class="keyword">if</span> (nextBlock == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">nextBlock(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>sendNext操作，就是将subscribeNext初始化传进来的block进行copy,然后调用参数执行block,所以将参数x传递进来<br>执行下面这句话<br><code>NSLog(@&quot;signal %@&quot;,x);</code><br>忽略Error和RACDisposble，至此一个信号的创建和订阅完毕</p><h3 id="RACSignal-使用原理"><a href="#RACSignal-使用原理" class="headerlink" title="RACSignal 使用原理"></a>RACSignal 使用原理</h3><p>先订阅，然后发送信息，订阅者接收到消息<br>创建信号-&gt;subscribeNext -&gt;产生Subscriber-&gt; 执行信号创建时候存储的block-&gt; sendNext -&gt; subscriber接收消息</p><ul><li>RACSignal调用subscribeNext方法，新建一个RACSubscriber。</li><li>新建的RACSubscriber会copy，nextBlock，errorBlock，completedBlock存在自己的属性变量中。</li><li>RACSignal的子类RACDynamicSignal调用subscribe方法。</li><li>新建RACCompoundDisposable和RACPassthroughSubscriber对象。RACPassthroughSubscriber分别保存对RACSignal/RACSubscriber/RACCompoundDisposable的引用，注意对RACSignal的引用是unsafe_unretained的。</li><li>RACDynamicSignal调用didSubscribe闭包。先调用RACPassthroughSubscriber的相应的sendNext/sendError/sendCompleted方法。</li><li>RACPassthroughSubscriber再去调用self.innerSubscriber，即RACSubscriber的nextBlock/errorBlock/completedBlock。注意这里调用同样是先copy一份，再调用闭包执行。</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>将原来的RACSignal通过传入的block，生成新的RACSignal</p><p>bind方法比较看着长，但是内部实现可以理解为，将RACSignal进行解包出NSObject，然后将NSObject传入RACSignalBindBlock，生成新的 RACSignal 返回<br>如果不考虑RACDisposble和error，可以将bind简化<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">            <span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line">            [bindingBlock(x, &amp;stop) subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">                [subscriber sendNext:x];</span><br><span class="line">            &#125;];</span><br><span class="line">       &#125;];</span><br><span class="line">    &#125;]setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面结合实例讲解下bind的使用<br>为了方便讲解，下面将block方法进行编码进行源码解析<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposble * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line"> <span class="comment">//block1</span></span><br><span class="line">    [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *blockSignal = [signal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line"><span class="comment">//block2</span></span><br><span class="line">    <span class="keyword">return</span>  ^(<span class="built_in">NSNumber</span> *value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="comment">//block3</span></span><br><span class="line">        value = @(value.integerValue * value.integerValue);</span><br><span class="line">        <span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:value];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[blockSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line"><span class="comment">//block4</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"blockSignal %@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    <span class="comment">//block5</span></span><br><span class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line">        <span class="comment">//block6</span></span><br><span class="line">        __block <span class="keyword">volatile</span> int32_t signalCount = <span class="number">1</span>;   <span class="comment">// indicates self</span></span><br><span class="line"></span><br><span class="line">        RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (^completeSignal)(RACDisposable *) = ^(RACDisposable *finishedDisposable) &#123;</span><br><span class="line">            <span class="comment">//block7</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (^addSignal)(RACSignal *) = ^(RACSignal *signal) &#123;</span><br><span class="line">            <span class="comment">//block8</span></span><br><span class="line">            RACDisposable *disposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">            <span class="comment">//block 9</span></span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">            [compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">            RACDisposable *bindingDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// block 10</span></span><br><span class="line">                <span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line">                <span class="keyword">id</span> signal = bindingBlock(x, &amp;stop);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (signal != <span class="literal">nil</span>) addSignal(signal);</span><br><span class="line">                    <span class="keyword">if</span> (signal == <span class="literal">nil</span> || stop) &#123;</span><br><span class="line">                        [selfDisposable dispose];</span><br><span class="line">                        completeSignal(selfDisposable);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                [compoundDisposable dispose];</span><br><span class="line">                [subscriber sendError:error];</span><br><span class="line">            &#125; completed:^&#123;</span><br><span class="line">                <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                    completeSignal(selfDisposable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line"></span><br><span class="line">            selfDisposable.disposable = bindingDisposable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> compoundDisposable;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//RACSignalBindBlock:接受 NSObject 对象返回 RACSignal 对象<br><code>typedef RACSignal * _Nullable (^RACSignalBindBlock)(ValueType _Nullable value, BOOL *stop);</code></p><p>1.首先，根据RACSignal的创建方法，didSubscribe先保存block1 进行copy<br>2.调用bind方法，先执行bind5<br>3.创建新信号，didSubscribe将block6 进行copy<br>4.执行bindSignal的sunscribeNext方法，也就执行self.didSubscribe(subscriber),执行block6<br>5.block6内第一步先执行 <code>RACSignalBindBlock bindingBlock = block();</code> ，也就是执行block2,返回RACSignalBindBlock<br>6.执行<code>[self subscribeNext:{...}]</code> 此处self是bind方法的调用者即signal，于是订阅signal发出的信号,执行subscribe,执行signal信号的didSubscribe，于是此处执行block1<br>7.block1调用sendNext，于是执行subscriber的nextBlock，此处执行block10<br>8.block10中会先调用bindingBlock，这个是之前调用block2的返回值，这个RACStreamBindBlock对象里面保存的是block3,所以开始调用block3<br>9.block3 的入参，是signal中sendNext中发出来的value的值，这里对value进行操作变化，返回新的信号signal’<br>10.如果返回的signal’为空，则会调用completeSignal，即调用block7。block7中会发送sendCompleted。如果返回的signal’不为空，则会调用addSignal，即调用block8。block8内，对入参新信号signal’进行订阅。signal’是bind函数的返回值，实际调用<code>[RACSignal return:value];</code>返回的是 RACReturnSignal，当subscribeNext新信号，立即就会执行block，发出sendNext，执行block9<br>11.block9内部执行<code>[subscriber sendNext:x];</code>此处的subscriber是bind方法的入参，也就是新的bindSignal的订阅者，执行sendNext操作会执行bindSignal的nextBlock即block4<br>12.block9 中执行完sendNext，还会调用sendCompleted,completeSignal(signal, selfDisposable)执行completeSignal，即block7。<br>13.执行完block7，就完成了一次从signal 发送信号sendNext的全过程。</p><p>以上流程就是bind方法的全部执行过程</p><p>打印输出<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blockSignal <span class="number">1</span></span><br><span class="line">blockSignal <span class="number">4</span></span><br><span class="line">blockSignal <span class="number">9</span></span><br><span class="line">blockSignal <span class="number">16</span></span><br></pre></td></tr></table></figure></p><p>整个过程大致如下:</p><ul><li>订阅原信号中的值；</li><li>将原信号发出的值传入 RACSignalBindBlock 进行转换；</li><li>如果 RACSignalBindBlock 返回一个信号，就会订阅该信号并将信号中的所有值传给订阅者 subscriber；</li><li>如果 RACSignalBindBlock 请求终止信号就会向原信号发出 -sendCompleted 消息；</li><li>当所有信号都完成时，会向订阅者发送 -sendCompleted；</li><li>无论何时，如果信号发出错误，都会向订阅者发送 -sendError: 消息。</li></ul><p>信号的订阅发送，可以按需定制<br><img src="/images/RAC-发送订阅.png" alt="RAC-发送订阅"></p><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>事例<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:</span><br><span class="line">                         ^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//block1</span></span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"signal dispose"</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signal2 = [RACSignal createSignal:</span><br><span class="line"> ^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//block2</span></span><br><span class="line">[subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">[subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"signals dispose"</span>);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">    RACSignal *concatSignal = [signal1 concat:signal2];</span><br><span class="line"></span><br><span class="line">    [concatSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="comment">//block3</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p><p>下面看下concat内部操作<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)concat:(RACSignal *)signal &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACCompoundDisposable *compoundDisposable = [[RACCompoundDisposable alloc] init];</span><br><span class="line"><span class="comment">//block4</span></span><br><span class="line"></span><br><span class="line">RACDisposable *sourceDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="comment">//block5</span></span><br><span class="line">[subscriber sendNext:x]; <span class="comment">//收到signal1的信号</span></span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="comment">//block6</span></span><br><span class="line">RACDisposable *concattedDisposable = [signal subscribe:subscriber];</span><br><span class="line"><span class="comment">//signal2调用subscribe</span></span><br><span class="line">  <span class="comment">//内部执行`self.didSubscribe(subscriber)`</span></span><br><span class="line">[compoundDisposable addDisposable:concattedDisposable];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[compoundDisposable addDisposable:sourceDisposable];</span><br><span class="line"><span class="keyword">return</span> compoundDisposable;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -concat: %@"</span>, <span class="keyword">self</span>.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>内部调用createSignal产生新的信号concatSignal<br>signal1和signal2分别将各种的block存储在didSubscriber<br>concatSignal将block也存储在didSubscriber<br>1.首先concatSignal执行 <code>subscribeNext</code>，执行concatSignal的didSubscribe，于是执行block4<br>2.block4内部执行<code>self subscribeNext</code>此处self是方法调用者signal1,于是调用signal1的didSubscribe，signal1执行<code>sendNext</code>，然后执行nextBlock也就是block5<code>[subscriber sendNext:x];</code>，执行block3<br>3.当signal1调用sendCompleted，执行block6 调用 <code>[signal subscribe:subscriber];</code> 此处signal实际是signal2<br>4.执行signal2的 didsubscribe ，于是调用block2，内部执行<code>[subscriber sendNext:@2];</code>此处的subscriber是入参，也就是concatSignal的订阅者，所以再次调用block3直到sendCompleted或者sendError</p><p>注:<br>concat是有序的组合，第一个信号完成之后才发送第二个信号</p><p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-03-24 11:20:28.468644+0800 ReactiveObjcTest[83027:1136301] value = 1</span><br><span class="line">2018-03-24 11:25:14.451727+0800 ReactiveObjcTest[83027:1136301] value = 2</span><br><span class="line">2018-03-24 11:25:15.716178+0800 ReactiveObjcTest[83027:1136301] value = 3</span><br><span class="line">2018-03-24 11:25:15.716384+0800 ReactiveObjcTest[83027:1136301] signals dispose</span><br><span class="line">2018-03-24 11:25:15.716775+0800 ReactiveObjcTest[83027:1136301] signal dispose</span><br></pre></td></tr></table></figure></p><h3 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h3><p>将上面例子代码修改方法为<code>zipwith</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *concatSignal = [signal1 zipWith:signal2];</span><br><span class="line"></span><br><span class="line">[concatSignal subscribeNext:^(id x) &#123;</span><br><span class="line">NSLog(@&quot;value = %@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>zipwith源码分析<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)zipWith:(RACSignal *)signal &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">__block <span class="built_in">BOOL</span> selfCompleted = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *selfValues = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">__block <span class="built_in">BOOL</span> otherCompleted = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *otherValues = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^sendCompletedIfNecessary)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line"><span class="built_in">BOOL</span> selfEmpty = (selfCompleted &amp;&amp; selfValues.count == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">BOOL</span> otherEmpty = (otherCompleted &amp;&amp; otherValues.count == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 如果任意一个信号完成并且数组里面空了，就整个信号算完成</span></span><br><span class="line"><span class="keyword">if</span> (selfEmpty || otherEmpty) [subscriber sendCompleted];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^sendNext)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line"><span class="keyword">if</span> (selfValues.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (otherValues.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据进行拼接 然后移除</span></span><br><span class="line">RACTuple *tuple = RACTuplePack(selfValues[<span class="number">0</span>], otherValues[<span class="number">0</span>]);</span><br><span class="line">[selfValues removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">[otherValues removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="comment">//将拼接的数据进行发送</span></span><br><span class="line">[subscriber sendNext:tuple];</span><br><span class="line">sendCompletedIfNecessary();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅第一个信号</span></span><br><span class="line">RACDisposable *selfDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">[selfValues addObject:x ?: RACTupleNil.tupleNil];</span><br><span class="line">sendNext(); <span class="comment">//将值发送出去</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">selfCompleted = <span class="literal">YES</span>;</span><br><span class="line">sendCompletedIfNecessary();</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅第二个信号</span></span><br><span class="line">RACDisposable *otherDisposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">[otherValues addObject:x ?: RACTupleNil.tupleNil];</span><br><span class="line">sendNext(); <span class="comment">//将值发送出去</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">otherCompleted = <span class="literal">YES</span>;</span><br><span class="line">sendCompletedIfNecessary();</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[selfDisposable dispose];</span><br><span class="line">[otherDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -zipWith: %@"</span>, <span class="keyword">self</span>.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>zipWith里面有两个数组，分别会存储两个信号的值。</p><p>先执行第一个信号的didsubscribe,signal1执行<code>sendNext</code>,订阅之后将value装入selfValues，然后发送出去，<br>在 sendNext block中，会执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (selfValues.count == 0) return;</span><br><span class="line">if (otherValues.count == 0) return;</span><br></pre></td></tr></table></figure></p><p>此时otherValues为空，return，不会将消息发送出去<br>当第二个信号的值紧接着发出来了，第二个信号每发送一次值，也会存储到第二个数组中，然后再调用sendNext()，不会再return了，因为两个数组里面都有值了，两个数组的第0号位置都有一个值了,然后打包成元组RACTuple发送出去。并清空两个数组0号位置存储的值。<br>然后判断是否发送完成，如果任一信号完成且数组的内容为空，则订阅完成</p><p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-03-24 11:54:04.033897+0800 ReactiveObjcTest[83279:1168707] value = &lt;RACTwoTuple: 0x604000010f00&gt; (</span><br><span class="line">    1,</span><br><span class="line">    2</span><br><span class="line">)</span><br><span class="line">2018-03-24 11:54:06.402037+0800 ReactiveObjcTest[83279:1168707] signals dispose</span><br></pre></td></tr></table></figure></p><p>注:<br>如果value为空，会被拼接为<code>RACTupleNil.tupleNil</code></p><h2 id="RACDisposble-信号的清理"><a href="#RACDisposble-信号的清理" class="headerlink" title="RACDisposble 信号的清理"></a>RACDisposble 信号的清理</h2><p>在创建信号的时候，会返回一个 RACDisposble ，用于在订阅结束进行必要的清理</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACDisposable</span> () </span>&#123;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">volatile</span> _disposeBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACDisposable 最核心的就是 <code>_disposeBlock</code> ，内部的方法都是围绕它进行处理</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)disposableWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_disposeBlock = (<span class="keyword">void</span> *)<span class="built_in">CFBridgingRetain</span>([block <span class="keyword">copy</span>]);</span><br><span class="line">OSMemoryBarrier();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_disposeBlock = (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>;</span><br><span class="line">OSMemoryBarrier();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>void (^)(void)类型的block作为参数传入，会转化为CoreFoundation中的类型，赋值disposeBlock</p><p>下面是相关主要的子类RACSerialDisposable 和 RACCompoundDisposable</p><ul><li><p>RACSerialDisposable<br>线程安全，使用 pthread_mutex_t 保证<br>保证只含有一个RACDisposble</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  - (<span class="built_in">BOOL</span>)isDisposed &#123;</span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">BOOL</span> disposed = _disposed;</span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> disposed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RACCompoundDisposable<br>管理多个 RACDisposable 对象的释放</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACCompoundDisposable</span> () </span>&#123;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t _mutex;</span><br><span class="line">RACDisposable *_inlineDisposables[RACCompoundDisposableInlineCount];</span><br><span class="line"><span class="built_in">CFMutableArrayRef</span> _disposables;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDisposables:(<span class="built_in">NSArray</span> *)otherDisposables &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">self</span> init];</span><br><span class="line"></span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line">[otherDisposables enumerateObjectsUsingBlock:^(RACDisposable *disposable, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">self</span>-&gt;_inlineDisposables[index] = disposable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop after this iteration if we've reached the end of the inlined</span></span><br><span class="line"><span class="comment">// array.</span></span><br><span class="line"><span class="keyword">if</span> (index == RACCompoundDisposableInlineCount - <span class="number">1</span>) *stop = <span class="literal">YES</span>;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (otherDisposables.count &gt; RACCompoundDisposableInlineCount) &#123;</span><br><span class="line">_disposables = RACCreateDisposablesArray();</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRange</span> range = <span class="built_in">CFRangeMake</span>(RACCompoundDisposableInlineCount, (<span class="built_in">CFIndex</span>)otherDisposables.count - RACCompoundDisposableInlineCount);</span><br><span class="line"><span class="built_in">CFArrayAppendArray</span>(_disposables, (__bridge <span class="built_in">CFArrayRef</span>)otherDisposables, range);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对象持有的 RACDisposable 不超过 RACCompoundDisposableInlineCount(2) 时，都会存储在 <code>_inlineDisposables</code> 数组中，而更多的实例都会存储在 <code>_disposables</code> 中：</p><p>值得注意的还有一个 addDisposable 方法<br>方法线程安全，如果_inlineDisposables数组内没有存满，先优先存储在inlineDisposbles数组，如果存满，往_disposables拼接数据<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDisposable:(RACDisposable *)disposable &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(disposable != <span class="keyword">self</span>);</span><br><span class="line"><span class="keyword">if</span> (disposable == <span class="literal">nil</span> || disposable.disposed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> shouldDispose = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_disposed) &#123;</span><br><span class="line">shouldDispose = <span class="literal">YES</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; RACCompoundDisposableInlineCount; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (_inlineDisposables[i] == <span class="literal">nil</span>) &#123;</span><br><span class="line">_inlineDisposables[i] = disposable;</span><br><span class="line"><span class="keyword">goto</span> foundSlot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_disposables == <span class="literal">NULL</span>) _disposables = RACCreateDisposablesArray();</span><br><span class="line"><span class="built_in">CFArrayAppendValue</span>(_disposables, (__bridge <span class="keyword">void</span> *)disposable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RACCOMPOUNDDISPOSABLE_ADDED_ENABLED()) &#123;</span><br><span class="line">RACCOMPOUNDDISPOSABLE_ADDED(<span class="keyword">self</span>.description.UTF8String, disposable.description.UTF8String, <span class="built_in">CFArrayGetCount</span>(_disposables) + RACCompoundDisposableInlineCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line">foundSlot:;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shouldDispose) [disposable dispose];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="订阅的销毁"><a href="#订阅的销毁" class="headerlink" title="订阅的销毁"></a>订阅的销毁</h2><p>在了解了相关RACDisposble之后，再来看下bind方法中关于这方面发处理,以下是缩略版<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line"></span><br><span class="line">        __block <span class="keyword">volatile</span> int32_t signalCount = <span class="number">1</span>;   <span class="comment">// indicates self</span></span><br><span class="line"></span><br><span class="line">        RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (^completeSignal)(RACDisposable *) = ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (^addSignal)(RACSignal *) = ...</span><br><span class="line"></span><br><span class="line">        RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">        [compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">        RACDisposable *bindingDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (compoundDisposable.disposed) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">id</span> signal = bindingBlock(x, &amp;stop);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (signal != <span class="literal">nil</span>) addSignal(signal);</span><br><span class="line">            <span class="keyword">if</span> (signal == <span class="literal">nil</span> || stop) &#123;</span><br><span class="line">                [selfDisposable dispose];</span><br><span class="line">                completeSignal(selfDisposable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125; completed:^&#123;</span><br><span class="line">            completeSignal(selfDisposable);</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        selfDisposable.disposable = bindingDisposable;</span><br><span class="line">        <span class="keyword">return</span> compoundDisposable;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简化后，可以观察到，信号的清理交给了 RACCompoundDisposable 实例，向 RACCompoundDisposable添加了 RACSerialDisposable ，将信号订阅后返回的 RACDisposable 交给了 RACSerialDisposable</p><p>completeSignal 和  addSignal 负责新信号创建之后的清理<br>当订阅新信号，产生的 RACSerialDisposable 添加进 RACCompoundDisposable 实例<br>当信号完成，compoundDisposable进行清理工作</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^completeSignal)(RACDisposable *) = ^(RACDisposable *finishedDisposable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (OSAtomicDecrement32Barrier(&amp;signalCount) == <span class="number">0</span>) &#123;</span><br><span class="line">      [subscriber sendCompleted];</span><br><span class="line">      [compoundDisposable dispose];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      [compoundDisposable removeDisposable:finishedDisposable];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (^addSignal)(RACSignal *) = ^(RACSignal *signal) &#123;</span><br><span class="line">    OSAtomicIncrement32Barrier(&amp;signalCount);</span><br><span class="line"></span><br><span class="line">    RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">    [compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">    RACDisposable *disposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">      [subscriber sendNext:x];</span><br><span class="line">    &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">      [compoundDisposable dispose];</span><br><span class="line">      [subscriber sendError:error];</span><br><span class="line">    &#125; completed:^&#123;</span><br><span class="line">      <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        completeSignal(selfDisposable);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    selfDisposable.disposable = disposable;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="举栗子"><a href="#举栗子" class="headerlink" title="举栗子"></a>举栗子</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Origin Signal Dispose"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *blockSignal = [signal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">    <span class="keyword">return</span>  ^(<span class="built_in">NSNumber</span> *value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        value = @(value.integerValue * value.integerValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;value.integerValue; i++) &#123;</span><br><span class="line">                [subscriber sendNext:value];</span><br><span class="line">            &#125;</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"Binding Signal Dispose"</span>);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[blockSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"signal %@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">打印log</span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] signal <span class="number">1</span></span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] Binding Signal Dispose</span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] signal <span class="number">4</span></span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] signal <span class="number">4</span></span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] signal <span class="number">4</span></span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] signal <span class="number">4</span></span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] Binding Signal Dispose</span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] Origin Signal Dispose</span><br></pre></td></tr></table></figure><h2 id="RACStream-相关的方法"><a href="#RACStream-相关的方法" class="headerlink" title="RACStream 相关的方法"></a>RACStream 相关的方法</h2><ul><li>Map  一般用来信号变换</li></ul><p>事例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">//block1</span><br><span class="line"> [subscriber sendNext:@1];</span><br><span class="line"> [subscriber sendCompleted];</span><br><span class="line"> return nil;</span><br><span class="line"> &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *mapSignal = [signal1 map:^id _Nullable(id  _Nullable value) &#123;</span><br><span class="line">//block2</span><br><span class="line"> return @([value integerValue] * 10);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[mapSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">//block3</span><br><span class="line">  NSLog(@&quot;value = %@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>map 源码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)map:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"><span class="comment">//block4</span></span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^(<span class="keyword">id</span> value) &#123;</span><br><span class="line"><span class="comment">// block5</span></span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:block(value)];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -map:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>self.class 实际返回signal的class，signal是RACDynamicSignal类型<br>map方法内部实际调用<code>flattenMap</code>方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"><span class="comment">//block6</span></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line"><span class="comment">//block7</span></span><br><span class="line"><span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="comment">//block8</span></span><br><span class="line"><span class="keyword">id</span> stream = block(value) ?: [<span class="keyword">class</span> empty];</span><br><span class="line"><span class="built_in">NSCAssert</span>([stream isKindOfClass:RACStream.class], <span class="string">@"Value returned from -flattenMap: is not a stream: %@"</span>, stream);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> stream;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -flattenMap:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flattenMap 内部调用的bind方法</p><ul><li>signal1创建，将block存入didSubscribe</li><li>执行map方法，此处先执行 block4, block内部调用 flattenMap 方法，于是执行 block6</li><li>block6 内部执行bind方法，于是创建新的信号作为返回结果 mapSignal</li><li>bind方法内部执行<code>RACSignalBindBlock bindingBlock = block();</code> 也就是将 block7 进行储存</li><li>然后调用bind方法内部的<code>[self subscribeNext:]</code>，对self进行订阅，self是map方法的调用者，也就是signal1，执行signal1的didSubscribe，</li><li>signal1调用<code>sendNext</code>执行，然后执行 bind方法内部<code>id signal = bindingBlock(x, &amp;stop);</code>，也就是执行bind方法的入参闭包，此处执行block7</li><li>接着执行block8,执行<code>id stream = block(value) ?: [class empty];</code> 此处执行block(value)，也就是flattenMap方法的入参闭包也就是block5</li><li>block5执行<code>return [class return:block(value)];</code>此处的block闭包是执行map方法的block闭包，也就是block2<br><code>[class return:value]</code>内部返回 RACReturnSignal ，当返回结果有值，则返回，否则返回<code>[class empty]</code>，也就是RACEmptySignal</li><li>返回信号不为nil，执行bind方法内部的<code>[signal subscribeNext:]</code> 对返回的信号进行订阅，由于返回的信号是RACReturnSignal类型，订阅之后直接调用subscribe方法执行sendNext，也就是订阅到执行block3</li></ul><p>map 就是将信号的值进行变换产生新的信号，将变换后的值进行发送出去，让调用者接收到新值</p><p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-03-24 15:42:28.407001+0800 ReactiveObjcTest[96645:1260165] value = 10</span><br></pre></td></tr></table></figure></p><ul><li>mapReplace<br>不管signal1 发送什么值，都替换成@“A”。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalB = [signal1 mapReplace:@&quot;A&quot;];</span><br></pre></td></tr></table></figure></li></ul><p>mapReplace 源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)mapReplace:(id)object &#123;</span><br><span class="line">    return [[self map:^(id _) &#123;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -mapReplace: %@&quot;, self.name, [object rac_description]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mapReplace 内部调用map方法，只是返回的是参数object 固定的</p><ul><li>reduceEach<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal2 = [signal1 reduceEach:^id(NSNumber *num1 , NSNumber *num2)&#123;</span><br><span class="line"> return @([num1 intValue] + [num2 intValue]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li></ul><p>reduceEach 源码分析<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)reduceEach:(<span class="keyword">id</span> (^)())reduceBlock &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(reduceBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    __<span class="keyword">weak</span> RACStream *stream __attribute__((unused)) = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> map:^(RACTuple *t) &#123;</span><br><span class="line">        <span class="built_in">NSCAssert</span>([t isKindOfClass:RACTuple.class], <span class="string">@"Value from stream %@ is not a tuple: %@"</span>, stream, t);</span><br><span class="line">        <span class="keyword">return</span> [RACBlockTrampoline invokeBlock:reduceBlock withArguments:t];</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -reduceEach:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处先断言入参block是否为空，然后弱引用当前对象self<br>内部调用map方法，内部断言入参是否是合法的</p><p>RACBlockTrampoline<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACBlockTrampoline</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="keyword">id</span> block;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBlock:(<span class="keyword">id</span>)block &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_block = [block <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)invokeBlock:(<span class="keyword">id</span>)block withArguments:(RACTuple *)arguments &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">RACBlockTrampoline *trampoline = [[<span class="keyword">self</span> alloc] initWithBlock:block];</span><br><span class="line"><span class="keyword">return</span> [trampoline invokeWithArguments:arguments];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)invokeWithArguments:(RACTuple *)arguments &#123;</span><br><span class="line">SEL selector = [<span class="keyword">self</span> selectorForArgumentCount:arguments.count];</span><br><span class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:[<span class="keyword">self</span> methodSignatureForSelector:selector]];</span><br><span class="line">invocation.selector = selector;</span><br><span class="line">invocation.target = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; arguments.count; i++) &#123;</span><br><span class="line"><span class="keyword">id</span> arg = arguments[i];</span><br><span class="line"><span class="built_in">NSInteger</span> argIndex = (<span class="built_in">NSInteger</span>)(i + <span class="number">2</span>);</span><br><span class="line">[invocation setArgument:&amp;arg atIndex:argIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[invocation invoke];</span><br><span class="line"></span><br><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> returnVal;</span><br><span class="line">[invocation getReturnValue:&amp;returnVal];</span><br><span class="line"><span class="keyword">return</span> returnVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>内部持有 block，初始化的时候是给block赋值，动态的构造一个NSInvocation并执行<br>将结果进行返回，也是map闭包里面的返回值</p><p>事例<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        RACTuple *tuple = [RACTuple tupleWithObjects:<span class="string">@"1"</span>,<span class="string">@"2"</span>, <span class="literal">nil</span>];</span><br><span class="line">        [subscriber sendNext:tuple];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signal2 = [signal1 reduceEach:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *num1 , <span class="built_in">NSNumber</span> *num2)&#123;</span><br><span class="line">      <span class="keyword">return</span> @([num1 intValue] + [num2 intValue]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal2 subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"value %@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>reduceEach 内部还是调用 map 方法,当signal1的发出的值包裹的数据是RACTuple类型时，才可以使用该操作,入参是block，参数可以任意</p><p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-03-24 16:24:39.880757+0800 ReactiveObjcTest[97285:1354826] value 3</span><br></pre></td></tr></table></figure></p><p>剩下的方法这里先不介绍了,可自行查阅<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">- (RACSignal *)not;</span><br><span class="line">- (RACSignal *)and;</span><br><span class="line">- (RACSignal *)or;</span><br><span class="line">- (RACSignal *)reduceApply;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，<em>系统总是重新从它所在的内存读取数据</em>，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a = i;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span></span><br><span class="line"><span class="keyword">int</span> b = i;</span><br></pre></td></tr></table></figure><p>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取<br>volatile 可以保证对特殊地址的稳定访问</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RACSignal 相关的类及代码较简洁，方法也不是很复杂，但是之前并没有深入学习，理解还是需要分析的。<br>结合实际事例，查看调用栈分析情况容易入手，<br>使用上看着也方便，但是内部创建了多个实例对象，信号、订阅者、信号清理机制等，弄清楚流程就简单了</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://github.com/Draveness/analyze/blob/master/contents/ReactiveObjC/RACSignal.md" target="_blank" rel="noopener">https://github.com/Draveness/analyze/blob/master/contents/ReactiveObjC/RACSignal.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文源码为 ReactiveObjc 3.1.0 版本&lt;/p&gt;
&lt;p&gt;ReactiveCocoa 开源已
      
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="https://pattyxp.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
</feed>
