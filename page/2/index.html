<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, Patty" />





  <link rel="alternate" href="/atom.xml" title="温暖的弦" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Life&apos;s like a movie, write your own ending, keep believing, keep pretending.">
<meta property="og:type" content="website">
<meta property="og:title" content="温暖的弦">
<meta property="og:url" content="https://pattyxp.github.io/page/2/index.html">
<meta property="og:site_name" content="温暖的弦">
<meta property="og:description" content="Life&apos;s like a movie, write your own ending, keep believing, keep pretending.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="温暖的弦">
<meta name="twitter:description" content="Life&apos;s like a movie, write your own ending, keep believing, keep pretending.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://pattyxp.github.io/page/2/"/>





  <title>温暖的弦</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">温暖的弦</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/02/12/Objc-protocol篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/12/Objc-protocol篇/" itemprop="url">Objc-protocol篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-12T11:28:59+08:00">
                2018-02-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@protocol DogProtocol</span><br><span class="line">@required</span><br><span class="line">- (void)printName;</span><br><span class="line">@optional</span><br><span class="line">- (void)printAge;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Dog: NSObject</span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@property (nonatomic) NSInteger age;</span><br><span class="line">@property (nonatomic, weak) id delegate;</span><br><span class="line">- (void)printDetails;</span><br><span class="line">@end</span><br><span class="line">@implementation Dog</span><br><span class="line">-(void)printDetails</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;I&apos;m Dog&quot;);</span><br><span class="line">    [self.delegate printName];</span><br><span class="line">    [self.delegate printAge];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface SampleClass:NSObject&lt;DogProtocol&gt;</span><br><span class="line">@property (nonatomic, strong) Dog *littleDog;</span><br><span class="line">- (void)startAction;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SampleClass</span><br><span class="line"></span><br><span class="line">- (void)startAction&#123;</span><br><span class="line">    Dog *dog = [[Dog alloc]init];</span><br><span class="line">    dog.name = @&quot;PattyDog&quot;;</span><br><span class="line">    dog.age = 10;</span><br><span class="line">    dog.delegate = self;</span><br><span class="line"></span><br><span class="line">    self.littleDog = dog;</span><br><span class="line">    [dog printDetails];</span><br><span class="line">&#125;</span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;name:%@&quot;,self.littleDog.name);</span><br><span class="line">&#125;</span><br><span class="line">- (void)printAge</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;age:%zd&quot;,self.littleDog.age);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark -main</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        SampleClass *sample = [[SampleClass alloc] init];</span><br><span class="line">        [sample startAction];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看控制台打印输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m Dog</span><br><span class="line">name:PattyDog</span><br><span class="line">age:10</span><br></pre></td></tr></table></figure></p>
<h2 id="protocol-t结构"><a href="#protocol-t结构" class="headerlink" title="protocol_t结构"></a>protocol_t结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct protocol_t : objc_object &#123;</span><br><span class="line">    const char *mangledName;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    method_list_t *instanceMethods;</span><br><span class="line">    method_list_t *classMethods;</span><br><span class="line">    method_list_t *optionalInstanceMethods;</span><br><span class="line">    method_list_t *optionalClassMethods;</span><br><span class="line">    property_list_t *instanceProperties;</span><br><span class="line">    uint32_t size;   // sizeof(protocol_t)</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    // Fields below this point are not always present on disk.</span><br><span class="line">    const char **_extendedMethodTypes;</span><br><span class="line">    const char *_demangledName;</span><br><span class="line">    property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    const char *demangledName();</span><br><span class="line"></span><br><span class="line">    const char *nameForLogging() &#123;</span><br><span class="line">        return demangledName();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="分别申明-required和-optional方法"><a href="#分别申明-required和-optional方法" class="headerlink" title="分别申明@required和@optional方法"></a>分别申明@required和@optional方法</h2><p>下面打印验证协议方法<br>打印方法类似之前文章中介绍消息缓存<br>现在查看SampleClass遵循的协议</p>
<p><img src="/images/protocol_t.png" alt="protocol_t结构证明"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">2018-02-13 09:51:09.129854+0800 debug-objc[26530:1205183] 0x100002610</span><br><span class="line">(lldb) p (objc_class *)0x100002610</span><br><span class="line">(objc_class *) $0 = 0x0000000100002610</span><br><span class="line">(lldb) p (class_data_bits_t *)0x0000000100002630</span><br><span class="line">(class_data_bits_t *) $1 = 0x0000000100002630</span><br><span class="line">(lldb) p (class_rw_t *)$1-&gt;data()</span><br><span class="line">(class_rw_t *) $2 = 0x0000000100a21a80</span><br><span class="line">(lldb) p $2-&gt;protocols</span><br><span class="line">(protocol_array_t) $3 = &#123;</span><br><span class="line">  list_array_tt&lt;unsigned long, protocol_list_t&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = 0x0000000100002370</span><br><span class="line">      arrayAndFlag = 4294976368</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $3.beginLists()</span><br><span class="line">(protocol_list_t **) $4 = 0x0000000100a21aa0</span><br><span class="line">(lldb) p **$4</span><br><span class="line">(protocol_list_t) $5 = (count = 1, list = protocol_ref_t [] @ 0x00007fbc7e780c58)</span><br><span class="line">(lldb) p $5.list[0]</span><br><span class="line">(protocol_ref_t) $6 = 4294977080</span><br><span class="line">(lldb) p (protocol_t *)$6</span><br><span class="line">(protocol_t *) $7 = 0x0000000100002638</span><br><span class="line">(lldb) p *$7</span><br><span class="line">(protocol_t) $8 = &#123;</span><br><span class="line">  objc_object = &#123;</span><br><span class="line">    isa = &#123;</span><br><span class="line">      cls = Protocol</span><br><span class="line">      bits = 4302295240</span><br><span class="line">       = &#123;</span><br><span class="line">        nonpointer = 0</span><br><span class="line">        has_assoc = 0</span><br><span class="line">        has_cxx_dtor = 0</span><br><span class="line">        shiftcls = 537786905</span><br><span class="line">        magic = 0</span><br><span class="line">        weakly_referenced = 0</span><br><span class="line">        deallocating = 0</span><br><span class="line">        has_sidetable_rc = 0</span><br><span class="line">        extra_rc = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mangledName = 0x0000000100001f5e &quot;DogProtocol&quot;   //证明协议名称</span><br><span class="line">  protocols = 0x0000000000000000</span><br><span class="line">  instanceMethods = 0x0000000100002320</span><br><span class="line">  classMethods = 0x0000000000000000</span><br><span class="line">  optionalInstanceMethods = 0x0000000100002340</span><br><span class="line">  optionalClassMethods = 0x0000000000000000</span><br><span class="line">  instanceProperties = 0x0000000000000000</span><br><span class="line">  size = 96</span><br><span class="line">  flags = 0</span><br><span class="line">  _extendedMethodTypes = 0x0000000100002360</span><br><span class="line">  _demangledName = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  _classProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $8.instanceMethods  //打印实例方法</span><br><span class="line">(method_list_t *) $9 = 0x0000000100002320</span><br><span class="line">(lldb) p $9-&gt;get(0)</span><br><span class="line">(method_t) $10 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $11 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 1</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从打印记录可以看到，SampleClass 含有的协议是”DogProtocol”<br>协议含有的实例方法列表 只有required方法<br>如果将DogProtocol协议中的@optional申明注释，打印协议里面的实例方法</p>
<h2 id="required申明方法"><a href="#required申明方法" class="headerlink" title="required申明方法"></a>required申明方法</h2><p>可以看到协议的实例方法列表含有两个方法,分别是printName和printAge，都是@required申明的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *$7</span><br><span class="line">(protocol_t) $8 = &#123;</span><br><span class="line">  objc_object = &#123;</span><br><span class="line">    isa = &#123;</span><br><span class="line">      cls = Protocol</span><br><span class="line">      bits = 4302295240</span><br><span class="line">       = &#123;</span><br><span class="line">        nonpointer = 0</span><br><span class="line">        has_assoc = 0</span><br><span class="line">        has_cxx_dtor = 0</span><br><span class="line">        shiftcls = 537786905</span><br><span class="line">        magic = 0</span><br><span class="line">        weakly_referenced = 0</span><br><span class="line">        deallocating = 0</span><br><span class="line">        has_sidetable_rc = 0</span><br><span class="line">        extra_rc = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mangledName = 0x0000000100001f5e &quot;DogProtocol&quot;</span><br><span class="line">  protocols = 0x0000000000000000</span><br><span class="line">  instanceMethods = 0x0000000100002320</span><br><span class="line">  classMethods = 0x0000000000000000</span><br><span class="line">  optionalInstanceMethods = 0x0000000000000000</span><br><span class="line">  optionalClassMethods = 0x0000000000000000</span><br><span class="line">  instanceProperties = 0x0000000000000000</span><br><span class="line">  size = 96</span><br><span class="line">  flags = 0</span><br><span class="line">  _extendedMethodTypes = 0x0000000100002358</span><br><span class="line">  _demangledName = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  _classProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $8.instanceMethods()</span><br><span class="line">error: called object type &apos;method_list_t *&apos; is not a function or function pointer</span><br><span class="line">(lldb) p $8.instanceMethods</span><br><span class="line">(method_list_t *) $9 = 0x0000000100002320</span><br><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $10 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 2</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(0)</span><br><span class="line">(method_t) $11 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10-&gt;get(1)</span><br><span class="line">(method_t) $12 = &#123;</span><br><span class="line">  name = &quot;printAge&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="默认不申明"><a href="#默认不申明" class="headerlink" title="默认不申明"></a>默认不申明</h2><p>打印说明默认的就是required<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $10 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 2</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(0)</span><br><span class="line">(method_t) $11 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(1)</span><br><span class="line">(method_t) $12 = &#123;</span><br><span class="line">  name = &quot;printAge&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="将方法都申明为optional"><a href="#将方法都申明为optional" class="headerlink" title="将方法都申明为optional"></a>将方法都申明为optional</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@protocol DogProtocol</span><br><span class="line">@optional</span><br><span class="line">- (void)printName;</span><br><span class="line">- (void)printAge;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>打印,可以看到协议的实例方法为空，但是optionalInstanceMethods有两个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)0x100002608</span><br><span class="line">(objc_class *) $0 = 0x0000000100002608</span><br><span class="line">(lldb) p (class_data_bits_t *)0x0000000100002628</span><br><span class="line">(class_data_bits_t *) $1 = 0x0000000100002628</span><br><span class="line">(lldb) p (class_rw_t *)$1-&gt;data()</span><br><span class="line">(class_rw_t *) $2 = 0x0000000100b909a0</span><br><span class="line">(lldb) p $2-&gt;protocols</span><br><span class="line">(protocol_array_t) $3 = &#123;</span><br><span class="line">  list_array_tt&lt;unsigned long, protocol_list_t&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = 0x0000000100002368</span><br><span class="line">      arrayAndFlag = 4294976360</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $3.beginLists()</span><br><span class="line">(protocol_list_t **) $4 = 0x0000000100b909c0</span><br><span class="line">(lldb) p $5.list[0]</span><br><span class="line">error: use of undeclared identifier &apos;$5&apos;</span><br><span class="line">(lldb) p **$4</span><br><span class="line">(protocol_list_t) $5 = (count = 1, list = protocol_ref_t [] @ 0x00007fbc7e1dad48)</span><br><span class="line">(lldb) p $5.list[0]</span><br><span class="line">(protocol_ref_t) $6 = 4294977072</span><br><span class="line">(lldb) p (protocol_t *)$6</span><br><span class="line">(protocol_t *) $7 = 0x0000000100002630</span><br><span class="line">(lldb) p *$7</span><br><span class="line">(protocol_t) $8 = &#123;</span><br><span class="line">  objc_object = &#123;</span><br><span class="line">    isa = &#123;</span><br><span class="line">      cls = Protocol</span><br><span class="line">      bits = 4302295240</span><br><span class="line">       = &#123;</span><br><span class="line">        nonpointer = 0</span><br><span class="line">        has_assoc = 0</span><br><span class="line">        has_cxx_dtor = 0</span><br><span class="line">        shiftcls = 537786905</span><br><span class="line">        magic = 0</span><br><span class="line">        weakly_referenced = 0</span><br><span class="line">        deallocating = 0</span><br><span class="line">        has_sidetable_rc = 0</span><br><span class="line">        extra_rc = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mangledName = 0x0000000100001f5e &quot;DogProtocol&quot;</span><br><span class="line">  protocols = 0x0000000000000000</span><br><span class="line">  instanceMethods = 0x0000000000000000</span><br><span class="line">  classMethods = 0x0000000000000000</span><br><span class="line">  optionalInstanceMethods = 0x0000000100002320</span><br><span class="line">  optionalClassMethods = 0x0000000000000000</span><br><span class="line">  instanceProperties = 0x0000000000000000</span><br><span class="line">  size = 96</span><br><span class="line">  flags = 0</span><br><span class="line">  _extendedMethodTypes = 0x0000000100002358</span><br><span class="line">  _demangledName = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  _classProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $8.optionalInstanceMethods</span><br><span class="line">(method_list_t *) $9 = 0x0000000100002320</span><br><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $10 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 2</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(0)</span><br><span class="line">(method_t) $11 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(1)</span><br><span class="line">(method_t) $12 = &#123;</span><br><span class="line">  name = &quot;printAge&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/02/11/Objc-category篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/11/Objc-category篇/" itemprop="url">Objc category篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-11T11:05:02+08:00">
                2018-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在之前的文章中，分析load有提到对category中的load方法进行存储调用<br>现在我们来窥探一下category的作用</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>category主要用于动态的为类添加一些方法和属性<br>在OC中，catefory是在运行期决议的。当编译完成,对象的内存布局已经确定，我们无法为类添加实例变量，通过category,可以设置关联对象，为类动态添加属性,也可以添加方法</p>
<p>注:<br>extension它是在编译期，和类的.h和.m构成类的结构，可以添加实例变量，一般用于隐藏类的私有属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Category</span><br><span class="line">@interface PattyDog (Category)</span><br><span class="line">// 只会生成set,get方法的声明,创建的对象没有name属性.</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Extension(类扩展)</span><br><span class="line">@interface PattyDog</span><br><span class="line">// 创建name成员变量,并声明和实现set,get方法</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>在objc-runtime-new.h中,申明了category的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct category_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    struct method_list_t *instanceMethods;</span><br><span class="line">    struct method_list_t *classMethods;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    struct property_list_t *instanceProperties;</span><br><span class="line">    // Fields below this point are not always present on disk.</span><br><span class="line">    struct property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *methodsForMeta(bool isMeta) &#123;</span><br><span class="line">        if (isMeta) return classMethods;</span><br><span class="line">        else return instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以了解到，category包含了</p>
<ul>
<li>类的名字</li>
<li>类</li>
<li>给类添加的  实例方法列表</li>
<li>给类添加的  类方法列表</li>
<li>给类添加的  协议列表</li>
<li>给类添加的  属性列表</li>
<li>给类添加的  类属性列表</li>
</ul>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Dog.h</span><br><span class="line">@interface Dog: NSObject</span><br><span class="line">- (void)printName;</span><br><span class="line">@end</span><br><span class="line">@interface Dog (Patty)</span><br><span class="line">@property(nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//Dog.m</span><br><span class="line">@implementation Dog</span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;CommonDog&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Dog(Patty)</span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;PattyDog&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>下面将Dog.m文件进行clang编译，看下编译之后有哪些改动，以下是主要的变化</p>
<ul>
<li>category_t 结构体含有实例方法_CATEGORY_INSTANCE_METHODS<em>Dog</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Dog_$_Patty,</span><br><span class="line"></span><br><span class="line">具体实现存储的方法只有一个，方法名称是printName，方法编码，函数地址都存储在里面</span><br><span class="line">__attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line"> sizeof(_objc_method),</span><br><span class="line"> 1,</span><br><span class="line"> &#123;&#123;(struct objc_selector *)&quot;printName&quot;, &quot;v16@0:8&quot;, (void *)_I_Dog_Patty_printName&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">static __NSConstantStringImpl __NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_0 __attribute__ ((section (&quot;__DATA, __cfstring&quot;))) = &#123;__CFConstantStringClassReference,0x000007c8,&quot;CommonDog&quot;,9&#125;;</span><br><span class="line">static __NSConstantStringImpl __NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_1 __attribute__ ((section (&quot;__DATA, __cfstring&quot;))) = &#123;__CFConstantStringClassReference,0x000007c8,&quot;PattyDog&quot;,8&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// @implementation Dog</span><br><span class="line"></span><br><span class="line">static void _I_Dog_printName(Dog * self, SEL _cmd) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_0);</span><br><span class="line">&#125;</span><br><span class="line">// @end</span><br><span class="line">// @implementation Dog(Patty)</span><br><span class="line"></span><br><span class="line">static void _I_Dog_Patty_printName(Dog * self, SEL _cmd) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_1);</span><br><span class="line">&#125;</span><br><span class="line">// @end</span><br><span class="line"></span><br><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">	unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">	unsigned int method_count;</span><br><span class="line">	struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Dog_$_Patty __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">	sizeof(_objc_method),</span><br><span class="line">	1,</span><br><span class="line">	&#123;&#123;(struct objc_selector *)&quot;printName&quot;, &quot;v16@0:8&quot;, (void *)_I_Dog_Patty_printName&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_Dog;</span><br><span class="line"></span><br><span class="line">static struct _category_t _OBJC_$_CATEGORY_Dog_$_Patty __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) =</span><br><span class="line">&#123;</span><br><span class="line">	&quot;Dog&quot;,</span><br><span class="line">	0, // &amp;OBJC_CLASS_$_Dog,</span><br><span class="line">	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Dog_$_Patty,</span><br><span class="line">	0,</span><br><span class="line">	0,</span><br><span class="line">	0,</span><br><span class="line">&#125;;</span><br><span class="line">static void OBJC_CATEGORY_SETUP_$_Dog_$_Patty(void ) &#123;</span><br><span class="line">	_OBJC_$_CATEGORY_Dog_$_Patty.cls = &amp;OBJC_CLASS_$_Dog;</span><br><span class="line">&#125;</span><br><span class="line">#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)</span><br><span class="line">__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">	(void *)&amp;OBJC_CATEGORY_SETUP_$_Dog_$_Patty,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">	&amp;OBJC_CLASS_$_Dog,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">	&amp;_OBJC_$_CATEGORY_Dog_$_Patty,</span><br><span class="line">&#125;;</span><br><span class="line">static struct IMAGE_INFO &#123; unsigned version; unsigned flag; &#125; _OBJC_IMAGE_INFO = &#123; 0, 2 &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>category是由OC动态加载（runtime）,多个category的调用顺序是无法保证的，<br>一般来说category内的方法需要添加前缀可避免重复添加导致编译出错<br>OC的运行入口，在objc-os.mm内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized = false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized = true;</span><br><span class="line"></span><br><span class="line">    // fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_2_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的方法，在map_2_images函数里面进入加载images,最终调用到_read_images方法</p>
<ul>
<li>获取OC的category列表catlist</li>
<li>然后remapClass</li>
<li>如果category含有实例方法，协议或者属性列表，添加到类上</li>
<li>如果category含有类方法列表，协议,添加到类的metaclass上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">// Discover categories.</span><br><span class="line">    for (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist =</span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);//从表中取出cat对应的cls</span><br><span class="line"></span><br><span class="line">            if (!cls) &#123;</span><br><span class="line">                // Category&apos;s target class is missing (probably weak-linked).</span><br><span class="line">                // Disavow any knowledge of this category.</span><br><span class="line">                catlist[i] = nil;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span><br><span class="line">                                 &quot;missing weak-linked target class&quot;,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bool classExists = NO;</span><br><span class="line">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties)</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                if (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,</span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name,</span><br><span class="line">                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                if (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,</span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>绑定category的方法、协议等映射到类上，内部调用方法addUnattachedCategoryForClass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void addUnattachedCategoryForClass(category_t *cat, Class cls,</span><br><span class="line">                                          header_info *catHeader)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    // DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead</span><br><span class="line">    NXMapTable *cats = unattachedCategories();  //初始化NXMapTable</span><br><span class="line">    category_list *list;</span><br><span class="line"></span><br><span class="line">    list = (category_list *)NXMapGet(cats, cls);//去Table表中查找对应cls的category列表</span><br><span class="line">    if (!list) &#123;</span><br><span class="line">        list = (category_list *)</span><br><span class="line">            calloc(sizeof(*list) + sizeof(list-&gt;list[0]), 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        list = (category_list *)</span><br><span class="line">            realloc(list, sizeof(*list) + sizeof(list-&gt;list[0]) * (list-&gt;count + 1));</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;list[list-&gt;count++] = (locstamped_category_t)&#123;cat, catHeader&#125;;//扩大list</span><br><span class="line">    NXMapInsert(cats, cls, list); //将cls对应的list插入到表中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>remethodizeClass 将cat一系列方法添加到类上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">static void remethodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // Re-methodizing: check for more categories</span><br><span class="line">    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        attachCategories(cls, cats, true /*flush caches*/);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // fixme rearrange to remove these intermediate allocations</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int propcount = 0;</span><br><span class="line">    int protocount = 0;</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    bool fromBundle = NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        property_list_t *proplist =</span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键在attachLists方法，将cls的rw对应的方法列表，属性列表，协议列表进行添加列表</p>
<ul>
<li>memmove<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">       if (addedCount == 0) return;</span><br><span class="line"></span><br><span class="line">       if (hasArray()) &#123;</span><br><span class="line">           // many lists -&gt; many lists</span><br><span class="line">           uint32_t oldCount = array()-&gt;count;</span><br><span class="line">           uint32_t newCount = oldCount + addedCount;</span><br><span class="line">           setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">           array()-&gt;count = newCount;</span><br><span class="line">           memmove(array()-&gt;lists + addedCount, array()-&gt;lists,</span><br><span class="line">                   oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">           memcpy(array()-&gt;lists, addedLists,</span><br><span class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">       &#125;</span><br><span class="line">       else if (!list  &amp;&amp;  addedCount == 1) &#123;</span><br><span class="line">           // 0 lists -&gt; 1 list</span><br><span class="line">           list = addedLists[0];</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123;</span><br><span class="line">           // 1 list -&gt; many lists</span><br><span class="line">           List* oldList = list;</span><br><span class="line">           uint32_t oldCount = oldList ? 1 : 0;</span><br><span class="line">           uint32_t newCount = oldCount + addedCount;</span><br><span class="line">           setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">           array()-&gt;count = newCount;</span><br><span class="line">           if (oldList) array()-&gt;lists[addedCount] = oldList;</span><br><span class="line">           memcpy(array()-&gt;lists, addedLists,</span><br><span class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>memmove和memcpy 两个C函数的操作，<br>将array先前的列表内容拷贝到新数组的末尾，然后将新添加的list插入到新数组的头部<br>解释了category的特性</p>
<ul>
<li>category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加方法后，类的方法列表里会有两个methodA</li>
<li>category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，也就是我们常说category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会停止查找，殊不知后面可能还有一样名字的方法。</li>
<li>category关联对象特性在之前文章中，请自行翻阅</li>
</ul>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>memmove(p2, p1, len) 内存拷贝<br>将p1的前面len长度的字符，拷贝到p2</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li>c函数 memmove和memcpy的区别 <a href="http://blog.jobbole.com/108842/" target="_blank" rel="noopener">http://blog.jobbole.com/108842/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/02/03/Objc关联对象的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/03/Objc关联对象的实现/" itemprop="url">Objc关联对象的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-03T15:36:52+08:00">
                2018-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天主要来聊一聊以下三个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void *key) &#123;</span><br><span class="line">    return _object_get_associative_reference(object, (void *)key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">    _object_set_associative_reference(object, (void *)key, value, policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void objc_removeAssociatedObjects(id object)</span><br><span class="line">&#123;</span><br><span class="line">    if (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        _object_remove_assocations(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分类添加属性的时候，由于系统没有办法自动将属性添加set和get方法，需要自动实现，就需要以上的方法来实现</p>
<h2 id="事例code"><a href="#事例code" class="headerlink" title="事例code"></a>事例code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@interface Dog: NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation Dog</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Dog(DanceCategory)</span><br><span class="line">@property (nonatomic, strong) NSString *categoryProperty;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog(DanceCategory)</span><br><span class="line">- (NSString *)categoryProperty</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">- (void)setCategoryProperty:(NSString *)categoryProperty</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(categoryProperty), categoryProperty, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark -main</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Dog *dd = [[Dog alloc] init];</span><br><span class="line">        dd.categoryProperty = @&quot;分类属性&quot;;</span><br><span class="line">        dd.categoryProperty;</span><br><span class="line">        objc_removeAssociatedObjects(dd);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>先看下设置属性的方法调用顺序<br><img src="/images/分类属性-调用堆栈.png" alt="调用堆栈.png"></p>
<h3 id="object-set-associative-reference"><a href="#object-set-associative-reference" class="headerlink" title="object_set_associative_reference"></a>object_set_associative_reference</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line"></span><br><span class="line">    ObjcAssociation old_association(0, nil); //生成旧对象</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;  </span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i != associations.end()) &#123;</span><br><span class="line">                // secondary table exists</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second; //如果存在之前的值，给旧对象赋值</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // create the new association (first time).</span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // setting the association to nil breaks the association.</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果旧对象有值，进行释放</span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上主要操作:</p>
<ul>
<li>初始生成old_association，便于存储旧对象以及清除旧值</li>
<li>acquireValue 方法内部是对value进行copy或者retain</li>
<li>生成唯一的AssociationsManager 和 AssociationsHashMap</li>
<li>disguised_object 是根据object生成的，下面需要根据newValue的值是否为空来处理两种情况</li>
</ul>
<ol>
<li><p>newValue 存在</p>
<ul>
<li>在AssociationsHashMap中根据disguised_object作为key去取对应的object的AssociationsHashMap</li>
<li><p>如果map存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectAssociationMap *refs = i-&gt;second</span><br><span class="line">ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">if (j != refs-&gt;end()) &#123; //如果存在旧值，将旧值赋值给old_association</span><br><span class="line">    old_association = j-&gt;second;</span><br><span class="line">    j-&gt;second = ObjcAssociation(policy, new_value);//然后重新赋值</span><br><span class="line">&#125; else &#123; //如果不存在旧值，给map表设置key和value</span><br><span class="line">    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果map不存在，新生成ObjectAssociationMap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAssociationMap *refs = new ObjectAssociationMap; //新生成ObjectAssociationMap</span><br><span class="line">associations[disguised_object] = refs; //将disguised_object作为key ,value是ObjectAssociationMap</span><br><span class="line">(*refs)[key] = ObjcAssociation(policy, new_value) //在ObjectAssociationMap中插入key和对应的ObjcAssociation</span><br><span class="line">object-&gt;setHasAssociatedObjects();//标记对象对应的标记位</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>newValue 为空 说明需要将对应的map表移除</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">if (i !=  associations.end()) &#123; //如果存在该object对应的map表，</span><br><span class="line">    ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">    ObjectAssociationMap::iterator j = refs-&gt;find(key); //从ObjectAssociationMap表中取出对应的key所对应的association</span><br><span class="line">    if (j != refs-&gt;end()) &#123;</span><br><span class="line">        old_association = j-&gt;second; //将存在的值赋值给old_association</span><br><span class="line">        refs-&gt;erase(j); //从表中将key对应的ObjcAssociation进行擦除</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>最后 如果存在旧值，将旧值释放即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (old_association.hasValue()) ReleaseValue()(old_association);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="object-get-associative-reference"><a href="#object-get-associative-reference" class="headerlink" title="object_get_associative_reference"></a>object_get_associative_reference</h3><p><img src="/images/分类属性-get.png" alt="getAssociation堆栈图"><br>上图是调用对象属性的get方法执行的堆栈结构图</p>
<p>流程比上面的方法相对简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id _object_get_associative_reference(id object, void *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object); //从AssociationsHashMap表中查找对象</span><br><span class="line">        if (i != associations.end()) &#123; //如果存在对象的话</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key); //从对象对应的ObjectAssociationMap表中根据key取出对应的value</span><br><span class="line">            if (j != refs-&gt;end()) &#123; //如果存在value</span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.value(); //将存在的ObjcAssociation属性对应赋值</span><br><span class="line">                policy = entry.policy();</span><br><span class="line">                if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);   //对value进行retain</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);</span><br><span class="line">    &#125;</span><br><span class="line">    return value; //最后将关联对象 ObjcAssociation 的值进行返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="objc-removeAssociatedObjects"><a href="#objc-removeAssociatedObjects" class="headerlink" title="objc_removeAssociatedObjects"></a>objc_removeAssociatedObjects</h2><p>先来看下调用remove方法的函数调用<br><img src="/images/分类属性-remove.png" alt="remove"><br>打印isa的结构，可以看到对象的has_assoc 标记为1，也就是存在关联对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void _object_remove_assocations(id object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        if (associations.size() == 0) return; //如果不存在 返回</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object); //查找object对应的表</span><br><span class="line">        if (i != associations.end()) &#123;</span><br><span class="line">            // copy all of the associations that need to be removed.</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second; //存在的话取出对应的object表</span><br><span class="line">            for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);//将表的元素存入elements</span><br><span class="line">            &#125;</span><br><span class="line">            delete refs; //移除object对应的表</span><br><span class="line">            associations.erase(i); //同时在AssociationsHashMap表中将object也移除</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // the calls to releaseValue() happen outside of the lock.</span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue()); //通过循环将elements元素都进行释放</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文就是对于如何给分类添加属性操作进行解读</p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/02/02/KVO-实现原理分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/02/KVO-实现原理分析/" itemprop="url">KVO 实现原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-02T11:59:38+08:00">
                2018-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在之前，一直以为类的isa结构图就是那张很经典的图，但是才发现有个特例情况下，有点变化</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  PattyCat *pcat = [[PattyCat alloc] init];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   NSLog(@&quot;%p--pcat的isa:%p--%@-%@-%@&quot;,(object_getClass([PattyCat class])),object_getClass(pcat),object_getClass(pcat),pcat.superclass,[object_getClass(pcat) superclass]);</span><br><span class="line">   /*</span><br><span class="line">    0x10408c910--pcat的isa:0x10408c870--PattyCat-Cat-Cat</span><br><span class="line">    */</span><br><span class="line">   [pcat addObserver:self</span><br><span class="line">         forKeyPath:@&quot;address&quot;</span><br><span class="line">         options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld</span><br><span class="line">         context:nil];</span><br><span class="line">   pcat.address = @&quot;有地址了&quot;;</span><br><span class="line">//    NSLog(@&quot;%@--%p&quot;,(object_getClass([PattyCat class])),object_getClass(pcat));</span><br><span class="line"></span><br><span class="line">   NSLog(@&quot;%p---pcat的isa:%p-新的子类是:%@-新的子类的isa:%p-%@-%@&quot;,(object_getClass([PattyCat class])),object_getClass(pcat),object_getClass(pcat),object_getClass(object_getClass(pcat)),pcat.superclass,[object_getClass(pcat) superclass]);</span><br><span class="line">   /*</span><br><span class="line">    0x10408c910---pcat的isa:0x7b24000260a0-新的子类是:NSKVONotifying_PattyCat-新的子类的isa:0x7b2400026130-Cat-PattyCat</span><br><span class="line">    */</span><br><span class="line">   [pcat removeObserver:self forKeyPath:@&quot;address&quot;];</span><br><span class="line"></span><br><span class="line">  NSLog(@&quot;%p--pcat的isa:%p--%@-%@-%@&quot;,(object_getClass([PattyCat class])),object_getClass(pcat),object_getClass(pcat),pcat.superclass,[object_getClass(pcat) superclass]);</span><br><span class="line">   /*</span><br><span class="line">    0x10408c910--pcat的isa:0x10408c870--PattyCat-Cat-Cat</span><br><span class="line">    */</span><br></pre></td></tr></table></figure>
<p>在当前类中引入对象pcat,监听它的KVO变化之后，然后移除KVO，对象的isa以及superClass前后的变化如上</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>苹果文档介绍</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class ..</p>
</blockquote>
<p>简要的来说，在我们对某个对象完成监听的注册后，编译器会修改监听对象（上文中的pcat）的isa指针，让这个指针指向一个新生成的中间类，中间类的命名格式如 NSKVONotifying_XX (XX 是pcat对象的class)</p>
<p>苹果还 <strong>重写了这个子类的class方法跟description方法</strong> 来掩人耳目。<br>另外，新类相对于父类添加了一个NSKVONotifying_前缀，添加这个前缀是为了避免多次创建监听子类，节省资源</p>
<p>以上通过object_getClass(pcat)命令得到了KVO前为PattyCat   KVO后值为 NSKVONotifying_PattyCat</p>
<p>注: 以下两个方式得到类的指针是一样的哦<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p object_getClass(pcat)</span><br><span class="line">(Class) $0 = PattyCat</span><br><span class="line">(lldb) p (void *)$0</span><br><span class="line">(void *) $1 = 0x0000000100001188</span><br><span class="line"></span><br><span class="line">(lldb) p (objc_class *)[PattyCat class]</span><br><span class="line">(objc_class *) $2 = 0x0000000100001188</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对实例对象进行KVO观察的时候，实际上对象的isa已经不是之前的类对象了<br>移除KVO之后，恢复之前效果</p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/01/31/Objc中的属性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/31/Objc中的属性/" itemprop="url">Objc中的属性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-31T14:58:14+08:00">
                2018-01-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基础OC源码与clang编译"><a href="#基础OC源码与clang编译" class="headerlink" title="基础OC源码与clang编译"></a>基础OC源码与clang编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Dog: NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *sex;</span><br><span class="line">@property (nonatomic, copy) NSString *address;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation Dog</span><br><span class="line">&#123;</span><br><span class="line">    NSString * _name;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark -main</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过clang重写为cpp之后，文件主要的内容截取查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _REWRITER_typedef_Dog</span><br><span class="line">#define _REWRITER_typedef_Dog</span><br><span class="line">typedef struct objc_object Dog;</span><br><span class="line">typedef struct &#123;&#125; _objc_exc_Dog;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; unsigned long OBJC_IVAR_$_Dog$_sex;</span><br><span class="line">extern &quot;C&quot; unsigned long OBJC_IVAR_$_Dog$_address;</span><br><span class="line">struct Dog_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">	NSString *_name;</span><br><span class="line">	NSString *_sex;</span><br><span class="line">	NSString *_address;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// @property (nonatomic, copy) NSString *sex;</span><br><span class="line">// @property (nonatomic, copy) NSString *address;</span><br><span class="line">/* @end */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/** implementation Dog</span><br><span class="line">&#123;</span><br><span class="line">    NSString * _name;</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">static NSString * _I_Dog_sex(Dog * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Dog$_sex)); &#125;</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_setProperty (id, SEL, long, id, bool, bool);</span><br><span class="line"></span><br><span class="line">static void _I_Dog_setSex_(Dog * self, SEL _cmd, NSString *sex) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Dog, _sex), (id)sex, 0, 1); &#125;</span><br><span class="line"></span><br><span class="line">static NSString * _I_Dog_address(Dog * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Dog$_address)); &#125;</span><br><span class="line">static void _I_Dog_setAddress_(Dog * self, SEL _cmd, NSString *address) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Dog, _address), (id)address, 0, 1); &#125;</span><br><span class="line">// @end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Dog_IMPL 结构体含有三个实例变量，其中两个是系统为property生成的，一个是自身的ivar<br>Dog实现 系统自动生成property对应的set和get方法</p>
<p>对源码修改，添加如下code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@synthesize address = _name;</span><br></pre></td></tr></table></figure></p>
<p>clang编译之后，两份.cpp文件对比</p>
<p><img src="/images/cpp对比图.png" alt="cpp对比图"></p>
<p>以下是两份对比内容的源码</p>
<ul>
<li><p>当前添加code之后的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; unsigned long OBJC_IVAR_$_Dog$_name;</span><br><span class="line">// @synthesize address = _name;</span><br><span class="line">static NSString * _I_Dog_address(Dog * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Dog$_name)); &#125;</span><br><span class="line">static void _I_Dog_setAddress_(Dog * self, SEL _cmd, NSString *address) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Dog, _name), (id)address, 0, 1); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static NSString * _I_Dog_sex(Dog * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Dog$_sex)); &#125;</span><br><span class="line">	struct _ivar_t ivar_list[2];</span><br><span class="line">	2,</span><br><span class="line">	 &#123;(unsigned long int *)&amp;OBJC_IVAR_$_Dog$_sex, &quot;_sex&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;&#125;</span><br><span class="line">	&#123;&#123;(struct objc_selector *)&quot;address&quot;, &quot;@16@0:8&quot;, (void *)_I_Dog_address&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)&quot;setAddress:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Dog_setAddress_&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)&quot;sex&quot;, &quot;@16@0:8&quot;, (void *)_I_Dog_sex&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)&quot;setSex:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Dog_setSex_&#125;&#125;</span><br><span class="line">	&#123;&quot;address&quot;,&quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>未修改内容的cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; unsigned long OBJC_IVAR_$_Dog$_address;</span><br><span class="line">	NSString *_address;</span><br><span class="line"></span><br><span class="line">static NSString * _I_Dog_sex(Dog * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Dog$_sex)); &#125;</span><br><span class="line"></span><br><span class="line">static NSString * _I_Dog_address(Dog * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Dog$_address)); &#125;</span><br><span class="line">static void _I_Dog_setAddress_(Dog * self, SEL _cmd, NSString *address) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Dog, _address), (id)address, 0, 1); &#125;</span><br><span class="line">extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Dog$_address __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Dog, _address);</span><br><span class="line">	struct _ivar_t ivar_list[3];</span><br><span class="line">	3,</span><br><span class="line">	 &#123;(unsigned long int *)&amp;OBJC_IVAR_$_Dog$_sex, &quot;_sex&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;,</span><br><span class="line">	 &#123;(unsigned long int *)&amp;OBJC_IVAR_$_Dog$_address, &quot;_address&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;&#125;</span><br><span class="line">	&#123;&#123;(struct objc_selector *)&quot;sex&quot;, &quot;@16@0:8&quot;, (void *)_I_Dog_sex&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)&quot;setSex:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Dog_setSex_&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)&quot;address&quot;, &quot;@16@0:8&quot;, (void *)_I_Dog_address&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)&quot;setAddress:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Dog_setAddress_&#125;&#125;</span><br><span class="line">	&#123;&quot;address&quot;,&quot;T@\&quot;NSString\&quot;,C,N,V_address&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对比之后可以发现，当重写@synthesize方法, 自定义绑定属性<br>将属性和已经存在的成员变量进行绑定，编译器没有自动生成_address，在类中找不到这个变量的存在<br>所以当我们使用_address的时候，就会报错</p>
<p>有了getter和setter，方便获取属性，从某个意义上 属性更加面向对象</p>
<h3 id="查看系统为Dog类生成的实例变量"><a href="#查看系统为Dog类生成的实例变量" class="headerlink" title="查看系统为Dog类生成的实例变量"></a>查看系统为Dog类生成的实例变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@interface Dog: NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *sex;</span><br><span class="line">@property (nonatomic, copy) NSString *address;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog</span><br><span class="line">&#123;</span><br><span class="line">    NSString * _name;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark -main</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        unsigned int ivarCount = 0;</span><br><span class="line">        Ivar * ivars =  class_copyIvarList([Dog class], &amp;ivarCount);</span><br><span class="line">        NSLog(@&quot;=======&quot;);</span><br><span class="line">        for (unsigned int idx = 0; idx &lt; ivarCount; idx++) &#123;</span><br><span class="line">            Ivar ivar = ivars[idx];</span><br><span class="line">            NSLog(@&quot;%s&quot;, ivar_getName(ivar));</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivars);</span><br><span class="line"></span><br><span class="line">        unsigned int propertyCount;</span><br><span class="line">        objc_property_t * properties = class_copyPropertyList([Dog class], &amp;propertyCount);</span><br><span class="line">        NSLog(@&quot;=======&quot;);</span><br><span class="line">        for (unsigned int idx = 0; idx &lt; ivarCount; idx++) &#123;</span><br><span class="line">            objc_property_t property = properties[idx];</span><br><span class="line">            NSLog(@&quot;attribute:%s&quot;,property_getAttributes(property));</span><br><span class="line">        &#125;</span><br><span class="line">        free(properties);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印输出:</span><br><span class="line">_name _sex _address</span><br><span class="line"> attribute:T@&quot;NSString&quot;,C,N,V_sex</span><br><span class="line"> attribute:T@&quot;NSString&quot;,C,N,V_name</span><br></pre></td></tr></table></figure>
<ul>
<li>属性说明<br>使用property_getAttributes获得的描述是property_copyAttributeList<br>能获取到的所有的name和value的总体描述，<br>如 T@”NSDictionary”,C,N,V_dict1</li>
</ul>
<p>常用的属性如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">属性类型  name值：T  value：变化</span><br><span class="line">编码类型  name值：C(copy) &amp;(strong) W(weak) 空(assign) 等 value：无</span><br><span class="line">非/原子性 name值：空(atomic) N(Nonatomic)  value：无</span><br><span class="line">变量名称  name值：V  value：变化</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OC 属性和实例变量是存在区别的</p>
<p>实例变量，不会自动生成对应的getter和setter方法<br>属性，系统自动生成对应的getter和setter方法</p>
<p>相比起变量，在编译期间，编译器做了很多工作，包括这些：</p>
<ul>
<li>使用@synthesize生成属性对应的ivar，通常ivar命名为下划线+属性名</li>
<li>生成setter方法来设置ivar</li>
<li>生成getter方法来获取ivar</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/01/30/Objc消息的缓存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/30/Objc消息的缓存/" itemprop="url">Objc消息的缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-30T14:30:00+08:00">
                2018-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先来看下class对象的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p>
<p>存在了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct objc_cache *cache</span><br></pre></td></tr></table></figure></p>
<p>类型的方法缓存结构，objc_cache是一个结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct objc_cache &#123;</span><br><span class="line">    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;</span><br><span class="line">    unsigned int occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[1]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>mask表示当前能达到的最大index,从0开始，所以总是是mask+1</li>
<li>occupied 当前被占用的位置数量</li>
<li>buckets 数组表示的hash表，数组的每一项都代表的是方法，<br>类型是Method，Method的结构是objc_method,<br>里面存储了方法的method_name,method_types,method_imp<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method;</span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>每个类都存在objc_cache的结构体缓存方法列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PattyCat *pcat = [PattyCat alloc];</span><br><span class="line">[pcat init];</span><br><span class="line"></span><br><span class="line">[pcat class];</span><br></pre></td></tr></table></figure>
<p>所以在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[pcat class]</span><br></pre></td></tr></table></figure></p>
<p>处打上断点,在lookUpImpOrForward也打上断点，看看如何查找到父类的class方法流程</p>
<ul>
<li>去当前类的缓存cache_getImp查找，找不到去当前类的方法列表里methods.beginLists去查找，</li>
<li>如果当前类不存在方法，就会通过while循环查找， 先在父类缓存查找方法cache_getImp，找不到就在当前父类的方法列表查找getMethodNoSuper_nolock，如果找不到就往上找，</li>
<li>直到找到之后，都会缓存该方法实现 log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);缓存在类本身的方法缓存里。</li>
</ul>
<p>以上查找流程，当while循环两次之后，当curClass=NSObject,通过getMethodNoSuper_nolock查找到了class这个方法的method,<br><img src="/images/method_cache.png" alt="method缓存图"><br>可以看到class方法的type是 “#16@0:8”</p>
<p>从下图可以看到如何执行的方法cache，此处将NSObject的-class方法进行缓存<br><img src="/images/method_cache_fill.png" alt="method缓存fill"></p>
<p>cache_fill_nolock方法主要就是将cls的缓存方法结构体进行修改 bucket-&gt;set(key, imp);<br>如果cache的容量不够，则进行扩展cache-&gt;expand();<br>如果当前占用的数量还在总容量的3/4，则不扩展<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    // Never cache before +initialize is done</span><br><span class="line">    if (!cls-&gt;isInitialized()) return;</span><br><span class="line"></span><br><span class="line">    // Make sure the entry wasn&apos;t added to the cache by some other thread</span><br><span class="line">    // before we grabbed the cacheUpdateLock.</span><br><span class="line">    if (cache_getImp(cls, sel)) return;</span><br><span class="line"></span><br><span class="line">    cache_t *cache = getCache(cls);</span><br><span class="line">    cache_key_t key = getKey(sel);</span><br><span class="line"></span><br><span class="line">    // Use the cache as-is if it is less than 3/4 full</span><br><span class="line">    mask_t newOccupied = cache-&gt;occupied() + 1;</span><br><span class="line">    mask_t capacity = cache-&gt;capacity();</span><br><span class="line">    if (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        // Cache is read-only. Replace it.</span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (newOccupied &lt;= capacity / 4 * 3) &#123;</span><br><span class="line">        // Cache is less than 3/4 full. Use it as-is.</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // Cache is too full. Expand it.</span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Scan for the first unused slot and insert there.</span><br><span class="line">    // There is guaranteed to be an empty slot because the</span><br><span class="line">    // minimum size is 4 and we resized at 3/4 full.</span><br><span class="line">    bucket_t *bucket = cache-&gt;find(key, receiver);</span><br><span class="line">    if (bucket-&gt;key() == 0) cache-&gt;incrementOccupied();</span><br><span class="line">    bucket-&gt;set(key, imp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bucket设置之后，方法的cache存储结构如下<br><img src="/images/cache_bucket.png" alt="method缓存bucket"></p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/01/26/由RACSwizzleClass引发的class思考/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/26/由RACSwizzleClass引发的class思考/" itemprop="url">由RACSwizzleClass引发的class思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-26T17:12:47+08:00">
                2018-01-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前在看ReactiveCocoa的源码时候，看到交换类的class方法，存在些疑惑，记下来以免忘记</p>
<p>下面是主要的code，两个类，存在继承关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -class</span><br><span class="line">@interface Cat: NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation Cat</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface PattyCat: Cat</span><br><span class="line">@end</span><br><span class="line">@implementation PattyCat</span><br><span class="line">@end</span><br><span class="line">void RACSwizzleGetClass(Class class, Class statedClass) &#123;</span><br><span class="line">    SEL selector = @selector(class);</span><br><span class="line">    Method method = class_getInstanceMethod(class, selector);</span><br><span class="line">    IMP newIMP = imp_implementationWithBlock(^(id self) &#123;</span><br><span class="line">        return statedClass;</span><br><span class="line">    &#125;);</span><br><span class="line">    class_replaceMethod(class, selector, newIMP, method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;%p ---- %p&quot;,[PattyCat class],[Cat class]);</span><br><span class="line">        NSLog(@&quot;%p ---- %p&quot;,[[PattyCat new]class],[[Cat new]class]);</span><br><span class="line"></span><br><span class="line">        RACSwizzleGetClass([PattyCat class],[Cat class]);</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;%p \n %p&quot;,[PattyCat class],[Cat class]);</span><br><span class="line">        NSLog(@&quot;%p ---- %p&quot;,[[PattyCat new]class],[[Cat new]class]);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        RACSwizzleGetClass 方法交换的class之后，</span><br><span class="line">        为什么打印的[PattyCat class]前后没有变化？</span><br><span class="line">        [[PattyCat new]class]变化了，怎么写才会有变化</span><br><span class="line">        */</span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实践<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;%p ---- %p&quot;,[PattyCat class],[Cat class]);</span><br><span class="line">        NSLog(@&quot;%p ---- %p&quot;,[[PattyCat new]class],[[Cat new]class]);</span><br><span class="line"></span><br><span class="line">        IMP pattyCat_Class_IMP_before = [[PattyCat class] methodForSelector:@selector(class)];</span><br><span class="line">        IMP pattyCat_Instance_IMP_before = [[PattyCat new] methodForSelector:@selector(class)];</span><br><span class="line">        IMP pattyCat_MetaClass_IMP_before = [object_getClass([PattyCat class]) methodForSelector:@selector(class)];</span><br><span class="line"></span><br><span class="line">        //第一种情况</span><br><span class="line">       // RACSwizzleGetClass([PattyCat class],[Cat class]);</span><br><span class="line"></span><br><span class="line">        //第二种情况</span><br><span class="line">        id metaClass = object_getClass([PattyCat class]);</span><br><span class="line">        RACSwizzleGetClass(metaClass,[Cat class]);</span><br><span class="line"></span><br><span class="line">        IMP pattyCat_Class_IMP_after = [[PattyCat class] methodForSelector:@selector(class)];</span><br><span class="line">        IMP pattyCat_Instance_IMP_after= [[PattyCat new] methodForSelector:@selector(class)];</span><br><span class="line">        IMP pattyCat_MetaClass_IMP_after = [object_getClass([PattyCat class]) methodForSelector:@selector(class)];</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;%p ---- %p&quot;,[PattyCat class],[Cat class]);</span><br><span class="line">        NSLog(@&quot;%p ---- %p&quot;,[[PattyCat new]class],[[Cat new]class]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 对于第一种情况 RACSwizzleGetClass([PattyCat class],[Cat class]);<br> 打印前后 NSLog(@”%p \n %p”,[PattyCat class],[Cat class]);值没有变化</p>
<p> 在左侧的结果里，可以看到<br> pattyCat_Class_IMP_before 和 pattyCat_Class_IMP_after 都是一样的结果<br> 但是pattyCat_Instance_IMP_before 和 pattyCat_Instance_IMP_after不一样了</p>
<p> 说明swizzle交换的是-class方法，<br> 打印[[PattyCat new]class] 和 [[Cat new]class] 结果是一样的</p>
<p> 原因：<br> RACSwizzleGetClass 的第一个参数 如果是[PattyCat class]，那么<br> 根据 NSObject.mm<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)class &#123;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> [PattyCat class]返回的是PattyCat对象自身，所以<br> class_replaceMethod(class, selector, newIMP, method_getTypeEncoding(method));<br> 这句话是去PattyCat对象的methodList方法列表里去查找class方法，找到的当然是-class，替换为Cat对象</p>
<p> 对于第二种情况<br> id metaClass = object_getClass([PattyCat class]);<br> RACSwizzleGetClass(metaClass,[Cat class]);<br> 在左侧的结果里，可以看到 imp在前后都是一样的实现<br> 说明交互的是+class</p>
<p> 打印[PattyCat class]和[Cat class]是一样的了，也就是替换了[PattyCat class]指向<br> 因为第一个参数传递的是元类，也就是获取的是+class，所以打印的时候，[PattyCat class]从patty_meta_class查找方法，<br> 找不到就去super_meta_class查找，直到NSObject_meta_class，查找到替换方法的返回结果，所以获取[PattyCat class]取到的是替换后的结果，打印结果和之前有变化</p>
<h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><p>-class 和 +class 取值的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PattyCat *pcat = [[PattyCat alloc]init];</span><br></pre></td></tr></table></figure></p>
<p>[pcat class] 实例对象的class方法，是去PattyCat类查找class,如果没有，就一直去父类找，找到NSObject的-class方法，然后copy缓存一份在PattyCat的类列表里,虽然打印结果是一样的，但是指针地址%p是不一样的。</p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/01/18/ReactiveCocoa-RACDelegateProxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/18/ReactiveCocoa-RACDelegateProxy/" itemprop="url">ReactiveCocoa RACDelegateProxy</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-18T13:49:25+08:00">
                2018-01-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文源码为 ReactiveObjc 3.1.0 版本</p>
<p>ReactiveCocoa，将Cocoa世界中的代理，KVO，通知等桥接到了RAC的世界中，就是使用的RACDelegateProxy，通过运行时修改方法的运行机制，下面一起来熟悉下怎么做到的</p>
<p>使用事例</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RACDelegateProxy *delegateProxy = [[RACDelegateProxy  alloc]initWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">UITextFieldDelegate</span>)];</span></span><br><span class="line"></span><br><span class="line">[[delegateProxy rac_signalForSelector:<span class="keyword">@selector</span>(textFieldShouldReturn:)] subscribeNext:^(RACTuple *args) &#123;</span><br><span class="line">       <span class="built_in">UITextField</span> *field = [args first];</span><br><span class="line">       [field resignFirstResponder];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.textfield.delegate = (<span class="keyword">id</span>&lt;<span class="built_in">UITextFieldDelegate</span>&gt;)delegateProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//防止delegateProxy被释放</span></span><br><span class="line">objc_setAssociatedObject(<span class="keyword">self</span>.textfield, _cmd, delegateProxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br></pre></td></tr></table></figure>
<h2 id="RACDelegateProxy"><a href="#RACDelegateProxy" class="headerlink" title="RACDelegateProxy"></a>RACDelegateProxy</h2><p>RACDelegateProxy 继承自NSObject<br>创建只有一个init方法initWithProtocol传入协议，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithProtocol:(Protocol *)protocol &#123;</span><br><span class="line">	NSCParameterAssert(protocol != NULL);</span><br><span class="line"></span><br><span class="line">	self = [super init];</span><br><span class="line"></span><br><span class="line">	class_addProtocol(self.class, protocol);</span><br><span class="line"></span><br><span class="line">	_protocol = protocol;</span><br><span class="line"></span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line">给当前对象的类加上protocol</span><br></pre></td></tr></table></figure></p>
<p>RACDelegateProxy 有一个属性 id rac_proxiedDelegate:如果没有实现signalForSelector，则消息真正转发的代理对象</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">	[invocation invokeWithTarget:self.rac_proxiedDelegate]; //转发代理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line">  //获取协议必须和非必须的方法描述</span><br><span class="line">	struct objc_method_description methodDescription = protocol_getMethodDescription(_protocol, selector, NO, YES);</span><br><span class="line"></span><br><span class="line">	if (methodDescription.name == NULL) &#123;</span><br><span class="line">		methodDescription = protocol_getMethodDescription(_protocol, selector, YES, YES);</span><br><span class="line">		if (methodDescription.name == NULL) return [super methodSignatureForSelector:selector];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return [NSMethodSignature signatureWithObjCTypes:methodDescription.types];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark API</span><br><span class="line"></span><br><span class="line">- (RACSignal *)signalForSelector:(SEL)selector &#123;</span><br><span class="line">	return [self rac_signalForSelector:selector fromProtocol:_protocol];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSignal *)rac_signalForSelector:(SEL)selector fromProtocol:(Protocol *)protocol &#123;</span><br><span class="line">	NSCParameterAssert(selector != NULL);</span><br><span class="line">	NSCParameterAssert(protocol != NULL);</span><br><span class="line"></span><br><span class="line">	return NSObjectRACSignalForSelector(self, selector, protocol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSObjectRACSignalForSelector"><a href="#NSObjectRACSignalForSelector" class="headerlink" title="NSObjectRACSignalForSelector"></a>NSObjectRACSignalForSelector</h3><p>方法就是实现消息转发的关键，如何将seletor方法转化为信号RACSignal<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">static RACSignal *NSObjectRACSignalForSelector(NSObject *self, SEL selector, Protocol *protocol) &#123;</span><br><span class="line">	SEL aliasSelector = RACAliasForSelector(selector);</span><br><span class="line"></span><br><span class="line">	@synchronized (self) &#123;</span><br><span class="line">		RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);</span><br><span class="line">		if (subject != nil) return subject;</span><br><span class="line"></span><br><span class="line">		Class class = RACSwizzleClass(self);</span><br><span class="line">		NSCAssert(class != nil, @&quot;Could not swizzle class of %@&quot;, self);</span><br><span class="line"></span><br><span class="line">		subject = [[RACSubject subject] setNameWithFormat:@&quot;%@ -rac_signalForSelector: %s&quot;, RACDescription(self), sel_getName(selector)];</span><br><span class="line">		objc_setAssociatedObject(self, aliasSelector, subject, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line"></span><br><span class="line">		[self.rac_deallocDisposable addDisposable:[RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">			[subject sendCompleted];</span><br><span class="line">		&#125;]];</span><br><span class="line"></span><br><span class="line">		Method targetMethod = class_getInstanceMethod(class, selector);</span><br><span class="line">		if (targetMethod == NULL) &#123; //对不存在该方法，只需要获得方法的类型编码并将实现添加为 _objc_msgForward，交给消息转发流程进行处理即可。</span><br><span class="line">			const char *typeEncoding;</span><br><span class="line">			if (protocol == NULL) &#123;</span><br><span class="line">				typeEncoding = RACSignatureForUndefinedSelector(selector);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">        //protocol_getMethodDescription 两次从协议中获取可选和必须实现的方法的描述，并从结构体中拿出类型编码，最后为类添加这个之前不存在的方法：</span><br><span class="line"></span><br><span class="line">				if (methodDescription.name == NULL) &#123;</span><br><span class="line">					// Then fall back to looking for a required instance method.</span><br><span class="line">					methodDescription = protocol_getMethodDescription(protocol, selector, YES, YES);</span><br><span class="line">					NSCAssert(methodDescription.name != NULL, @&quot;Selector %@ does not exist in &lt;%s&gt;&quot;, NSStringFromSelector(selector), protocol_getName(protocol));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				typeEncoding = methodDescription.types;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			RACCheckTypeEncoding(typeEncoding);</span><br><span class="line"></span><br><span class="line">			// Define the selector to call -forwardInvocation:.</span><br><span class="line">			if (!class_addMethod(class, selector, _objc_msgForward, typeEncoding)) &#123;</span><br><span class="line">				NSDictionary *userInfo = @&#123;</span><br><span class="line">					NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedString(@&quot;A race condition occurred implementing %@ on class %@&quot;, nil), NSStringFromSelector(selector), class],</span><br><span class="line">					NSLocalizedRecoverySuggestionErrorKey: NSLocalizedString(@&quot;Invoke -rac_signalForSelector: again to override the implementation.&quot;, nil)</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				return [RACSignal error:[NSError errorWithDomain:RACSelectorSignalErrorDomain code:RACSelectorSignalErrorMethodSwizzlingRace userInfo:userInfo]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else if (method_getImplementation(targetMethod) != _objc_msgForward) &#123;</span><br><span class="line">			// Make a method alias for the existing method implementation.</span><br><span class="line">			const char *typeEncoding = method_getTypeEncoding(targetMethod);</span><br><span class="line"></span><br><span class="line">			RACCheckTypeEncoding(typeEncoding);</span><br><span class="line"></span><br><span class="line">			BOOL addedAlias __attribute__((unused)) = class_addMethod(class, aliasSelector, method_getImplementation(targetMethod), typeEncoding);</span><br><span class="line">			NSCAssert(addedAlias, @&quot;Original implementation for %@ is already copied to %@ on %@&quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), class);</span><br><span class="line"></span><br><span class="line">			// Redefine the selector to call -forwardInvocation:.</span><br><span class="line">			class_replaceMethod(class, selector, _objc_msgForward, method_getTypeEncoding(targetMethod));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return subject;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上方法可以分为三个部分</p>
<ul>
<li>生成对应的aliasSelector，绑定RACSubject</li>
<li>RACSwizzleClass</li>
<li>class_addMethod</li>
</ul>
<p>class_addMethod 可以分为三部分</p>
<ul>
<li>targetMethod == NULL &amp;&amp;  Protocol == NULL : RACSignatureForUndefinedSelector根据selector生成不存在的方法，返回方法类型编码，然后class_addMethod</li>
<li>protocol != NULL : 获取对应协议方法的类型编码,然后class_addMethod</li>
<li>targetMethod ！= NULL  如果存在对应的方法，但是方法的实现不是objc_msgForward:将原方法的selector指向objc_msgForward，生成一个aliasSelector指向原方法的method实现</li>
</ul>
<p>以上三个部分，最后都实现 class_addMethod(class, selector, objc_msgForward, typeEncoding)</p>
<p>注:上面方法中objc_msgForward实际是_objc_msgForward，因为编写有问题就简化了</p>
<h3 id="RACSignatureForUndefinedSelector"><a href="#RACSignatureForUndefinedSelector" class="headerlink" title="RACSignatureForUndefinedSelector"></a>RACSignatureForUndefinedSelector</h3><p>根据selector生成对应的方法签名类型编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">默认返回self 以及当前方法的选择子 SEL，也就是v@:</span><br><span class="line">根据Apple的参数类型，id类型的对象都用@表示,v表示void,:表示SEL</span><br><span class="line">如果selector中含有参数，拼接@，可见参数都是id类型</span><br><span class="line"></span><br><span class="line">static const char *RACSignatureForUndefinedSelector(SEL selector) &#123;</span><br><span class="line">	const char *name = sel_getName(selector);</span><br><span class="line">	NSMutableString *signature = [NSMutableString stringWithString:@&quot;v@:&quot;];</span><br><span class="line"></span><br><span class="line">	while ((name = strchr(name, &apos;:&apos;)) != NULL) &#123;</span><br><span class="line">		[signature appendString:@&quot;@&quot;];</span><br><span class="line">		name++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return signature.UTF8String;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="重点swizzleClass"><a href="#重点swizzleClass" class="headerlink" title="重点swizzleClass"></a>重点swizzleClass</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">static Class RACSwizzleClass(NSObject *self) &#123;</span><br><span class="line">	Class statedClass = self.class;</span><br><span class="line">	Class baseClass = object_getClass(self);//获取self的isa：元类</span><br><span class="line"></span><br><span class="line">	Class knownDynamicSubclass = objc_getAssociatedObject(self, RACSubclassAssociationKey);</span><br><span class="line">	if (knownDynamicSubclass != Nil) return knownDynamicSubclass;</span><br><span class="line"></span><br><span class="line">	NSString *className = NSStringFromClass(baseClass);</span><br><span class="line"></span><br><span class="line">	if (statedClass != baseClass) &#123;</span><br><span class="line"></span><br><span class="line">		@synchronized (swizzledClasses()) &#123;</span><br><span class="line">			if (![swizzledClasses() containsObject:className]) &#123;</span><br><span class="line">				RACSwizzleForwardInvocation(baseClass);</span><br><span class="line">				RACSwizzleRespondsToSelector(baseClass);</span><br><span class="line">				RACSwizzleGetClass(baseClass, statedClass);</span><br><span class="line">				RACSwizzleGetClass(object_getClass(baseClass), statedClass);</span><br><span class="line">				RACSwizzleMethodSignatureForSelector(baseClass);</span><br><span class="line">				[swizzledClasses() addObject:className];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return baseClass;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	const char *subclassName = [className stringByAppendingString:RACSubclassSuffix].UTF8String;</span><br><span class="line">	Class subclass = objc_getClass(subclassName);</span><br><span class="line"></span><br><span class="line">  //生成baseClass对应的子类</span><br><span class="line">	if (subclass == nil) &#123;</span><br><span class="line">		subclass = objc_allocateClassPair(baseClass, subclassName, 0);</span><br><span class="line">		if (subclass == nil) return nil;</span><br><span class="line"></span><br><span class="line">		RACSwizzleForwardInvocation(subclass);</span><br><span class="line">		RACSwizzleRespondsToSelector(subclass);</span><br><span class="line"></span><br><span class="line">		RACSwizzleGetClass(subclass, statedClass);</span><br><span class="line">		RACSwizzleGetClass(object_getClass(subclass), statedClass);</span><br><span class="line"></span><br><span class="line">		RACSwizzleMethodSignatureForSelector(subclass);</span><br><span class="line"></span><br><span class="line">		objc_registerClassPair(subclass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	object_setClass(self, subclass); //修改self为对应的子类，以后消息转发到了子类执行</span><br><span class="line">	objc_setAssociatedObject(self, RACSubclassAssociationKey, subclass, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">	return subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以分为三部分 主要是修改当前类的一些方法实现</p>
<ul>
<li><p>生成子类，然后替换子类的实现方法<br>子类RACDelegateProxy_RACSelectorSignal的class方法返回的对象是当前的类RACDelegateProxy</p>
</li>
<li><p>RACSwizzleForwardInvocation(baseClass);</p>
</li>
<li>RACSwizzleRespondsToSelector(baseClass);</li>
<li>RACSwizzleMethodSignatureForSelector(baseClass);</li>
<li>RACSwizzleGetClass</li>
</ul>
<h3 id="RACSwizzleForwardInvocation"><a href="#RACSwizzleForwardInvocation" class="headerlink" title="RACSwizzleForwardInvocation"></a>RACSwizzleForwardInvocation</h3><p>这是最主要的方法RACSwizzleForwardInvocation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">将当前forwardInvocation实现替换为newForwardInvocation的实现</span><br><span class="line"></span><br><span class="line">static void RACSwizzleForwardInvocation(Class class) &#123;</span><br><span class="line">	SEL forwardInvocationSEL = @selector(forwardInvocation:);</span><br><span class="line">	Method forwardInvocationMethod = class_getInstanceMethod(class, forwardInvocationSEL);</span><br><span class="line"></span><br><span class="line">	// Preserve any existing implementation of -forwardInvocation:.</span><br><span class="line">	void (*originalForwardInvocation)(id, SEL, NSInvocation *) = NULL;</span><br><span class="line">	if (forwardInvocationMethod != NULL) &#123;</span><br><span class="line">		originalForwardInvocation = (__typeof__(originalForwardInvocation))method_getImplementation(forwardInvocationMethod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	id newForwardInvocation = ^(id self, NSInvocation *invocation) &#123;</span><br><span class="line">		BOOL matched = RACForwardInvocation(self, invocation);</span><br><span class="line">		if (matched) return;</span><br><span class="line"></span><br><span class="line">		if (originalForwardInvocation == NULL) &#123;</span><br><span class="line">			[self doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			originalForwardInvocation(self, forwardInvocationSEL, invocation);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	class_replaceMethod(class, forwardInvocationSEL, imp_implementationWithBlock(newForwardInvocation), &quot;v@:@&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static BOOL RACForwardInvocation(id self, NSInvocation *invocation) &#123;</span><br><span class="line">	SEL aliasSelector = RACAliasForSelector(invocation.selector);</span><br><span class="line">	RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);</span><br><span class="line"></span><br><span class="line">	Class class = object_getClass(invocation.target);</span><br><span class="line">	BOOL respondsToAlias = [class instancesRespondToSelector:aliasSelector];</span><br><span class="line">	if (respondsToAlias) &#123;</span><br><span class="line">		invocation.selector = aliasSelector;</span><br><span class="line">		[invocation invoke]; //响应方法的target</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (subject == nil) return respondsToAlias;</span><br><span class="line"></span><br><span class="line">	[subject sendNext:invocation.rac_argumentsTuple];//信号，传参</span><br><span class="line">	return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="RACSwizzleMethodSignatureForSelector"><a href="#RACSwizzleMethodSignatureForSelector" class="headerlink" title="RACSwizzleMethodSignatureForSelector"></a>RACSwizzleMethodSignatureForSelector</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//在方法不存在时，通过 objc_msgSendSuper 调用父类的 -methodSignatureForSelector: 方法获取方法签名。</span><br><span class="line"></span><br><span class="line">static void RACSwizzleMethodSignatureForSelector(Class class) &#123;</span><br><span class="line">	IMP newIMP = imp_implementationWithBlock(^(id self, SEL selector) &#123;</span><br><span class="line"></span><br><span class="line">		Class actualClass = object_getClass(self);</span><br><span class="line">		Method method = class_getInstanceMethod(actualClass, selector);</span><br><span class="line">		if (method == NULL) &#123;</span><br><span class="line"></span><br><span class="line">			struct objc_super target = &#123;</span><br><span class="line">				.super_class = class_getSuperclass(class),</span><br><span class="line">				.receiver = self,</span><br><span class="line">			&#125;;</span><br><span class="line">			NSMethodSignature * (*messageSend)(struct objc_super *, SEL, SEL) = (__typeof__(messageSend))objc_msgSendSuper;</span><br><span class="line">			return messageSend(&amp;target, @selector(methodSignatureForSelector:), selector);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		char const *encoding = method_getTypeEncoding(method);</span><br><span class="line">		return [NSMethodSignature signatureWithObjCTypes:encoding];</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	SEL selector = @selector(methodSignatureForSelector:);</span><br><span class="line">	Method methodSignatureForSelectorMethod = class_getInstanceMethod(class, selector);</span><br><span class="line">	class_replaceMethod(class, selector, newIMP, method_getTypeEncoding(methodSignatureForSelectorMethod));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RACSwizzleGetClass"><a href="#RACSwizzleGetClass" class="headerlink" title="RACSwizzleGetClass"></a>RACSwizzleGetClass</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void RACSwizzleGetClass(Class class, Class statedClass) &#123;</span><br><span class="line">	SEL selector = @selector(class);</span><br><span class="line">	Method method = class_getInstanceMethod(class, selector);</span><br><span class="line">	IMP newIMP = imp_implementationWithBlock(^(id self) &#123;</span><br><span class="line">		return statedClass;</span><br><span class="line">	&#125;);</span><br><span class="line">	class_replaceMethod(class, selector, newIMP, method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br><span class="line">将class的selector(class)实现替换为newIMP，即返回(statedClass)</span><br></pre></td></tr></table></figure>
<p>swizzleGetClass有点疑惑，所以写下code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">有两个类</span><br><span class="line">Cat 继承NSObject</span><br><span class="line">PattyCat 继承Cat</span><br><span class="line"></span><br><span class="line">Class object_getClass(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)wanwan</span><br><span class="line">&#123;</span><br><span class="line">  NSLog(@&quot;PattyCat:%p&quot;,[PattyCat class]); //0x101bfa630</span><br><span class="line">  NSLog(@&quot;Cat:%p&quot;,[Cat class]);           //0x101bfa5e0</span><br><span class="line"></span><br><span class="line">  Class statedClass = PattyCat.class;                  //0x101bfa630</span><br><span class="line">  Class baseClass = object_getClass([PattyCat class]);//0x101bfa608</span><br><span class="line"></span><br><span class="line">  if (statedClass != baseClass) &#123;</span><br><span class="line">      RACSwizzleGetClass(baseClass, statedClass);//hook class方法</span><br><span class="line">      RACSwizzleGetClass(object_getClass(baseClass), statedClass);</span><br><span class="line"></span><br><span class="line">      NSLog(@&quot;PattyCat:%p&quot;,[PattyCat class]); //0x101bfa630</span><br><span class="line">      NSLog(@&quot;Cat:%p&quot;,[Cat class]);           //0x101bfa630</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class实例方法存在NSObject的方法列表，类方法存在NSobject-MetaClass的类列表方法里面，所以RACSwizzleGetClass(baseClass, statedClass);第一次执行的时候，是将baseClass也就是在PattyCat的metaClass寻找类class方法，找不到继续往上找Cat-MetaClass，然后直到NSobject-MetaClass找到了，改变class返回为statedClass</span><br><span class="line"></span><br><span class="line">第二次执行  RACSwizzleGetClass(object_getClass(baseClass), statedClass);，从NSobject-MetaClass类列表方法查找Class方法，找到了返回为statedClass</span><br><span class="line"></span><br><span class="line">所以[PattyCat class]没有变化，返回statedClass的指针</span><br><span class="line">[Cat class]去Cat-MetaClass类列表查找，一直找到NSObject-metaClass找到后发现class返回的是statedClass，所以打印的也是statedClass的指针</span><br></pre></td></tr></table></figure></p>
<p>实际上在了解以上步骤之后，对原来的RACSwizzleClass方法才加以了解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static Class RACSwizzleClass(NSObject *self) &#123;</span><br><span class="line">	Class statedClass = self.class;</span><br><span class="line">	Class baseClass = object_getClass(self);</span><br><span class="line"></span><br><span class="line">	Class knownDynamicSubclass = objc_getAssociatedObject(self, RACSubclassAssociationKey);</span><br><span class="line">	if (knownDynamicSubclass != Nil) return knownDynamicSubclass;</span><br><span class="line"></span><br><span class="line">	NSString *className = NSStringFromClass(baseClass);</span><br><span class="line"></span><br><span class="line">	if (statedClass != baseClass) &#123; //如果当前传进来的self是对象的话，此处不执行</span><br><span class="line">		 ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	const char *subclassName = [className stringByAppendingString:RACSubclassSuffix].UTF8String;</span><br><span class="line">	Class subclass = objc_getClass(subclassName);</span><br><span class="line"></span><br><span class="line">	if (subclass == nil) &#123;</span><br><span class="line">		subclass = objc_allocateClassPair(baseClass, subclassName, 0);//从baseclass处生成子类</span><br><span class="line">		if (subclass == nil) return nil;</span><br><span class="line"></span><br><span class="line">    //替换子类的相应的方法</span><br><span class="line">		RACSwizzleForwardInvocation(subclass);</span><br><span class="line">		RACSwizzleRespondsToSelector(subclass);</span><br><span class="line"></span><br><span class="line">    //从上面的事例可以帮助理解，此处是将子类subclass的class方法返回为statedClass，也就是子类subclass的isa为statedClass</span><br><span class="line">		RACSwizzleGetClass(subclass, statedClass);</span><br><span class="line">		RACSwizzleGetClass(object_getClass(subclass), statedClass);</span><br><span class="line">    //这一步是将子类subclass的metaclass，isa指向statedClass</span><br><span class="line"></span><br><span class="line">		RACSwizzleMethodSignatureForSelector(subclass);</span><br><span class="line"></span><br><span class="line">		objc_registerClassPair(subclass);//注册子类</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	object_setClass(self, subclass);//将当前返回的类修改为子类，这样调用当前的方法会转发到子类去执行，但是为外部来说，返回的class还是statedClass也就是原来的类</span><br><span class="line">	objc_setAssociatedObject(self, RACSubclassAssociationKey, subclass, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">	return subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>strchr 是C函数，原型为<code>extern char *strchr(const char *s,char c)</code><br>可以查找出字符串s中首次出现c的位置，如果没找到，返回NULL</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RACDelegateProxy 使用消息信号的形式监听所有的代理方法，可以用 block 的形式去代替原有的方法，为我们帮助简化代码。</p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/01/15/Objc消息的发送和查找/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/15/Objc消息的发送和查找/" itemprop="url">Objc消息的发送和查找</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-15T14:17:14+08:00">
                2018-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本Objc系列的文章，都是笔者在学习的阶段，翻阅他人笔记，自己查看源码记录以加深印象，并非全部原创</p>
<blockquote>
<p>本文直接运行的是runtime Objc4-706版本，debug-objc的target，mac运行</p>
</blockquote>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>在main.m中实现如下代码，添加断点查看XXObject调用hello方法的执行流程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;objc-runtime.h&quot;</span><br><span class="line">@interface XXObject: NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation XXObject</span><br><span class="line">- (void)hello</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        XXObject *obj = [[XXObject alloc] init];</span><br><span class="line">        [obj hello];//lldb  p (void *)@selector(hello) 方法也是在编译期间地址就确定了</span><br><span class="line">                    //lldb  (void *) $1 = 0x0000000100000f9c</span><br><span class="line">        [obj hello];//已经缓存过，直接从缓存取，走的是汇编代码，断点直接到方法实现了</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/Objc消息缓存查找.png" alt="Objc消息缓存查找流程"></p>
<p>方法先是通过 objc_msgSend_uncached去查找是否有方法的缓存，这个时候断点都没有走到，可见在编译阶段就可以去查找方法的缓存了，也就是说方法的地址在编译期间就已经确定了，和类在内存中的地址是一样的，下面去验证这一说法的正确性</p>
<p>点进去可以看到，是使用的汇编语言执行的，以此来提高查找速度<br>在主函数中，任意断点处，打印lldb<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (void *)@selector(hello)</span><br><span class="line">(void *) $1 = 0x0000000100000f8c</span><br><span class="line">(lldb) p (void *)@selector(undefined_hello)</span><br><span class="line">(void *) $2 = 0x000000010290ced0</span><br></pre></td></tr></table></figure></p>
<p>可见在代码中，没有显示的申明方法undefined_hello，导致内存地址和已经申明的方法hello还是有些差距的，undefined_hello选择子是在运行时确定的，因此再次显示申明一次方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main.m</span><br><span class="line">  __unused SEL sel = @selector(undefined_hello);</span><br><span class="line">  XXObject *obj = [[XXObject alloc] init];</span><br><span class="line">  [obj hello];</span><br><span class="line"></span><br><span class="line">lldb打印</span><br><span class="line">(lldb) p (void *)@selector(hello)</span><br><span class="line">(void *) $0 = 0x0000000100000f8c</span><br><span class="line">(lldb) p (void *)@selector(undefined_hello)</span><br><span class="line">(void *) $1 = 0x0000000100000f92</span><br></pre></td></tr></table></figure></p>
<p>两个选择子内存地址已经想差不大了<br>由此可以得出猜测:<br>1.通过@selector打印选择子的地址，而不是通过hello方法的内存地址，可见在OC中有一份巨大的选择子表<br>2.只需要传入sel的name,就可以去查找对应的选择子内存地址，如果没有找到，就会自动生成一个SEL并插入到表中<br>3.在编译期间就可以把所有的头文件和实现文件中的方法和@selector()方式调用的sel都插入到表中</p>
<p>在init方法执行前，打断点<br><img src="/images/Objc选择子地址.png" alt="Objc选择子地址"><br>打印选择子hello的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p SEL(0x0000000100000f8c)</span><br><span class="line">(SEL) $2 = &quot;hello&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="msgSend"><a href="#msgSend" class="headerlink" title="msgSend"></a>msgSend</h2><p>具体方法 OBJC_EXPORT id objc_msgSend(id self, SEL op, …)没有实现方法，是汇编语言实现的具体实现</p>
<p>当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个 objc_msgSend、objc_msgSend_stret、objc_msgSendSuper 和 objc_msgSendSuper_stret。<br>发送给对象的父类的消息会使用 objc_msgSendSuper 有数据结构作为返回值的方法会使用 objc_msgSendSuper_stret 或 objc_msgSend_stret 其它的消息都是使用 objc_msgSend 发送的</p>
<p>现在看下整个的主流程，在调用hello方法的地方，打上断点之后，<br>整个流程中，没有找到方法缓存时，会通过调用lookUpImpOrForward查找方法的实现，打开这个函数的断点，<br>lookUpImpOrForward这个函数主要做的事情如下:</p>
<ul>
<li>查找缓存中是否存在方法的实现</li>
<li>如果类没有初始化完成，就会去分配正确的可读写结构体</li>
<li>当前类和父类中查找方法实现</li>
<li>方法决议</li>
</ul>
<ol>
<li><p>查找缓存<br>由于参数传入cache为NO,这里其实是不执行的，在汇编objc_msgSend_uncached已经做了缓存处理了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (cache) &#123; //缓存中查找</span><br><span class="line">      imp = cache_getImp(cls, sel);</span><br><span class="line">      if (imp) return imp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类初始化和实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> if (!cls-&gt;isRealized()) &#123;</span><br><span class="line">     rwlock_writer_t lock(runtimeLock);</span><br><span class="line">     realizeClass(cls);//为类分配可读写结构体 class_rw_t 的空间，并返回正确的类结构体。</span><br><span class="line"> &#125;</span><br><span class="line"> if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">    _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在当前类中查找，如果查找到了跳转done，否则去当前类查找search_method_list，查找到了调用log_and_fill_cache缓存该方法并跳转done</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">imp = cache_getImp(cls, sel);</span><br><span class="line">if (imp) goto done;</span><br><span class="line"></span><br><span class="line">// Try this class&apos;s method lists.</span><br><span class="line"></span><br><span class="line">meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">if (meth) &#123;</span><br><span class="line">    log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">    imp = meth-&gt;imp;</span><br><span class="line">    goto done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>去父类中查找方法，流程和3原理一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">curClass = cls;</span><br><span class="line">  while ((curClass = curClass-&gt;superclass)) &#123;</span><br><span class="line">      // Superclass cache.</span><br><span class="line">      imp = cache_getImp(curClass, sel);</span><br><span class="line">      if (imp) &#123;</span><br><span class="line">          if (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">              log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">              goto done;</span><br><span class="line">          &#125;</span><br><span class="line">          else &#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Superclass method list.</span><br><span class="line">      meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">      if (meth) &#123;</span><br><span class="line">          log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">          imp = meth-&gt;imp;</span><br><span class="line">          goto done;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">与当前类寻找实现的区别是：在父类中寻找到的 _objc_msgForward_impcache 实现会交给当前类来处理。</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法决议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//在当前类和父类都没有找到对应的实现</span><br><span class="line">//判断当前类是否实现了 resolveInstanceMethod: 或者 resolveClassMethod: 方法，然后用objc_msgSend 执行sel，缓存方法</span><br><span class="line"></span><br><span class="line">if (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line">    _class_resolveMethod(cls, sel, inst);</span><br><span class="line">    // Don&apos;t cache the result; we don&apos;t hold the lock so it may have</span><br><span class="line">    // changed already. Re-do the search from scratch instead.</span><br><span class="line">    triedResolver = YES;</span><br><span class="line">    goto retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这部分调用_class_resolveMethod实现</p>
<p>//如果当前类不是元类，调用_class_resolveInstanceMethod实现<br>否则，调用_class_resolveClassMethod<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    if (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        // try [cls resolveInstanceMethod:sel]</span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // try [nonMetaClass resolveClassMethod:sel]</span><br><span class="line">        // and [cls resolveInstanceMethod:sel]</span><br><span class="line"></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        if (!lookUpImpOrNil(cls, sel, inst,</span><br><span class="line">                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/))</span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在执行了 resolveInstanceMethod: 之后，会跳转到 retry 标签，重新执行查找方法实现的流程，只不过不会再调用 resolveInstanceMethod: 方法了（将 triedResolver 标记为 YES）</p>
<ol>
<li>消息转发<br>当在缓存，当前类，父类，resolveInstanceMethod都没有实现，则还有最后一步，消息转发<br>执行完后进行方法的缓存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">   cache_fill(cls, sel, imp, inst);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="方法缓存之后再次执行同方法"><a href="#方法缓存之后再次执行同方法" class="headerlink" title="方法缓存之后再次执行同方法"></a>方法缓存之后再次执行同方法</h2><p>上面例子中，如果执行两次相同的方法hello<br>在第二次hello方法执行行 打上断点，然后在lookUpImpOrForward这个函数第一行打上断点，发现并没有进入，可见已经在缓存中查找到了方法并执行，这一步直接在汇编实现了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)[XXObject class]</span><br><span class="line">(objc_class *) $0 = 0x0000000100001480</span><br><span class="line">(lldb) p (cache_t *)0x0000000100001490</span><br><span class="line">(cache_t *) $1 = 0x0000000100001490</span><br><span class="line">(lldb) p *$1</span><br><span class="line">(cache_t) $2 = &#123;</span><br><span class="line">  _buckets = 0x0000000101905b50</span><br><span class="line">  _mask = 3</span><br><span class="line">  _occupied = 2</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $2.capacity()</span><br><span class="line">(mask_t) $3 = 4</span><br><span class="line">(lldb) p $2.buckets()[0]</span><br><span class="line">(bucket_t) $4 = &#123;</span><br><span class="line">  _key = 0</span><br><span class="line">  _imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $2.buckets()[1]</span><br><span class="line">(bucket_t) $5 = &#123;</span><br><span class="line">  _key = 4303608373</span><br><span class="line">  _imp = 0x00000001003459e0 (libobjc.A.dylib`::-[NSObject init]() at NSObject.mm:2312)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $2.buckets()[2]</span><br><span class="line">(bucket_t) $6 = &#123;</span><br><span class="line">  _key = 4294971205</span><br><span class="line">  _imp = 0x0000000100000b30 (debug-objc`-[XXObject hello] at main.m:84)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $2.buckets()[3]</span><br><span class="line">(bucket_t) $7 = &#123;</span><br><span class="line">  _key = 0</span><br><span class="line">  _imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意上面的XXObject类的指针和缓存的方法列表结构体指针有偏移，是不一样，偏移16<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p sizeof(Class)</span><br><span class="line">(unsigned long) $8 = 8</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>因为objc_Class继承自objc_Object，所以在cache_t对象之前还有一个隐藏的ISA和superClass，<br>所以cache_t相对偏移16</p>
<p>以上可以获取到类XXObject的cache_t结构体中所有缓存过的方法列表，通过赋值清除方法缓存<br>类似使用如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) expr $2.buckets()[2] = $2.buckets()[1]</span><br><span class="line">(bucket_t) $8 = &#123;</span><br><span class="line">  _key = 0</span><br><span class="line">  _imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后再次调用hello方法，可以预料到方法再次通过lookUpImpOrForward函数去查找方法实现</p>
<h2 id="类方法存储"><a href="#类方法存储" class="headerlink" title="类方法存储"></a>类方法存储</h2><p>这里又做了个小测试，测试类方法存储<br>PattyCat类写了个类方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (void)eat</span><br></pre></td></tr></table></figure></p>
<p>在objc_init方法处打上断点，查看当前类的元类，在编译的时候所存储的方法列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p [PattyCat class]</span><br><span class="line">(Class) $0 = PattyCat</span><br><span class="line">(lldb) p (objc_class *)$0</span><br><span class="line">(objc_class *) $2 = 0x00000001000014c0</span><br><span class="line">(lldb) p (object_getClass([PattyCat class]))</span><br><span class="line">(Class) $3 = 0x0000000100001498</span><br><span class="line">(lldb)</span><br><span class="line"></span><br><span class="line">(lldb) p (objc_class *)0x0000000100001498</span><br><span class="line">(objc_class *) $0 = 0x0000000100001498</span><br><span class="line">(lldb)  p (class_data_bits_t *)0x00000001000014b8</span><br><span class="line">(class_data_bits_t *) $1 = 0x00000001000014b8</span><br><span class="line">(lldb) p $1-&gt;data()</span><br><span class="line">warning: could not find Objective-C class data in the process. This may reduce the quality of type information available.</span><br><span class="line">(class_rw_t *) $2 = 0x0000000100001290</span><br><span class="line">(lldb) p (class_ro_t *)$2</span><br><span class="line">(class_ro_t *) $3 = 0x0000000100001290</span><br><span class="line">(lldb) p *$3</span><br><span class="line">(class_ro_t) $4 = &#123;</span><br><span class="line">  flags = 389</span><br><span class="line">  instanceStart = 40</span><br><span class="line">  instanceSize = 40</span><br><span class="line">  reserved = 0</span><br><span class="line">  ivarLayout = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  name = 0x0000000100000f34 &quot;PattyCat&quot;</span><br><span class="line">  baseMethodList = 0x0000000100001270</span><br><span class="line">  baseProtocols = 0x0000000000000000</span><br><span class="line">  ivars = 0x0000000000000000</span><br><span class="line">  weakIvarLayout = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  baseProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p (method_list_t *)0x0000000100001270</span><br><span class="line">(method_list_t *) $6 = 0x0000000100001270</span><br><span class="line">(lldb) p *$6</span><br><span class="line">(method_list_t) $7 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 1</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;eat&quot;</span><br><span class="line">      types = 0x0000000100000f8c &quot;v16@0:8&quot; //这里可以看到，在编译的时候，已经存储好了类方法eat，存储在元类中</span><br><span class="line">      imp = 0x0000000100000b20 (debug-objc`+[PattyCat eat] at main.m:88)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">2018-02-01 15:54:27.808594+0800 debug-objc[14086:176179] I can eat</span><br><span class="line">(lldb) p sizeof(cache_t)</span><br><span class="line">(unsigned long) $8 = 16</span><br><span class="line">(lldb) p (cache_t *)0x00000001000014a8  在执行完[PattyCat class]方法时候，打印元类的缓存方法，查看class是否从NSObjetc的元类方法copy的</span><br><span class="line">(cache_t *) $11 = 0x00000001000014a8</span><br><span class="line">(lldb) p *$11</span><br><span class="line">(cache_t) $12 = &#123;</span><br><span class="line">  _buckets = 0x0000000100c450e0</span><br><span class="line">  _mask = 3</span><br><span class="line">  _occupied = 3</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p (bucket_t *)0x0000000100c450e0</span><br><span class="line">(bucket_t *) $13 = 0x0000000100c450e0</span><br><span class="line">(lldb) p *$13</span><br><span class="line">(bucket_t) $14 = &#123;</span><br><span class="line">  _key = 4303608336</span><br><span class="line">  _imp = 0x0000000100343b50 (libobjc.A.dylib`::+[NSObject class]() at NSObject.mm:1988) //此处可以证明类的class方法是从NSObject的类方法class拷贝得到的哈哈哈</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了提高消息传递的效率，ObjC 对 objc_msgSend 以及 cache_getImp 使用了汇编语言来编写。</p>
<p>objc_msgSend的汇编文件在objc-msg-arm.s中</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://github.com/Draveness/analyze/blob/master/contents/objc/%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9C%8B%20ObjC%20%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81.md" target="_blank" rel="noopener">https://github.com/Draveness/analyze/blob/master/contents/objc/%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9C%8B%20ObjC%20%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81.md</a></p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/01/13/Objc initialize的分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/Objc initialize的分析/" itemprop="url">Objc initialize的分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T14:04:50+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本Objc系列的文章，都是笔者在学习的阶段，翻阅他人笔记，自己查看源码记录以加深印象，并非全部原创</p>
<blockquote>
<p>本文直接运行的是runtime Objc4-706版本，debug-objc的target，mac运行，</p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先来看下源码，在main.m中添加代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface XXObject: NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation XXObject</span><br><span class="line"></span><br><span class="line">+ (void)initialize</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;XXObject initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序，发现没有任何打印log<br><img src="/images/initialize的打印.png" alt="initialize的打印"></p>
<p>和load方法不同，load方法运行还是有打印的，这是为什么呢？？</p>
<p>如果运行以下code,将会看到断点执行和log<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        __unused XXObject *object = [[XXObject alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/initialize的打印2.png" alt="initialize的打印2"></p>
<p>由此可见，虽然没有显式调用initialize方法，但是还是打印了log</p>
<blockquote>
<p>initialize方法是在该类第一次调用方法的时候才会执行</p>
</blockquote>
<p>在方法调用栈里，可以查看到方法调用的顺序，首先_objc_msgSend_uncached，先从方法的缓存里面查找该对应的方法，找不到了，然后从lookUpImpOrForward方法去查找.<br><img src="/images/initialize_lookupImg.png" alt="initialize_lookupImg"><br>在上图的调用栈里，打印 p sel 打印当前的选择子，发现log输出的是alloc,也就是当前调用的是alloc方法，可见initialize方法调用在alloc之前,alloc的调用导致了方法initialize的执行</p>
<p>下面再看 class_initialize方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    bool reallyInitialize = NO;</span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls); //初始化父类</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Try to atomically set CLS_INITIALIZING.</span><br><span class="line">    &#123;</span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">            cls-&gt;setInitializing(); //设置标志位</span><br><span class="line">            reallyInitialize = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (reallyInitialize) &#123; //如果成功设置标志位,初始化 callInitialize(cls)</span><br><span class="line"></span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: calling +[%s initialize]&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @try &#123;</span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: finished +[%s initialize]&quot;,</span><br><span class="line">                             cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @catch (...) &#123;</span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: +[%s initialize] threw an exception&quot;,</span><br><span class="line">                             cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            @throw;</span><br><span class="line">        &#125;</span><br><span class="line">        @finally &#123;</span><br><span class="line">            monitor_locker_t lock(classInitLock);</span><br><span class="line">            if (!supercls  ||  supercls-&gt;isInitialized()) &#123;</span><br><span class="line">                _finishInitializing(cls, supercls);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                _finishInitializingAfter(cls, supercls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法的主要执行流程:</p>
<ul>
<li>如果存在父类，先初始化父类</li>
<li>加锁，设置初始化RW_INITIALIZING标志，</li>
<li>向当前类发送执行initialize方法</li>
<li>设置标志位RW_INITIALIZED完成<br>如果父类已经初始化完成，调用_finishInitializing<br>否则调用_finishInitializingAfter在父类初始化结束之后设置完成标志</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void _finishInitializing(Class cls, Class supercls)</span><br><span class="line">&#123;</span><br><span class="line">    PendingInitialize *pending;</span><br><span class="line"></span><br><span class="line">    classInitLock.assertLocked();</span><br><span class="line">    assert(!supercls  ||  supercls-&gt;isInitialized());</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    cls-&gt;setInitialized();</span><br><span class="line">    classInitLock.notifyAll();</span><br><span class="line">    _setThisThreadIsNotInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">    // mark any subclasses that were merely waiting for this class</span><br><span class="line">    if (!pendingInitializeMap) return;</span><br><span class="line">    pending = (PendingInitialize *)NXMapGet(pendingInitializeMap, cls);</span><br><span class="line">    if (!pending) return;</span><br><span class="line"></span><br><span class="line">    NXMapRemove(pendingInitializeMap, cls);</span><br><span class="line"></span><br><span class="line">    // Destroy the pending table if it&apos;s now empty, to save memory.</span><br><span class="line">    if (NXCountMapTable(pendingInitializeMap) == 0) &#123;</span><br><span class="line">        NXFreeMapTable(pendingInitializeMap);</span><br><span class="line">        pendingInitializeMap = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (pending) &#123;</span><br><span class="line">        PendingInitialize *next = pending-&gt;next;</span><br><span class="line">        if (pending-&gt;subclass) _finishInitializing(pending-&gt;subclass, cls);</span><br><span class="line">        free(pending);</span><br><span class="line">        pending = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">由于父类已经完成了初始化，在这里直接将当前类标记成已经初始化，然后递归地将被当前类 block 的子类标记为已初始化，再把这些类移除 pendingInitializeMap。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void _finishInitializingAfter(Class cls, Class supercls)</span><br><span class="line">&#123;</span><br><span class="line">    PendingInitialize *pending;</span><br><span class="line"></span><br><span class="line">    classInitLock.assertLocked();</span><br><span class="line">    ...</span><br><span class="line">    if (!pendingInitializeMap) &#123;</span><br><span class="line">        pendingInitializeMap =</span><br><span class="line">            NXCreateMapTable(NXPtrValueMapPrototype, 10);</span><br><span class="line">        // fixme pre-size this table for CF/NSObject +initialize</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pending = (PendingInitialize *)malloc(sizeof(*pending));</span><br><span class="line">    pending-&gt;subclass = cls;</span><br><span class="line">    pending-&gt;next = (PendingInitialize *)</span><br><span class="line">        NXMapGet(pendingInitializeMap, supercls);</span><br><span class="line">    NXMapInsert(pendingInitializeMap, supercls, pending);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">首先创建一个pending,然后将当前类作为子类继承，插入到map表</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下关于initialize方法的特性：</p>
<ul>
<li>initialize 的调用是惰性的，它会在第一次调用当前类的方法时被调用</li>
<li>与load 不同，initialize 方法调用时，所有的类都已经加载到了内存中</li>
<li>initialize 的运行是线程安全的</li>
<li>子类会继承父类的 initialize 方法</li>
<li>而其作用也非常局限，一般我们只会在 initialize 方法中进行一些常量的初始化。</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/flower.jpg"
               alt="Patty" />
          <p class="site-author-name" itemprop="name">Patty</p>
           
              <p class="site-description motion-element" itemprop="description">Life's like a movie, write your own ending, keep believing, keep pretending.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Patty</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_uv">
  本站总访问量<span id="busuanzi_value_site_uv"></span>次
</span>
<span class="post-count"> 博客全站共52.6k字</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
