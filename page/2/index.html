<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, Patty" />





  <link rel="alternate" href="/atom.xml" title="温暖的弦" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Life&apos;s like a movie, write your own ending, keep believing, keep pretending.">
<meta property="og:type" content="website">
<meta property="og:title" content="温暖的弦">
<meta property="og:url" content="https://pattyxp.github.io/page/2/index.html">
<meta property="og:site_name" content="温暖的弦">
<meta property="og:description" content="Life&apos;s like a movie, write your own ending, keep believing, keep pretending.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="温暖的弦">
<meta name="twitter:description" content="Life&apos;s like a movie, write your own ending, keep believing, keep pretending.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://pattyxp.github.io/page/2/"/>





  <title>温暖的弦</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">温暖的弦</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/03/15/ReactiveObjc-RACSequence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/15/ReactiveObjc-RACSequence/" itemprop="url">ReactiveObjc-RACSequence</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-15T15:12:30+08:00">
                2018-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文源码为 ReactiveObjc 3.1.0 版本</p>
<h2 id="RACSequence"><a href="#RACSequence" class="headerlink" title="RACSequence"></a>RACSequence</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACSequence</span>&lt;<span class="title">__covariant</span> <span class="title">ValueType</span>&gt; : <span class="title">RACStream</span> &lt;<span class="title">NSCoding</span>, <span class="title">NSCopying</span>, <span class="title">NSFastEnumeration</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) ValueType head;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) RACSequence&lt;ValueType&gt; *tail;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;ValueType&gt; *array;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSEnumerator</span>&lt;ValueType&gt; *objectEnumerator;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;ValueType&gt; *eagerSequence;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;ValueType&gt; *lazySequence;</span><br></pre></td></tr></table></figure>
<p>RACSequence 主要由两部分组成， head 和 tail, head是一个 数字， tail 是 流RACSequence 的形式</p>
<p>先来了解下 RACSequence 相关的子类<br><img src="RACSequence子类结构图.png" alt="RACSequence子类结构图"></p>
<blockquote>
<p>此图来自 <img src="https://github.com/Draveness/analyze/blob/43d828b6f516a57e12eeff69913ff49cc94a0f36/contents/ReactiveObjC/RACSequence.md" alt="Draveness博客"></p>
</blockquote>
<p>这里，和RACSignal类似，获取 head 和 tail 的方法需要被子类重写<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)head &#123;</span><br><span class="line">	<span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"%s must be overridden by subclasses"</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSequence *)tail &#123;</span><br><span class="line">	<span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"%s must be overridden by subclasses"</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>empty<br>返回 RACEmptySequence 实例</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSequence *)empty &#123;</span><br><span class="line">	<span class="keyword">return</span> RACEmptySequence.empty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>return<br>返回 RACUnarySequence 实例，将传入的参数作为 head，tail 返回 nil</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSequence *)<span class="keyword">return</span>:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">	<span class="keyword">return</span> [RACUnarySequence <span class="keyword">return</span>:value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (RACUnarySequence *)<span class="keyword">return</span>:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">	RACUnarySequence *sequence = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">	sequence.head = value;</span><br><span class="line">	<span class="keyword">return</span> [sequence setNameWithFormat:<span class="string">@"+return: %@"</span>, RACDescription(value)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark RACSequence</span></span><br><span class="line"></span><br><span class="line">- (RACSequence *)tail &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>bind</p>
</li>
</ul>
<p>调用内部 bind:passingThroughValuesFromSequence:方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (RACSequence *)bind:(RACSequenceBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">	RACSequenceBindBlock bindBlock = block();</span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> bind:bindBlock passingThroughValuesFromSequence:<span class="literal">nil</span>] setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSequence *)bind:(RACSequenceBindBlock)bindBlock passingThroughValuesFromSequence:(RACSequence *)passthroughSequence &#123;</span><br><span class="line"></span><br><span class="line">	__block RACSequence *valuesSeq = <span class="keyword">self</span>;</span><br><span class="line">	__block RACSequence *current = passthroughSequence;</span><br><span class="line">	__block <span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">	RACSequence *sequence = [RACDynamicSequence sequenceWithLazyDependency:^ <span class="keyword">id</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (current.head == <span class="literal">nil</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stop) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">id</span> value = valuesSeq.head;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (value == <span class="literal">nil</span>) &#123;</span><br><span class="line">				stop = <span class="literal">YES</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			current = (<span class="keyword">id</span>)bindBlock(value, &amp;stop);</span><br><span class="line">			<span class="keyword">if</span> (current == <span class="literal">nil</span>) &#123;</span><br><span class="line">				stop = <span class="literal">YES</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			valuesSeq = valuesSeq.tail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">NSCAssert</span>([current isKindOfClass:RACSequence.class], <span class="string">@"-bind: block returned an object that is not a sequence: %@"</span>, current);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">	&#125; headBlock:^(<span class="keyword">id</span> _) &#123;</span><br><span class="line">		<span class="keyword">return</span> current.head;</span><br><span class="line">	&#125; tailBlock:^ <span class="keyword">id</span> (<span class="keyword">id</span> _) &#123;</span><br><span class="line">		<span class="keyword">if</span> (stop) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> [valuesSeq bind:bindBlock passingThroughValuesFromSequence:current.tail];</span><br><span class="line">	&#125;];</span><br><span class="line"></span><br><span class="line">	sequence.name = <span class="keyword">self</span>.name;</span><br><span class="line">	<span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>内部创建 RACDynamicSequence 实例返回</p>
<p>创建RACDynamicSequence</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSequence *)sequenceWithLazyDependency:(<span class="keyword">id</span> (^)(<span class="keyword">void</span>))dependencyBlock headBlock:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> dependency))headBlock tailBlock:(RACSequence *(^)(<span class="keyword">id</span> dependency))tailBlock &#123;</span><br><span class="line">  ...</span><br><span class="line">	RACDynamicSequence *seq = [[RACDynamicSequence alloc] init];</span><br><span class="line">	seq.headBlock = [headBlock <span class="keyword">copy</span>];</span><br><span class="line">	seq.tailBlock = [tailBlock <span class="keyword">copy</span>];</span><br><span class="line">	seq.dependencyBlock = [dependencyBlock <span class="keyword">copy</span>];</span><br><span class="line">	seq.hasDependency = <span class="literal">YES</span>;</span><br><span class="line">	<span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建好 RACDynamicSequence 之后，获取 head</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)head &#123;</span><br><span class="line">	<span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">		<span class="keyword">id</span> untypedHeadBlock = <span class="keyword">self</span>.headBlock;</span><br><span class="line">		<span class="keyword">if</span> (untypedHeadBlock == <span class="literal">nil</span>) <span class="keyword">return</span> _head;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">self</span>.hasDependency) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">self</span>.dependencyBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">				_dependency = <span class="keyword">self</span>.dependencyBlock();</span><br><span class="line">				<span class="keyword">self</span>.dependencyBlock = <span class="literal">nil</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">id</span> (^headBlock)(<span class="keyword">id</span>) = untypedHeadBlock;</span><br><span class="line">			_head = headBlock(_dependency);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">id</span> (^headBlock)(<span class="keyword">void</span>) = untypedHeadBlock;</span><br><span class="line">			_head = headBlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">self</span>.headBlock = <span class="literal">nil</span>;</span><br><span class="line">		<span class="keyword">return</span> _head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么这里获取head之后，将headBlock 、dependencyBlock 均清空了下次怎么办<br>解惑:<br>第一次获取head时候，如果已经获取到，headBlock 、dependencyBlock  清空<br>第二次获取head时候，headBlock 已经为空，所以直接返回第一次获取的结果，不需要再次赋值</p>
</blockquote>
<p>获取tail,和 head 获取方法同理<br>获取的 tail 依赖 tailBlock 和 dependencyBlock, 最后返回的tail 执行返回 RACSequence对象<br><code>return [valuesSeq bind:bindBlock passingThroughValuesFromSequence:current.tail];</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (RACSequence *)tail &#123;</span><br><span class="line">	<span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">		<span class="keyword">id</span> untypedTailBlock = <span class="keyword">self</span>.tailBlock;</span><br><span class="line">		<span class="keyword">if</span> (untypedTailBlock == <span class="literal">nil</span>) <span class="keyword">return</span> _tail;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">self</span>.hasDependency) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">self</span>.dependencyBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">				_dependency = <span class="keyword">self</span>.dependencyBlock();</span><br><span class="line">				<span class="keyword">self</span>.dependencyBlock = <span class="literal">nil</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			RACSequence * (^tailBlock)(<span class="keyword">id</span>) = untypedTailBlock;</span><br><span class="line">			_tail = tailBlock(_dependency);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			RACSequence * (^tailBlock)(<span class="keyword">void</span>) = untypedTailBlock;</span><br><span class="line">			_tail = tailBlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (_tail.name == <span class="literal">nil</span>) _tail.name = <span class="keyword">self</span>.name;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">self</span>.tailBlock = <span class="literal">nil</span>;</span><br><span class="line">		<span class="keyword">return</span> _tail;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面通过更具体的代码来了解bind方法使用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *sequence = [RACSequence sequenceWithHeadBlock:^<span class="keyword">id</span> _Nullable&#123;</span><br><span class="line">    <span class="keyword">return</span> @<span class="number">1</span>;</span><br><span class="line">&#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">    <span class="keyword">return</span>  [RACSequence sequenceWithHeadBlock:^<span class="keyword">id</span> _Nullable&#123;</span><br><span class="line">        <span class="keyword">return</span> @<span class="number">2</span>;</span><br><span class="line">    &#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">        <span class="keyword">return</span> [RACSequence <span class="keyword">return</span>:@<span class="number">3</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSequence *bindSequence = [sequence bind:^RACSequenceBindBlock _Nonnull&#123;</span><br><span class="line">    <span class="keyword">return</span> ^(<span class="built_in">NSNumber</span> *value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"RACSequenceBindBlock: %@"</span>, value);</span><br><span class="line">        value = @(value.integerValue * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> [RACSequence <span class="keyword">return</span>:value];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"BindSequence:  head=(%@) tail=(%@)"</span>, bindSequence.head, bindSequence.tail);</span><br></pre></td></tr></table></figure></p>
<p>log 获取的 head 有值，获取的 tail 是 RACSequence对象，值暂时都是unresolved<br><code>BindSequence:  head=(2) tail=(&lt;RACDynamicSequence: 0x600000098560&gt;{ name = , head = (unresolved), tail = (unresolved) })</code></p>
<p>上面的流程中，执行bind方法的block是惰性的， 只有在获取 RACSequence 对象的head以及tail的时候才会执行 LazyDependency,在 LazyDependency内部将value 执行bindBlock(value, &amp;stop),返回 RACUnarySequence 对象 最后通过head属性取出值</p>
<blockquote>
<p>注意:<br>在整个 ReactiveCocoa 中，所有的 RACSequence 对象在默认情况下都是惰性的，序列中的值只有在真正需要使用时才会被展开，在其他时间都是 unresolved。</p>
</blockquote>
<ul>
<li>lazySequence 和 eagerSequence</li>
</ul>
<p>打印下上面例子的这两个属性值<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *sequence = [RACSequence sequenceWithHeadBlock:^<span class="keyword">id</span> _Nullable&#123;</span><br><span class="line">       <span class="keyword">return</span> @<span class="number">1</span>;</span><br><span class="line">   &#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">       <span class="keyword">return</span>  [RACSequence sequenceWithHeadBlock:^<span class="keyword">id</span> _Nullable&#123;</span><br><span class="line">           <span class="keyword">return</span> @<span class="number">2</span>;</span><br><span class="line">       &#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">           <span class="keyword">return</span> [RACSequence <span class="keyword">return</span>:@<span class="number">3</span>];</span><br><span class="line">       &#125;];</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   RACSequence *bindSequence = [sequence bind:^RACSequenceBindBlock _Nonnull&#123;</span><br><span class="line">       <span class="keyword">return</span> ^(<span class="built_in">NSNumber</span> *value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"RACSequenceBindBlock: %@"</span>, value);</span><br><span class="line">           value = @(value.integerValue * <span class="number">2</span>);</span><br><span class="line">           <span class="keyword">return</span> [RACSequence <span class="keyword">return</span>:value];</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"BindSequence: lazySequence=(%@)"</span>, bindSequence.lazySequence);</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"BindSequence: eagerSequence=(%@)"</span>, bindSequence.eagerSequence);</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"BindSequence: lazySequence=(%@)"</span>, bindSequence.lazySequence);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BindSequence: lazySequence=(&lt;RACDynamicSequence: 0x6000000971b0&gt;&#123; name = , head = (unresolved), tail = (unresolved) &#125;)</span><br><span class="line">BindSequence: eagerSequence=(&lt;RACEagerSequence: 0x600000223ec0&gt;&#123; name = , array = (</span><br><span class="line">    2,</span><br><span class="line">    4,</span><br><span class="line">    6</span><br><span class="line">) &#125;)</span><br><span class="line">BindSequence: lazySequence=(&lt;RACDynamicSequence: 0x6000000971b0&gt;&#123; name = , head = 2, tail = &lt;RACDynamicSequence: 0x600000095040&gt;&#123; name = , head = 4, tail = &lt;RACDynamicSequence: 0x6040000939c0&gt;&#123; name = , head = 6, tail = (null) &#125; &#125; &#125;)</span><br></pre></td></tr></table></figure>
<p>可以看到 lazySequence 一开始还是unresolved ，调用 eagerSequence 之后，lazySequence 就不再是 unresolved</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (RACSequence *)lazySequence &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSequence *)eagerSequence &#123;</span><br><span class="line">	<span class="keyword">return</span> [RACEagerSequence sequenceWithArray:<span class="keyword">self</span>.array offset:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RACArraySequence.m</span></span><br><span class="line">+ (RACSequence *)sequenceWithArray:(<span class="built_in">NSArray</span> *)array offset:(<span class="built_in">NSUInteger</span>)offset &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(offset &lt;= array.count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset == array.count) <span class="keyword">return</span> <span class="keyword">self</span>.empty;</span><br><span class="line"></span><br><span class="line">	RACArraySequence *seq = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">	seq-&gt;_backingArray = [array <span class="keyword">copy</span>];</span><br><span class="line">	seq-&gt;_offset = offset;</span><br><span class="line">	<span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eager从字面上也可以了解到，就是提前获取所有的数据</p>
<p>获取eagerSequence方法里面，有个参数<code>self.array</code><br>调用的是RACSequence的方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line">	<span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">		[array addObject:obj];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [array <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印self<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">po self</span><br><span class="line">&lt;RACDynamicSequence: 0x604000095cc0&gt;&#123; name = , head = 2, tail =</span><br><span class="line">&lt;RACDynamicSequence: 0x600000282ee0&gt;&#123; name = , head = 4, tail =</span><br><span class="line">&lt;RACDynamicSequence: 0x600000282ad0&gt;&#123; name = , head = 6, tail = (null) &#125; &#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p>好奇 array的obj是怎么来的，查看调用栈<br>RACSequence 有属性array，遵循协议 NSFastEnumeration ，因此执行forin的时候调用以下方法<br><code>- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id *)stackbuf count:(NSUInteger)len</code><br>该方法遍历获取 self ，通过<br><code>RACSequence *(^getSequence)(void) = ^{
        return (__bridge RACSequence *)(void *)state-&gt;state;
    };</code> 将当前对象内部的每一项state转化为sequence,然后获取head</p>
<ul>
<li>RACSequence 和 RACSignal</li>
</ul>
<p>两者存在区别，但是也可以相互转化</p>
<ul>
<li><p>RACSequence 转化为 RACSignal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *sequence = @[@1,@2,@3].rac_sequence;</span><br><span class="line">RACSignal *signal = sequence.signal;</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;signal: %@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> signal: 1</span><br><span class="line"> signal: 2</span><br><span class="line"> signal: 3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>下面看下具体实现源码</p>
<p>内部是重新创建返回 RACSignal 通过递归调用 RACScheduler block方法，向 RACSubscriber 发送sendNext 直到结束</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  - (RACSignal *)signal &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> signalWithScheduler:[RACScheduler scheduler]] setNameWithFormat:<span class="string">@"[%@] -signal"</span>, <span class="keyword">self</span>.name];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> - (RACSignal *)signalWithScheduler:(RACScheduler *)scheduler &#123;</span><br><span class="line"> 	<span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"> 		__block RACSequence *sequence = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line"> 		<span class="keyword">return</span> [scheduler scheduleRecursiveBlock:^(<span class="keyword">void</span> (^reschedule)(<span class="keyword">void</span>)) &#123;</span><br><span class="line"> 			<span class="keyword">if</span> (sequence.head == <span class="literal">nil</span>) &#123;</span><br><span class="line"> 				[subscriber sendCompleted];</span><br><span class="line"> 				<span class="keyword">return</span>;</span><br><span class="line"> 			&#125;</span><br><span class="line"></span><br><span class="line"> 			[subscriber sendNext:sequence.head];</span><br><span class="line"> 			sequence = sequence.tail;</span><br><span class="line"> 			reschedule();</span><br><span class="line"> 		&#125;];</span><br><span class="line"> 	&#125;] setNameWithFormat:<span class="string">@"[%@] -signalWithScheduler: %@"</span>, <span class="keyword">self</span>.name, scheduler];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RACSignal 转化为 RACSequence</p>
</li>
</ul>
<p>内部创建 RACArraySequence ，收集到发出的所有信号<br>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">      [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">      [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">      [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">      [subscriber sendCompleted];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, signal.toArray.rac_sequence);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   &lt;RACArraySequence: 0x600000222ca0&gt;&#123; name = , array = (</span></span><br><span class="line"><span class="comment">   1,</span></span><br><span class="line"><span class="comment">   2,</span></span><br><span class="line"><span class="comment">   3</span></span><br><span class="line"><span class="comment">   ) &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>Map 、 Filter 、 flattenMap</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array=@[@(<span class="number">2</span>),@(<span class="number">5</span>),@(<span class="number">7</span>),@(<span class="number">15</span>)];</span><br><span class="line">  RACSequence *sequences = [array rac_sequence];</span><br><span class="line">  <span class="keyword">id</span> mapData = [sequences map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">      <span class="keyword">return</span> @([value integerValue] * <span class="number">2</span>);</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"序列Map之后的数据:%@"</span>,[mapData array]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">id</span> filterData = [sequences filter:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">      <span class="keyword">return</span> [value integerValue]%<span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"序列Filter之后的数据:%@"</span>,[filterData array]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  RACSequence *flatmapData = [sequences flattenMap:^__kindof RACSequence * _Nullable(<span class="keyword">id</span>  _Nullable value) &#123;</span><br><span class="line">       <span class="keyword">if</span> ([value integerValue]%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> [RACSequence sequenceWithHeadBlock:^<span class="keyword">id</span> _Nullable&#123;</span><br><span class="line">               <span class="keyword">return</span> value;</span><br><span class="line">           &#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">           &#125;];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> [RACSequence empty];</span><br><span class="line">   &#125;];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"先map再filter之后的数据:%@"</span>, flatmapData.eagerSequence);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">序列Map之后的数据:(</span></span><br><span class="line"><span class="comment">    4,</span></span><br><span class="line"><span class="comment">    10,</span></span><br><span class="line"><span class="comment">    14,</span></span><br><span class="line"><span class="comment">    30</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">序列Filter之后的数据:(</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> &lt;RACEagerSequence: 0x6040002241c0&gt;&#123; name = , array = (</span></span><br><span class="line"><span class="comment"> 2</span></span><br><span class="line"><span class="comment"> ) &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化<br>内部实际返回 RACDynamicSequence 对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSequence *)sequenceWithHeadBlock:(id (^)(void))headBlock tailBlock:(RACSequence&lt;id&gt; *(^)(void))tailBlock &#123;</span><br><span class="line">	return [[RACDynamicSequence sequenceWithHeadBlock:headBlock tailBlock:tailBlock] setNameWithFormat:@&quot;+sequenceWithHeadBlock:tailBlock:&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/03/12/ReactiveObjc入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/ReactiveObjc入门/" itemprop="url">ReactiveObjc入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T17:40:55+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文源码为 ReactiveObjc 3.1.0 版本</p>
<p>ReactiveCocoa 开源已久，实现非常高效，对应OC中各种不同的设计模式，如代理响应，观察者模式，通知等模式的输入，都可以抽象为信号，让组件对自己的行为进行控制，简化控制器的负担。<br>本文作为系列开篇，先介绍最核心的 信号流 RACStream</p>
<p>RACStream 属于抽象类，两个子类分别是 RACSignal 和 RACSequence<br><img src="/images/RACStream大概.png" alt="RAC-stream"></p>
<p>两者虽然都继承自RACStream,拥有父类的很多共同的特性，但是差异在于 推驱动 和 拉驱动的方式</p>
<ul>
<li>RACSignal : 推驱动， 每次当信号中出现新的数据，主动发送给所有的订阅者</li>
<li>RACSequence : 拉驱动，每次出现新的数据，并不会通知当前的订阅对象，而是当订阅者再次需要使用 RACSequence 对象才会去获取最新的数据，由使用者自己去拉取新数据</li>
</ul>
<p>本文先介绍 RACSignal 相关的信息</p>
<h2 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h2><p>RACStream作为抽象类，在实现内部抛出异常</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (__kindof RACStream *)empty &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *reason = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ must be overridden by subclasses"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd)];</span><br><span class="line">	<span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInternalInconsistencyException</span> reason:reason userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (__kindof RACStream *)bind:(RACStreamBindBlock (^)(<span class="keyword">void</span>))block;</span><br><span class="line">+ (__kindof RACStream *)<span class="keyword">return</span>:(<span class="keyword">id</span>)value;</span><br><span class="line">- (__kindof RACStream *)concat:(RACStream *)stream;</span><br><span class="line">- (__kindof RACStream *)zipWith:(RACStream *)stream;</span><br></pre></td></tr></table></figure>
<p>RACStream 需要子类实现这些方法，否则抛出异常<br>RACStream的分类Operations，定义了许多方法，只要子类实现以上的抽象方法，这些分类方法都能使用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">	Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">		<span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">			<span class="keyword">id</span> stream = block(value) ?: [<span class="keyword">class</span> empty];</span><br><span class="line">			<span class="built_in">NSCAssert</span>([stream isKindOfClass:RACStream.class], <span class="string">@"Value returned from -flattenMap: is not a stream: %@"</span>, stream);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> stream;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@"[%@] -flattenMap:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (__kindof RACStream *)flatten</span><br><span class="line">- (__kindof RACStream *)map:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> value))block</span><br><span class="line">- (__kindof RACStream *)mapReplace:(<span class="keyword">id</span>)object</span><br><span class="line">- (__kindof RACStream *)combinePreviousWithStart:(<span class="keyword">id</span>)start reduce:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> previous, <span class="keyword">id</span> next))reduceBlock</span><br><span class="line">- (__kindof RACStream *)filter:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> value))block</span><br><span class="line">- (__kindof RACStream *)ignore:(<span class="keyword">id</span>)value</span><br><span class="line">- (__kindof RACStream *)reduceEach:(RACReduceBlock)reduceBlock</span><br><span class="line">- (__kindof RACStream *)startWith:(<span class="keyword">id</span>)value</span><br><span class="line">- (__kindof RACStream *)skip:(<span class="built_in">NSUInteger</span>)skipCount</span><br><span class="line">- (__kindof RACStream *)take:(<span class="built_in">NSUInteger</span>)count</span><br><span class="line">+ (__kindof RACStream *)join:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)streams block:(RACStream * (^)(<span class="keyword">id</span>, <span class="keyword">id</span>))block</span><br><span class="line">+ (__kindof RACStream *)zip:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)streams</span><br><span class="line">+ (__kindof RACStream *)zip:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)streams reduce:(RACGenericReduceBlock)reduceBlock</span><br><span class="line">+ (__kindof RACStream *)concat:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)streams</span><br><span class="line">- (__kindof RACStream *)scanWithStart:(<span class="keyword">id</span>)startingValue reduce:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> running, <span class="keyword">id</span> next))reduceBlock</span><br><span class="line">- (__kindof RACStream *)scanWithStart:(<span class="keyword">id</span>)startingValue reduceWithIndex:(<span class="keyword">id</span> (^)(<span class="keyword">id</span>, <span class="keyword">id</span>, <span class="built_in">NSUInteger</span>))reduceBlock</span><br><span class="line">- (__kindof RACStream *)takeUntilBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate</span><br><span class="line">- (__kindof RACStream *)takeWhileBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate</span><br><span class="line">- (__kindof RACStream *)skipUntilBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate</span><br><span class="line">- (__kindof RACStream *)skipWhileBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate</span><br><span class="line">- (__kindof RACStream *)distinctUntilChanged</span><br></pre></td></tr></table></figure>
<p>RACSignal继承自RACStream<br>下面简单介绍部分常用的方法，在 RACSignal (RACStream)</p>
<ul>
<li>return<br>通过传入NSObject类型的value,返回RACSignal对象，完成了UIKit -&gt; ReactiveCocoa<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)<span class="keyword">return</span>:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">	<span class="keyword">return</span> [RACReturnSignal <span class="keyword">return</span>:value];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>RACSignal是一个类簇，return 方法虽然返回的是 RACSignal 但是内部实际返回 RACReturnSignal<br>同样的在创建实例时，可能会返回 RACDynamicSignal、RACEmptySignal、RACErrorSignal 和 RACReturnSignal 对象<br>如return方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACReturnSignal.m</span><br><span class="line">+ (RACSignal *)<span class="keyword">return</span>:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">	RACReturnSignal *signal = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">	signal-&gt;_value = value;</span><br><span class="line"></span><br><span class="line"><span class="meta">#ifdef DEBUG</span></span><br><span class="line">	[signal setNameWithFormat:<span class="string">@"+return: %@"</span>, value];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	<span class="keyword">return</span> signal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面结合实例讲解下信号订阅的过程<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposble * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"signal %@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>createSignal 创建信号<br>createSignal 实际返回RACDynamicSignal对象，将block存储在唯一的属性_didSubscribe上</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)createSignal:(RACDisposble * (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line">	RACDynamicSignal *signal = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">	signal-&gt;_didSubscribe = [didSubscribe <span class="keyword">copy</span>];</span><br><span class="line">	<span class="keyword">return</span> [signal setNameWithFormat:<span class="string">@"+createSignal:"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>subscribeNext<br>信号创建之后，调用subscribeNext 返回RACDisposble ，还生成一个 RACSubscriber 对象，向这个对象发送消息 -sendNext: 时，就向所有的订阅者发送消息。</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposble *)subscribeNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))nextBlock &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(nextBlock != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:<span class="literal">NULL</span> completed:<span class="literal">NULL</span>];</span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span> subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>创建RACSubscriber 消息的订阅者</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)subscriberWithNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))next error:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *error))error completed:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completed &#123;</span><br><span class="line">	RACSubscriber *subscriber = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line"></span><br><span class="line">	subscriber-&gt;_next = [next <span class="keyword">copy</span>];</span><br><span class="line">	subscriber-&gt;_error = [error <span class="keyword">copy</span>];</span><br><span class="line">	subscriber-&gt;_completed = [completed <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>subscribe<br>创建的RACSubscriber实例需要订阅,subscribe:方法需要被RACSignal的子类实现，如 RACDynamicSignal</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">RACSignal.m</span><br><span class="line">- (RACDisposble *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">	<span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"This method must be overridden by subclasses"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RACDynamicSignal.m</span><br><span class="line">- (RACDisposble *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(subscriber != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">	RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将subscriber，signal，disposable绑定</span></span><br><span class="line">	subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="keyword">self</span> disposable:disposable];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>.didSubscribe != <span class="literal">NULL</span>) &#123; <span class="comment">//self.didSubscribe是初始化RACSignal时候赋值block</span></span><br><span class="line">		RACDisposble *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">      <span class="comment">//schedule即执行block()，也就是下面的内容</span></span><br><span class="line">			RACDisposble *innerDisposable = <span class="keyword">self</span>.didSubscribe(subscriber);<span class="comment">//将订阅者传进去执行结果</span></span><br><span class="line">			[disposable addDisposable:innerDisposable];</span><br><span class="line">		&#125;];</span><br><span class="line"></span><br><span class="line">		[disposable addDisposable:schedulingDisposable];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>subscribe方法作用:<br>1.创建RACCompoundDisposable<br>2.创建RACPassthroughSubscriber 一个私有的类，只有一个实例初始化方法，内部分别持有属性innerSubscriber消息的订阅者，signal信号，disposable订阅者的销毁对象,遵循RACSubscriber协议，内部会执行sendNext，sendError，sendCompleted方法，实际会将消息转发给真正的订阅者innerSubscriber</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACPassthroughSubscriber</span> : <span class="title">NSObject</span> &lt;<span class="title">RACSubscriber</span>&gt;</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSubscriber:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber signal:(RACSignal *)signal disposable:(RACCompoundDisposable *)disposable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;RACSubscriber&gt; innerSubscriber;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">unsafe_unretained</span>, <span class="keyword">readonly</span>) RACSignal *signal;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACCompoundDisposable *disposable;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">	...</span><br><span class="line">	[<span class="keyword">self</span>.innerSubscriber sendNext:value];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>3.RACScheduler.subscriptionScheduler是一个全局的变量<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (RACScheduler *)subscriptionScheduler &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">	<span class="keyword">static</span> RACScheduler *subscriptionScheduler;</span><br><span class="line">	<span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">		subscriptionScheduler = [[RACSubscriptionScheduler alloc] init];</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> subscriptionScheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建RACDynamicSignal的时候，存储了didSubscribe，接着执行 schedule 的block方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (RACScheduler.currentScheduler == <span class="literal">nil</span>) <span class="keyword">return</span> [<span class="keyword">self</span>.backgroundScheduler schedule:block];</span><br><span class="line"></span><br><span class="line">	block();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着执行block()也就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RACDisposble *innerDisposable = self.didSubscribe(subscriber);//将订阅者传进去执行结果</span><br><span class="line">[disposable addDisposable:innerDisposable];</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>调用self.didSubscribe(subscriber)对订阅者发送消息，执行了闭包block<br><code>[subscriber sendNext:@4];</code></p>
</li>
<li><p>sendNext</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark RACSubscriber</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">	<span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">		<span class="keyword">void</span> (^nextBlock)(<span class="keyword">id</span>) = [<span class="keyword">self</span>.next <span class="keyword">copy</span>];</span><br><span class="line">		<span class="keyword">if</span> (nextBlock == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		nextBlock(value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>sendNext操作，就是将subscribeNext初始化传进来的block进行copy,然后调用参数执行block,所以将参数x传递进来<br>执行下面这句话<br><code>NSLog(@&quot;signal %@&quot;,x);</code><br>忽略Error和RACDisposble，至此一个信号的创建和订阅完毕</p>
<h3 id="RACSignal-使用原理"><a href="#RACSignal-使用原理" class="headerlink" title="RACSignal 使用原理"></a>RACSignal 使用原理</h3><p>先订阅，然后发送信息，订阅者接收到消息<br>创建信号-&gt;subscribeNext -&gt;产生Subscriber-&gt; 执行信号创建时候存储的block-&gt; sendNext -&gt; subscriber接收消息</p>
<ul>
<li>RACSignal调用subscribeNext方法，新建一个RACSubscriber。</li>
<li>新建的RACSubscriber会copy，nextBlock，errorBlock，completedBlock存在自己的属性变量中。</li>
<li>RACSignal的子类RACDynamicSignal调用subscribe方法。</li>
<li>新建RACCompoundDisposable和RACPassthroughSubscriber对象。RACPassthroughSubscriber分别保存对RACSignal/RACSubscriber/RACCompoundDisposable的引用，注意对RACSignal的引用是unsafe_unretained的。</li>
<li>RACDynamicSignal调用didSubscribe闭包。先调用RACPassthroughSubscriber的相应的sendNext/sendError/sendCompleted方法。</li>
<li>RACPassthroughSubscriber再去调用self.innerSubscriber，即RACSubscriber的nextBlock/errorBlock/completedBlock。注意这里调用同样是先copy一份，再调用闭包执行。</li>
</ul>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>将原来的RACSignal通过传入的block，生成新的RACSignal</p>
<p>bind方法比较看着长，但是内部实现可以理解为，将RACSignal进行解包出NSObject，然后将NSObject传入RACSignalBindBlock，生成新的 RACSignal 返回<br>如果不考虑RACDisposble和error，可以将bind简化<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">            <span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line">            [bindingBlock(x, &amp;stop) subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">                [subscriber sendNext:x];</span><br><span class="line">            &#125;];</span><br><span class="line">       &#125;];</span><br><span class="line">    &#125;]setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面结合实例讲解下bind的使用<br>为了方便讲解，下面将block方法进行编码进行源码解析<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposble * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">	 	<span class="comment">//block1</span></span><br><span class="line">    [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *blockSignal = [signal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">		<span class="comment">//block2</span></span><br><span class="line">    <span class="keyword">return</span>  ^(<span class="built_in">NSNumber</span> *value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">				<span class="comment">//block3</span></span><br><span class="line">        value = @(value.integerValue * value.integerValue);</span><br><span class="line">        <span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:value];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[blockSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">		<span class="comment">//block4</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"blockSignal %@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    <span class="comment">//block5</span></span><br><span class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line">        <span class="comment">//block6</span></span><br><span class="line">        __block <span class="keyword">volatile</span> int32_t signalCount = <span class="number">1</span>;   <span class="comment">// indicates self</span></span><br><span class="line"></span><br><span class="line">        RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (^completeSignal)(RACDisposable *) = ^(RACDisposable *finishedDisposable) &#123;</span><br><span class="line">            <span class="comment">//block7</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (^addSignal)(RACSignal *) = ^(RACSignal *signal) &#123;</span><br><span class="line">            <span class="comment">//block8</span></span><br><span class="line">            RACDisposable *disposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">            <span class="comment">//block 9</span></span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">            [compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">            RACDisposable *bindingDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// block 10</span></span><br><span class="line">                <span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line">                <span class="keyword">id</span> signal = bindingBlock(x, &amp;stop);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (signal != <span class="literal">nil</span>) addSignal(signal);</span><br><span class="line">                    <span class="keyword">if</span> (signal == <span class="literal">nil</span> || stop) &#123;</span><br><span class="line">                        [selfDisposable dispose];</span><br><span class="line">                        completeSignal(selfDisposable);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                [compoundDisposable dispose];</span><br><span class="line">                [subscriber sendError:error];</span><br><span class="line">            &#125; completed:^&#123;</span><br><span class="line">                <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                    completeSignal(selfDisposable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line"></span><br><span class="line">            selfDisposable.disposable = bindingDisposable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> compoundDisposable;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//RACSignalBindBlock:接受 NSObject 对象返回 RACSignal 对象<br><code>typedef RACSignal * _Nullable (^RACSignalBindBlock)(ValueType _Nullable value, BOOL *stop);</code></p>
<p>1.首先，根据RACSignal的创建方法，didSubscribe先保存block1 进行copy<br>2.调用bind方法，先执行bind5<br>3.创建新信号，didSubscribe将block6 进行copy<br>4.执行bindSignal的sunscribeNext方法，也就执行self.didSubscribe(subscriber),执行block6<br>5.block6内第一步先执行 <code>RACSignalBindBlock bindingBlock = block();</code> ，也就是执行block2,返回RACSignalBindBlock<br>6.执行<code>[self subscribeNext:{...}]</code> 此处self是bind方法的调用者即signal，于是订阅signal发出的信号,执行subscribe,执行signal信号的didSubscribe，于是此处执行block1<br>7.block1调用sendNext，于是执行subscriber的nextBlock，此处执行block10<br>8.block10中会先调用bindingBlock，这个是之前调用block2的返回值，这个RACStreamBindBlock对象里面保存的是block3,所以开始调用block3<br>9.block3 的入参，是signal中sendNext中发出来的value的值，这里对value进行操作变化，返回新的信号signal’<br>10.如果返回的signal’为空，则会调用completeSignal，即调用block7。block7中会发送sendCompleted。如果返回的signal’不为空，则会调用addSignal，即调用block8。block8内，对入参新信号signal’进行订阅。signal’是bind函数的返回值，实际调用<code>[RACSignal return:value];</code>返回的是 RACReturnSignal，当subscribeNext新信号，立即就会执行block，发出sendNext，执行block9<br>11.block9内部执行<code>[subscriber sendNext:x];</code>此处的subscriber是bind方法的入参，也就是新的bindSignal的订阅者，执行sendNext操作会执行bindSignal的nextBlock即block4<br>12.block9 中执行完sendNext，还会调用sendCompleted,completeSignal(signal, selfDisposable)执行completeSignal，即block7。<br>13.执行完block7，就完成了一次从signal 发送信号sendNext的全过程。</p>
<p>以上流程就是bind方法的全部执行过程</p>
<p>打印输出<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blockSignal <span class="number">1</span></span><br><span class="line">blockSignal <span class="number">4</span></span><br><span class="line">blockSignal <span class="number">9</span></span><br><span class="line">blockSignal <span class="number">16</span></span><br></pre></td></tr></table></figure></p>
<p>整个过程大致如下:</p>
<ul>
<li>订阅原信号中的值；</li>
<li>将原信号发出的值传入 RACSignalBindBlock 进行转换；</li>
<li>如果 RACSignalBindBlock 返回一个信号，就会订阅该信号并将信号中的所有值传给订阅者 subscriber；</li>
<li>如果 RACSignalBindBlock 请求终止信号就会向原信号发出 -sendCompleted 消息；</li>
<li>当所有信号都完成时，会向订阅者发送 -sendCompleted；</li>
<li>无论何时，如果信号发出错误，都会向订阅者发送 -sendError: 消息。</li>
</ul>
<p>信号的订阅发送，可以按需定制<br><img src="/images/RAC-发送订阅.png" alt="RAC-发送订阅"></p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>事例<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:</span><br><span class="line">                         ^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">    &#123;</span><br><span class="line">				<span class="comment">//block1</span></span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"signal dispose"</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">		RACSignal *signal2 = [RACSignal createSignal:</span><br><span class="line">												 ^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">		&#123;</span><br><span class="line">				<span class="comment">//block2</span></span><br><span class="line">				[subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">				[subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">				[subscriber sendCompleted];</span><br><span class="line">				<span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">						<span class="built_in">NSLog</span>(<span class="string">@"signals dispose"</span>);</span><br><span class="line">				&#125;];</span><br><span class="line">		&#125;];</span><br><span class="line"></span><br><span class="line">    RACSignal *concatSignal = [signal1 concat:signal2];</span><br><span class="line"></span><br><span class="line">    [concatSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">				<span class="comment">//block3</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>下面看下concat内部操作<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)concat:(RACSignal *)signal &#123;</span><br><span class="line">	<span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">		RACCompoundDisposable *compoundDisposable = [[RACCompoundDisposable alloc] init];</span><br><span class="line">		<span class="comment">//block4</span></span><br><span class="line"></span><br><span class="line">		RACDisposable *sourceDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">			<span class="comment">//block5</span></span><br><span class="line">			[subscriber sendNext:x]; <span class="comment">//收到signal1的信号</span></span><br><span class="line">		&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">			[subscriber sendError:error];</span><br><span class="line">		&#125; completed:^&#123;</span><br><span class="line">			<span class="comment">//block6</span></span><br><span class="line">			RACDisposable *concattedDisposable = [signal subscribe:subscriber];</span><br><span class="line">			<span class="comment">//signal2调用subscribe</span></span><br><span class="line">		  <span class="comment">//内部执行`self.didSubscribe(subscriber)`</span></span><br><span class="line">			[compoundDisposable addDisposable:concattedDisposable];</span><br><span class="line">		&#125;];</span><br><span class="line"></span><br><span class="line">		[compoundDisposable addDisposable:sourceDisposable];</span><br><span class="line">		<span class="keyword">return</span> compoundDisposable;</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@"[%@] -concat: %@"</span>, <span class="keyword">self</span>.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>内部调用createSignal产生新的信号concatSignal<br>signal1和signal2分别将各种的block存储在didSubscriber<br>concatSignal将block也存储在didSubscriber<br>1.首先concatSignal执行 <code>subscribeNext</code>，执行concatSignal的didSubscribe，于是执行block4<br>2.block4内部执行<code>self subscribeNext</code>此处self是方法调用者signal1,于是调用signal1的didSubscribe，signal1执行<code>sendNext</code>，然后执行nextBlock也就是block5<code>[subscriber sendNext:x];</code>，执行block3<br>3.当signal1调用sendCompleted，执行block6 调用 <code>[signal subscribe:subscriber];</code> 此处signal实际是signal2<br>4.执行signal2的 didsubscribe ，于是调用block2，内部执行<code>[subscriber sendNext:@2];</code>此处的subscriber是入参，也就是concatSignal的订阅者，所以再次调用block3直到sendCompleted或者sendError</p>
<p>注:<br>concat是有序的组合，第一个信号完成之后才发送第二个信号</p>
<p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-03-24 11:20:28.468644+0800 ReactiveObjcTest[83027:1136301] value = 1</span><br><span class="line">2018-03-24 11:25:14.451727+0800 ReactiveObjcTest[83027:1136301] value = 2</span><br><span class="line">2018-03-24 11:25:15.716178+0800 ReactiveObjcTest[83027:1136301] value = 3</span><br><span class="line">2018-03-24 11:25:15.716384+0800 ReactiveObjcTest[83027:1136301] signals dispose</span><br><span class="line">2018-03-24 11:25:15.716775+0800 ReactiveObjcTest[83027:1136301] signal dispose</span><br></pre></td></tr></table></figure></p>
<h3 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h3><p>将上面例子代码修改方法为<code>zipwith</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *concatSignal = [signal1 zipWith:signal2];</span><br><span class="line"></span><br><span class="line">[concatSignal subscribeNext:^(id x) &#123;</span><br><span class="line">		NSLog(@&quot;value = %@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>zipwith源码分析<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)zipWith:(RACSignal *)signal &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">		__block <span class="built_in">BOOL</span> selfCompleted = <span class="literal">NO</span>;</span><br><span class="line">		<span class="built_in">NSMutableArray</span> *selfValues = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">		__block <span class="built_in">BOOL</span> otherCompleted = <span class="literal">NO</span>;</span><br><span class="line">		<span class="built_in">NSMutableArray</span> *otherValues = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">void</span> (^sendCompletedIfNecessary)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">			<span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">				<span class="built_in">BOOL</span> selfEmpty = (selfCompleted &amp;&amp; selfValues.count == <span class="number">0</span>);</span><br><span class="line">				<span class="built_in">BOOL</span> otherEmpty = (otherCompleted &amp;&amp; otherValues.count == <span class="number">0</span>);</span><br><span class="line">				<span class="comment">// 如果任意一个信号完成并且数组里面空了，就整个信号算完成</span></span><br><span class="line">				<span class="keyword">if</span> (selfEmpty || otherEmpty) [subscriber sendCompleted];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">void</span> (^sendNext)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">			<span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">				<span class="keyword">if</span> (selfValues.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">				<span class="keyword">if</span> (otherValues.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//数据进行拼接 然后移除</span></span><br><span class="line">				RACTuple *tuple = RACTuplePack(selfValues[<span class="number">0</span>], otherValues[<span class="number">0</span>]);</span><br><span class="line">				[selfValues removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">				[otherValues removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">				<span class="comment">//将拼接的数据进行发送</span></span><br><span class="line">				[subscriber sendNext:tuple];</span><br><span class="line">				sendCompletedIfNecessary();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//订阅第一个信号</span></span><br><span class="line">		RACDisposable *selfDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">			<span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">				[selfValues addObject:x ?: RACTupleNil.tupleNil];</span><br><span class="line">				sendNext(); <span class="comment">//将值发送出去</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">			[subscriber sendError:error];</span><br><span class="line">		&#125; completed:^&#123;</span><br><span class="line">			<span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">				selfCompleted = <span class="literal">YES</span>;</span><br><span class="line">				sendCompletedIfNecessary();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;];</span><br><span class="line"></span><br><span class="line">		<span class="comment">//订阅第二个信号</span></span><br><span class="line">		RACDisposable *otherDisposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">			<span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">				[otherValues addObject:x ?: RACTupleNil.tupleNil];</span><br><span class="line">				sendNext(); <span class="comment">//将值发送出去</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">			[subscriber sendError:error];</span><br><span class="line">		&#125; completed:^&#123;</span><br><span class="line">			<span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">				otherCompleted = <span class="literal">YES</span>;</span><br><span class="line">				sendCompletedIfNecessary();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">			[selfDisposable dispose];</span><br><span class="line">			[otherDisposable dispose];</span><br><span class="line">		&#125;];</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@"[%@] -zipWith: %@"</span>, <span class="keyword">self</span>.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>zipWith里面有两个数组，分别会存储两个信号的值。</p>
<p>先执行第一个信号的didsubscribe,signal1执行<code>sendNext</code>,订阅之后将value装入selfValues，然后发送出去，<br>在 sendNext block中，会执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (selfValues.count == 0) return;</span><br><span class="line">if (otherValues.count == 0) return;</span><br></pre></td></tr></table></figure></p>
<p>此时otherValues为空，return，不会将消息发送出去<br>当第二个信号的值紧接着发出来了，第二个信号每发送一次值，也会存储到第二个数组中，然后再调用sendNext()，不会再return了，因为两个数组里面都有值了，两个数组的第0号位置都有一个值了,然后打包成元组RACTuple发送出去。并清空两个数组0号位置存储的值。<br>然后判断是否发送完成，如果任一信号完成且数组的内容为空，则订阅完成</p>
<p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-03-24 11:54:04.033897+0800 ReactiveObjcTest[83279:1168707] value = &lt;RACTwoTuple: 0x604000010f00&gt; (</span><br><span class="line">    1,</span><br><span class="line">    2</span><br><span class="line">)</span><br><span class="line">2018-03-24 11:54:06.402037+0800 ReactiveObjcTest[83279:1168707] signals dispose</span><br></pre></td></tr></table></figure></p>
<p>注:<br>如果value为空，会被拼接为<code>RACTupleNil.tupleNil</code></p>
<h2 id="RACDisposble-信号的清理"><a href="#RACDisposble-信号的清理" class="headerlink" title="RACDisposble 信号的清理"></a>RACDisposble 信号的清理</h2><p>在创建信号的时候，会返回一个 RACDisposble ，用于在订阅结束进行必要的清理</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACDisposable</span> () </span>&#123;</span><br><span class="line">	<span class="keyword">void</span> * <span class="keyword">volatile</span> _disposeBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RACDisposable 最核心的就是 <code>_disposeBlock</code> ，内部的方法都是围绕它进行处理</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)disposableWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">	_disposeBlock = (<span class="keyword">void</span> *)<span class="built_in">CFBridgingRetain</span>([block <span class="keyword">copy</span>]);</span><br><span class="line">	OSMemoryBarrier();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">	_disposeBlock = (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>;</span><br><span class="line">	OSMemoryBarrier();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>void (^)(void)类型的block作为参数传入，会转化为CoreFoundation中的类型，赋值disposeBlock</p>
<p>下面是相关主要的子类RACSerialDisposable 和 RACCompoundDisposable</p>
<ul>
<li><p>RACSerialDisposable<br>线程安全，使用 pthread_mutex_t 保证<br>保证只含有一个RACDisposble</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  - (<span class="built_in">BOOL</span>)isDisposed &#123;</span><br><span class="line">	pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">BOOL</span> disposed = _disposed;</span><br><span class="line">	pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> disposed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RACCompoundDisposable<br>管理多个 RACDisposable 对象的释放</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACCompoundDisposable</span> () </span>&#123;</span><br><span class="line"></span><br><span class="line">	pthread_mutex_t _mutex;</span><br><span class="line">	RACDisposable *_inlineDisposables[RACCompoundDisposableInlineCount];</span><br><span class="line">	<span class="built_in">CFMutableArrayRef</span> _disposables;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDisposables:(<span class="built_in">NSArray</span> *)otherDisposables &#123;</span><br><span class="line">	<span class="keyword">self</span> = [<span class="keyword">self</span> init];</span><br><span class="line"></span><br><span class="line">	<span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line">	[otherDisposables enumerateObjectsUsingBlock:^(RACDisposable *disposable, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">		<span class="keyword">self</span>-&gt;_inlineDisposables[index] = disposable;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Stop after this iteration if we've reached the end of the inlined</span></span><br><span class="line">		<span class="comment">// array.</span></span><br><span class="line">		<span class="keyword">if</span> (index == RACCompoundDisposableInlineCount - <span class="number">1</span>) *stop = <span class="literal">YES</span>;</span><br><span class="line">	&#125;];</span><br><span class="line">	<span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (otherDisposables.count &gt; RACCompoundDisposableInlineCount) &#123;</span><br><span class="line">		_disposables = RACCreateDisposablesArray();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">CFRange</span> range = <span class="built_in">CFRangeMake</span>(RACCompoundDisposableInlineCount, (<span class="built_in">CFIndex</span>)otherDisposables.count - RACCompoundDisposableInlineCount);</span><br><span class="line">		<span class="built_in">CFArrayAppendArray</span>(_disposables, (__bridge <span class="built_in">CFArrayRef</span>)otherDisposables, range);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对象持有的 RACDisposable 不超过 RACCompoundDisposableInlineCount(2) 时，都会存储在 <code>_inlineDisposables</code> 数组中，而更多的实例都会存储在 <code>_disposables</code> 中：</p>
<p>值得注意的还有一个 addDisposable 方法<br>方法线程安全，如果_inlineDisposables数组内没有存满，先优先存储在inlineDisposbles数组，如果存满，往_disposables拼接数据<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDisposable:(RACDisposable *)disposable &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(disposable != <span class="keyword">self</span>);</span><br><span class="line">	<span class="keyword">if</span> (disposable == <span class="literal">nil</span> || disposable.disposed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">BOOL</span> shouldDispose = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (_disposed) &#123;</span><br><span class="line">			shouldDispose = <span class="literal">YES</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; RACCompoundDisposableInlineCount; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (_inlineDisposables[i] == <span class="literal">nil</span>) &#123;</span><br><span class="line">					_inlineDisposables[i] = disposable;</span><br><span class="line">					<span class="keyword">goto</span> foundSlot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (_disposables == <span class="literal">NULL</span>) _disposables = RACCreateDisposablesArray();</span><br><span class="line">			<span class="built_in">CFArrayAppendValue</span>(_disposables, (__bridge <span class="keyword">void</span> *)disposable);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (RACCOMPOUNDDISPOSABLE_ADDED_ENABLED()) &#123;</span><br><span class="line">				RACCOMPOUNDDISPOSABLE_ADDED(<span class="keyword">self</span>.description.UTF8String, disposable.description.UTF8String, <span class="built_in">CFArrayGetCount</span>(_disposables) + RACCompoundDisposableInlineCount);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line">		foundSlot:;</span><br><span class="line">		<span class="meta">#endif</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (shouldDispose) [disposable dispose];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="订阅的销毁"><a href="#订阅的销毁" class="headerlink" title="订阅的销毁"></a>订阅的销毁</h2><p>在了解了相关RACDisposble之后，再来看下bind方法中关于这方面发处理,以下是缩略版<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line"></span><br><span class="line">        __block <span class="keyword">volatile</span> int32_t signalCount = <span class="number">1</span>;   <span class="comment">// indicates self</span></span><br><span class="line"></span><br><span class="line">        RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (^completeSignal)(RACDisposable *) = ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (^addSignal)(RACSignal *) = ...</span><br><span class="line"></span><br><span class="line">        RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">        [compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">        RACDisposable *bindingDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (compoundDisposable.disposed) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">id</span> signal = bindingBlock(x, &amp;stop);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (signal != <span class="literal">nil</span>) addSignal(signal);</span><br><span class="line">            <span class="keyword">if</span> (signal == <span class="literal">nil</span> || stop) &#123;</span><br><span class="line">                [selfDisposable dispose];</span><br><span class="line">                completeSignal(selfDisposable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125; completed:^&#123;</span><br><span class="line">            completeSignal(selfDisposable);</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        selfDisposable.disposable = bindingDisposable;</span><br><span class="line">        <span class="keyword">return</span> compoundDisposable;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化后，可以观察到，信号的清理交给了 RACCompoundDisposable 实例，向 RACCompoundDisposable添加了 RACSerialDisposable ，将信号订阅后返回的 RACDisposable 交给了 RACSerialDisposable</p>
<p>completeSignal 和  addSignal 负责新信号创建之后的清理<br>当订阅新信号，产生的 RACSerialDisposable 添加进 RACCompoundDisposable 实例<br>当信号完成，compoundDisposable进行清理工作</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^completeSignal)(RACDisposable *) = ^(RACDisposable *finishedDisposable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (OSAtomicDecrement32Barrier(&amp;signalCount) == <span class="number">0</span>) &#123;</span><br><span class="line">      [subscriber sendCompleted];</span><br><span class="line">      [compoundDisposable dispose];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      [compoundDisposable removeDisposable:finishedDisposable];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (^addSignal)(RACSignal *) = ^(RACSignal *signal) &#123;</span><br><span class="line">    OSAtomicIncrement32Barrier(&amp;signalCount);</span><br><span class="line"></span><br><span class="line">    RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">    [compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">    RACDisposable *disposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">      [subscriber sendNext:x];</span><br><span class="line">    &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">      [compoundDisposable dispose];</span><br><span class="line">      [subscriber sendError:error];</span><br><span class="line">    &#125; completed:^&#123;</span><br><span class="line">      <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        completeSignal(selfDisposable);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    selfDisposable.disposable = disposable;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="举栗子"><a href="#举栗子" class="headerlink" title="举栗子"></a>举栗子</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Origin Signal Dispose"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *blockSignal = [signal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">    <span class="keyword">return</span>  ^(<span class="built_in">NSNumber</span> *value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        value = @(value.integerValue * value.integerValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;value.integerValue; i++) &#123;</span><br><span class="line">                [subscriber sendNext:value];</span><br><span class="line">            &#125;</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"Binding Signal Dispose"</span>);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[blockSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"signal %@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">打印log</span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] signal <span class="number">1</span></span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] Binding Signal Dispose</span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] signal <span class="number">4</span></span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] signal <span class="number">4</span></span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] signal <span class="number">4</span></span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] signal <span class="number">4</span></span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] Binding Signal Dispose</span><br><span class="line">ReactiveObjcTest[<span class="number">17315</span>:<span class="number">3506059</span>] Origin Signal Dispose</span><br></pre></td></tr></table></figure>
<h2 id="RACStream-相关的方法"><a href="#RACStream-相关的方法" class="headerlink" title="RACStream 相关的方法"></a>RACStream 相关的方法</h2><ul>
<li>Map  一般用来信号变换</li>
</ul>
<p>事例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">		//block1</span><br><span class="line">			 [subscriber sendNext:@1];</span><br><span class="line">			 [subscriber sendCompleted];</span><br><span class="line">			 return nil;</span><br><span class="line">	 &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *mapSignal = [signal1 map:^id _Nullable(id  _Nullable value) &#123;</span><br><span class="line">	//block2</span><br><span class="line"> 			return @([value integerValue] * 10);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[mapSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">	//block3</span><br><span class="line">		  NSLog(@&quot;value = %@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>map 源码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)map:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line">	<span class="comment">//block4</span></span><br><span class="line">	Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^(<span class="keyword">id</span> value) &#123;</span><br><span class="line">		<span class="comment">// block5</span></span><br><span class="line">		<span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:block(value)];</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@"[%@] -map:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>self.class 实际返回signal的class，signal是RACDynamicSignal类型<br>map方法内部实际调用<code>flattenMap</code>方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">	Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line">	<span class="comment">//block6</span></span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">		<span class="comment">//block7</span></span><br><span class="line">		<span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">			<span class="comment">//block8</span></span><br><span class="line">			<span class="keyword">id</span> stream = block(value) ?: [<span class="keyword">class</span> empty];</span><br><span class="line">			<span class="built_in">NSCAssert</span>([stream isKindOfClass:RACStream.class], <span class="string">@"Value returned from -flattenMap: is not a stream: %@"</span>, stream);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> stream;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@"[%@] -flattenMap:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flattenMap 内部调用的bind方法</p>
<ul>
<li>signal1创建，将block存入didSubscribe</li>
<li>执行map方法，此处先执行 block4, block内部调用 flattenMap 方法，于是执行 block6</li>
<li>block6 内部执行bind方法，于是创建新的信号作为返回结果 mapSignal</li>
<li>bind方法内部执行<code>RACSignalBindBlock bindingBlock = block();</code> 也就是将 block7 进行储存</li>
<li>然后调用bind方法内部的<code>[self subscribeNext:]</code>，对self进行订阅，self是map方法的调用者，也就是signal1，执行signal1的didSubscribe，</li>
<li>signal1调用<code>sendNext</code>执行，然后执行 bind方法内部<code>id signal = bindingBlock(x, &amp;stop);</code>，也就是执行bind方法的入参闭包，此处执行block7</li>
<li>接着执行block8,执行<code>id stream = block(value) ?: [class empty];</code> 此处执行block(value)，也就是flattenMap方法的入参闭包也就是block5</li>
<li>block5执行<code>return [class return:block(value)];</code>此处的block闭包是执行map方法的block闭包，也就是block2<br><code>[class return:value]</code>内部返回 RACReturnSignal ，当返回结果有值，则返回，否则返回<code>[class empty]</code>，也就是RACEmptySignal</li>
<li>返回信号不为nil，执行bind方法内部的<code>[signal subscribeNext:]</code> 对返回的信号进行订阅，由于返回的信号是RACReturnSignal类型，订阅之后直接调用subscribe方法执行sendNext，也就是订阅到执行block3</li>
</ul>
<p>map 就是将信号的值进行变换产生新的信号，将变换后的值进行发送出去，让调用者接收到新值</p>
<p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-03-24 15:42:28.407001+0800 ReactiveObjcTest[96645:1260165] value = 10</span><br></pre></td></tr></table></figure></p>
<ul>
<li>mapReplace<br>不管signal1 发送什么值，都替换成@“A”。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalB = [signal1 mapReplace:@&quot;A&quot;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>mapReplace 源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)mapReplace:(id)object &#123;</span><br><span class="line">    return [[self map:^(id _) &#123;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -mapReplace: %@&quot;, self.name, [object rac_description]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mapReplace 内部调用map方法，只是返回的是参数object 固定的</p>
<ul>
<li>reduceEach<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal2 = [signal1 reduceEach:^id(NSNumber *num1 , NSNumber *num2)&#123;</span><br><span class="line">		 return @([num1 intValue] + [num2 intValue]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>reduceEach 源码分析<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)reduceEach:(<span class="keyword">id</span> (^)())reduceBlock &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(reduceBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    __<span class="keyword">weak</span> RACStream *stream __attribute__((unused)) = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> map:^(RACTuple *t) &#123;</span><br><span class="line">        <span class="built_in">NSCAssert</span>([t isKindOfClass:RACTuple.class], <span class="string">@"Value from stream %@ is not a tuple: %@"</span>, stream, t);</span><br><span class="line">        <span class="keyword">return</span> [RACBlockTrampoline invokeBlock:reduceBlock withArguments:t];</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -reduceEach:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处先断言入参block是否为空，然后弱引用当前对象self<br>内部调用map方法，内部断言入参是否是合法的</p>
<p>RACBlockTrampoline<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACBlockTrampoline</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="keyword">id</span> block;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBlock:(<span class="keyword">id</span>)block &#123;</span><br><span class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">	_block = [block <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)invokeBlock:(<span class="keyword">id</span>)block withArguments:(RACTuple *)arguments &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	RACBlockTrampoline *trampoline = [[<span class="keyword">self</span> alloc] initWithBlock:block];</span><br><span class="line">	<span class="keyword">return</span> [trampoline invokeWithArguments:arguments];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)invokeWithArguments:(RACTuple *)arguments &#123;</span><br><span class="line">	SEL selector = [<span class="keyword">self</span> selectorForArgumentCount:arguments.count];</span><br><span class="line">	<span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:[<span class="keyword">self</span> methodSignatureForSelector:selector]];</span><br><span class="line">	invocation.selector = selector;</span><br><span class="line">	invocation.target = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; arguments.count; i++) &#123;</span><br><span class="line">		<span class="keyword">id</span> arg = arguments[i];</span><br><span class="line">		<span class="built_in">NSInteger</span> argIndex = (<span class="built_in">NSInteger</span>)(i + <span class="number">2</span>);</span><br><span class="line">		[invocation setArgument:&amp;arg atIndex:argIndex];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[invocation invoke];</span><br><span class="line"></span><br><span class="line">	__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> returnVal;</span><br><span class="line">	[invocation getReturnValue:&amp;returnVal];</span><br><span class="line">	<span class="keyword">return</span> returnVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>内部持有 block，初始化的时候是给block赋值，动态的构造一个NSInvocation并执行<br>将结果进行返回，也是map闭包里面的返回值</p>
<p>事例<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        RACTuple *tuple = [RACTuple tupleWithObjects:<span class="string">@"1"</span>,<span class="string">@"2"</span>, <span class="literal">nil</span>];</span><br><span class="line">        [subscriber sendNext:tuple];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signal2 = [signal1 reduceEach:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *num1 , <span class="built_in">NSNumber</span> *num2)&#123;</span><br><span class="line">      <span class="keyword">return</span> @([num1 intValue] + [num2 intValue]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal2 subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"value %@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>reduceEach 内部还是调用 map 方法,当signal1的发出的值包裹的数据是RACTuple类型时，才可以使用该操作,入参是block，参数可以任意</p>
<p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-03-24 16:24:39.880757+0800 ReactiveObjcTest[97285:1354826] value 3</span><br></pre></td></tr></table></figure></p>
<p>剩下的方法这里先不介绍了,可自行查阅<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">- (RACSignal *)not;</span><br><span class="line">- (RACSignal *)and;</span><br><span class="line">- (RACSignal *)or;</span><br><span class="line">- (RACSignal *)reduceApply;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，<em>系统总是重新从它所在的内存读取数据</em>，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a = i;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span></span><br><span class="line"><span class="keyword">int</span> b = i;</span><br></pre></td></tr></table></figure>
<p>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取<br>volatile 可以保证对特殊地址的稳定访问</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RACSignal 相关的类及代码较简洁，方法也不是很复杂，但是之前并没有深入学习，理解还是需要分析的。<br>结合实际事例，查看调用栈分析情况容易入手，<br>使用上看着也方便，但是内部创建了多个实例对象，信号、订阅者、信号清理机制等，弄清楚流程就简单了</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://github.com/Draveness/analyze/blob/master/contents/ReactiveObjC/RACSignal.md" target="_blank" rel="noopener">https://github.com/Draveness/analyze/blob/master/contents/ReactiveObjC/RACSignal.md</a></p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/02/27/AFNetworking源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/27/AFNetworking源码分析/" itemprop="url">AFNetworking源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-27T16:43:30+08:00">
                2018-02-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="AFNetworking结构"><a href="#AFNetworking结构" class="headerlink" title="AFNetworking结构"></a>AFNetworking结构</h2><p>主要分为五部分内容</p>
<ul>
<li>网络通信NSURLSession (核心)</li>
<li>网络状态监听Reachability</li>
<li>网络安全Security</li>
<li>网络信息序列化Serialization</li>
<li>UIKit扩展</li>
</ul>
<h2 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h2><p>AFNetworking 基于NSURLSession 封装了 AFURLSessionManager 和 AFHTTPSessionManager<br>AFHTTPSessionManager继承自 AFURLSessionManager 主要提供对外的接口API<br>AFURLSessionManager 才是核心关键</p>
<h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>先来看下AFHTTPSessionManager 网络请求，以POST为例，调用父类方法获取task，然后调用resume<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)POST:(NSString *)URLString</span><br><span class="line">                    parameters:(id)parameters</span><br><span class="line">                      progress:(void (^)(NSProgress * _Nonnull))uploadProgress</span><br><span class="line">                       success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success</span><br><span class="line">                       failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;POST&quot; URLString:URLString parameters:parameters uploadProgress:uploadProgress downloadProgress:nil success:success failure:failure];</span><br><span class="line"></span><br><span class="line">    [dataTask resume];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在父类方法中，将参数和请求URL转化为Request，然后生成dataTask做网络请求</span><br><span class="line"></span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</span><br><span class="line">                                       URLString:(NSString *)URLString</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</span><br><span class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</span><br><span class="line">&#123;</span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    dataTask = [self dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="请求参数解析类"><a href="#请求参数解析类" class="headerlink" title="请求参数解析类"></a>请求参数解析类</h2><p>详解如何将参数转化为Request<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableURLRequest *)requestWithMethod:(NSString *)method</span><br><span class="line">                                 URLString:(NSString *)URLString</span><br><span class="line">                                parameters:(id)parameters</span><br><span class="line">                                     error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line"></span><br><span class="line">    NSParameterAssert(url);</span><br><span class="line"></span><br><span class="line">    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];</span><br><span class="line">    mutableRequest.HTTPMethod = method;</span><br><span class="line"></span><br><span class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">	return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要作用</p>
<ul>
<li>生成 NSMutableURLRequest</li>
<li>设置 Request的 HTTPMethod</li>
<li>AFHTTPRequestSerializerObservedKeyPaths内包含 NSMutableURLRequest的部分属性<ul>
<li>BOOL allowsCellularAccess;</li>
<li>NSURLRequestCachePolicy cachePolicy;cachePolicy</li>
<li>BOOL HTTPShouldHandleCookies</li>
<li>BOOL HTTPShouldUsePipelining</li>
<li>NSURLRequestNetworkServiceType networkServiceType</li>
<li>NSTimeInterval timeoutInterval<br>当检测到这几个属性有变化，重新赋值给mutableRequest</li>
</ul>
</li>
<li>将parameter进行编码添加入request</li>
</ul>
<h2 id="parameter编码"><a href="#parameter编码" class="headerlink" title="parameter编码"></a>parameter编码</h2><p>请求参数进行编码，根据请求Method区分参数是拼接在URL后面 setURL，还是设置请求体setHTTPBody<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</span><br><span class="line">                               withParameters:(id)parameters</span><br><span class="line">                                        error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</span><br><span class="line">    ...</span><br><span class="line">    NSString *query = nil;</span><br><span class="line">    ...</span><br><span class="line">    //将参数进行拼接</span><br><span class="line">    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">    ...</span><br><span class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;  // 如果是 GET 等，拼接参数重置 URL</span><br><span class="line">        if (query &amp;&amp; query.length &gt; 0) &#123;</span><br><span class="line">            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // #2864: an empty string is a valid x-www-form-urlencoded payload</span><br><span class="line">        if (!query) &#123;</span><br><span class="line">            query = @&quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</span><br><span class="line">            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];   //setHTTPHeaderField</span><br><span class="line">        &#125;</span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];// setHTTPBody</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/parameter转换.png" alt="parameter转换"></p>
<p>参数转码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">NSString * AFQueryStringFromParameters(NSDictionary *parameters) &#123;</span><br><span class="line">    NSMutableArray *mutablePairs = [NSMutableArray array];</span><br><span class="line">    //将参数转化为字典</span><br><span class="line">    for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class="line">    &#125;</span><br><span class="line">    //拼接</span><br><span class="line">    return [mutablePairs componentsJoinedByString:@&quot;&amp;&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSArray * AFQueryStringPairsFromDictionary(NSDictionary *dictionary) &#123;</span><br><span class="line">    return AFQueryStringPairsFromKeyAndValue(nil, dictionary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) &#123;</span><br><span class="line">    NSMutableArray *mutableQueryStringComponents = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">    //将参数的key对description进行排序，使用compare方法比较</span><br><span class="line">    //&#123; net,bar,base&#125; -&gt; &#123; bar,base,net&#125;</span><br><span class="line">    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;description&quot; ascending:YES selector:@selector(compare:)];</span><br><span class="line"></span><br><span class="line">    //对value是dict，array，set类型处理，直到为其他类型，生成AFQueryStringPair插入数组</span><br><span class="line">    if ([value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">        NSDictionary *dictionary = value;</span><br><span class="line">        for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            id nestedValue = dictionary[nestedKey];</span><br><span class="line">            if (nestedValue) &#123;</span><br><span class="line">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@&quot;%@[%@]&quot;, key, nestedKey] : nestedKey), nestedValue)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if ([value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">        NSArray *array = value;</span><br><span class="line">        for (id nestedValue in array) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@&quot;%@[]&quot;, key], nestedValue)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if ([value isKindOfClass:[NSSet class]]) &#123;</span><br><span class="line">        NSSet *set = value;</span><br><span class="line">        for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数转码举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@&#123;</span><br><span class="line">     @&quot;name&quot; : @&quot;bang&quot;,</span><br><span class="line">     @&quot;phone&quot;: @&#123;@&quot;mobile&quot;: @&quot;xx&quot;, @&quot;home&quot;: @&quot;xx&quot;&#125;,</span><br><span class="line">     @&quot;families&quot;: @[@&quot;father&quot;, @&quot;mother&quot;],</span><br><span class="line">     @&quot;nums&quot;: [NSSet setWithObjects:@&quot;1&quot;, @&quot;2&quot;, nil]</span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line">@[</span><br><span class="line">     field: @&quot;name&quot;, value: @&quot;bang&quot;,</span><br><span class="line">     field: @&quot;phone[mobile]&quot;, value: @&quot;xx&quot;,</span><br><span class="line">     field: @&quot;phone[home]&quot;, value: @&quot;xx&quot;,</span><br><span class="line">     field: @&quot;families[]&quot;, value: @&quot;father&quot;,</span><br><span class="line">     field: @&quot;families[]&quot;, value: @&quot;mother&quot;,</span><br><span class="line">     field: @&quot;nums&quot;, value: @&quot;1&quot;,</span><br><span class="line">     field: @&quot;nums&quot;, value: @&quot;2&quot;,</span><br><span class="line">]</span><br><span class="line">-&gt;</span><br><span class="line">name=bang&amp;phone[mobile]=xx&amp;phone[home]=xx&amp;families[]=father&amp;families[]=mother&amp;nums=1&amp;num=2</span><br></pre></td></tr></table></figure></p>
<p>至此，request已经设置好，下面就是如何生成 NSURLSessionDataTask</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">dataTask = [self dataTaskWithRequest:request ...]</span><br><span class="line"></span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line"></span><br><span class="line">    //为了解决iOS 8以下 创建task并发创建多个task但因同步问题导致task的identifier不唯一，所以串行处理</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [self.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug 1140.11</span><br><span class="line"></span><br><span class="line">static void url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123;</span><br><span class="line">        // Fix of bug</span><br><span class="line">        // Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span><br><span class="line">        // Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span><br><span class="line">        dispatch_sync(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个task都对应一个delegate,便于之后数据处理以及回调<br>根据dataTask唯一的taskIdentifier和AFURLSessionManagerTaskDelegate相对应，存储在字典中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class="line">    delegate.manager = self;  //设置manager</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</span><br><span class="line">    [self setDelegate:delegate forTask:dataTask]; //绑定delegate和dataTask</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(NSURLSessionTask *)task</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    //保证线程安全</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    //将AFdelegate存入以task的identifier为key的字典中</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    //监听task任务开始和暂停的通知</span><br><span class="line">    [self addNotificationObserverForTask:task];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//监听task任务开始和暂停的通知</span><br><span class="line">- (void)addNotificationObserverForTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上方法创建了AFURLSessionManagerTaskDelegate 将其和dataTask对应存储到manager的字典中，<br>同时还监听任务开始和挂起的通知，<br>差不多准备工作完毕，在AFHTTPSessionManager中拿到了返回的task，调用了resume启动任务</p>
<p>网络开始请求数据，初始化的时候，设置AFURLSessionManager 为session的代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br></pre></td></tr></table></figure></p>
<p>于是会进行下面的回调<br><img src="/images/AFNet-代理方法整理..png" alt="AFNet-代理方法整理"></p>
<p>AFURLSessionManager 包含许多自定义的block，可以在回调方法中处理接收到数据<br>其中六个方法会回调到AF自定义的delegate,负责把每个task对应的数据回调出去<br><img src="/images/AFNet-AFDelegate.jpeg" alt="AFNet-AFDelegate"></p>
<p>以task 请求baidu为例<br>首先会收到回调receiveData<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];</span><br><span class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line"></span><br><span class="line">    if (self.dataTaskDidReceiveData) &#123;</span><br><span class="line">        self.dataTaskDidReceiveData(session, dataTask, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    self.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive;</span><br><span class="line">    self.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived;</span><br><span class="line"></span><br><span class="line">    [self.mutableData appendData:data]; //拼接data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果请求完成，进入下面操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    // delegate may be nil when completing a task in the background</span><br><span class="line">    if (delegate) &#123;</span><br><span class="line">        //把代理转发给我们绑定的AFURLSessionManagerTaskDelegate</span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line"></span><br><span class="line">        [self removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //执行 completeblock</span><br><span class="line">    if (self.taskDidComplete) &#123;</span><br><span class="line">        self.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">  /*</span><br><span class="line">  @interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;</span><br><span class="line"></span><br><span class="line">  @property (nonatomic, weak) AFURLSessionManager *manager;</span><br><span class="line"></span><br><span class="line">  AFURLSessionManagerTaskDelegate 弱持有manager，所以下面强引用manager</span><br><span class="line">  不会存在循环引用问题</span><br><span class="line">  */</span><br><span class="line">    __strong AFURLSessionManager *manager = self.manager;</span><br><span class="line"></span><br><span class="line">    __block id responseObject = nil;</span><br><span class="line"></span><br><span class="line">    //下面对userInfo进行拼接</span><br><span class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    if (self.mutableData) &#123;</span><br><span class="line">        data = [self.mutableData copy]; //任务完成了，将数据拷贝后，不需要mutableData，清空释放内存</span><br><span class="line">        self.mutableData = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</span><br><span class="line">    &#125; else if (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (error) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">        //在自定义的completionGroup或者completionQueue进行回调操作</span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (self.completionHandler) &#123;</span><br><span class="line">                self.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line">            //在主线程发出任务完成通知</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            NSError *serializationError = nil;</span><br><span class="line"></span><br><span class="line">            //根据定义的responseSerializer 解析数据</span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            //如果是下载文件，解析数据为下载路径</span><br><span class="line">            if (self.downloadFileURL) &#123;</span><br><span class="line">                responseObject = self.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                if (self.completionHandler) &#123;</span><br><span class="line">                    self.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h2><p>自定义block，通过对外声明set方法，重写block的set方法，清晰了解block的参数和返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@interface AFURLSessionManager ()</span><br><span class="line">@property (readwrite, nonatomic, strong) NSURLSessionConfiguration *sessionConfiguration;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSOperationQueue *operationQueue;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSURLSession *session;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;</span><br><span class="line">@property (readonly, nonatomic, copy) NSString *taskDescriptionForSessionTasks;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSLock *lock;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidCompleteBlock taskDidComplete;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>下面了解下各个block的使用</p>
<ul>
<li><p>AFURLSessionDidBecomeInvalidBlock</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当session失效，该代理方法被调用</span><br><span class="line">当调用finishTasksAndInvalidate使session失效，但是允许现有任务运行完成之后调用该代理</span><br><span class="line">当调用invalidateAndCancel,session会立即调用该代理</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didBecomeInvalidWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">  if (self.sessionDidBecomeInvalid) &#123;</span><br><span class="line">      self.sessionDidBecomeInvalid(session, error);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AFURLSessionDidReceiveAuthenticationChallengeBlock</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  该方法主要用于对https的认证</span><br><span class="line">*/</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    // 挑战处理类型</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    // 使用指定证书</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line"></span><br><span class="line">    if (self.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      /*</span><br><span class="line">       此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust</span><br><span class="line">      也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。</span><br><span class="line">      而这个证书就需要使用credentialForTrust:来创建一个NSURLCredential对象</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">          // 基于客户端的安全策略来决定是否信任该服务器</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line"></span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                if (credential) &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengeUseCredential; //使用证书</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;//取消挑战</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //完成挑战</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AFURLSessionDidFinishEventsForBackgroundURLSessionBlock</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当session中所有已经入队的消息被发送出去后，会调用该代理方法</span><br><span class="line"></span><br><span class="line">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session &#123;</span><br><span class="line">    if (self.didFinishEventsForBackgroundURLSession) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            self.didFinishEventsForBackgroundURLSession(session);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>AFURLSessionTaskWillPerformHTTPRedirectionBlock<br>//当服务器重定向的时候调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">willPerformHTTPRedirection:(NSHTTPURLResponse *)response</span><br><span class="line">        newRequest:(NSURLRequest *)request</span><br><span class="line"> completionHandler:(void (^)(NSURLRequest *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLRequest *redirectRequest = request;</span><br><span class="line"></span><br><span class="line">    //如果存在自定义重定向block，返回新的重定向Request</span><br><span class="line">    if (self.taskWillPerformHTTPRedirection) &#123;</span><br><span class="line">        redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用request重新请求</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(redirectRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AFURLSessionTaskDidReceiveAuthenticationChallengeBlock</p>
</li>
</ul>
<p>和上面认证https方法类似，只是多了参数task,可以根据每个task去自定义需要的https认证方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line"></span><br><span class="line">    if (self.taskDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>AFURLSessionTaskNeedNewBodyStreamBlock</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line"> needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSInputStream *inputStream = nil;</span><br><span class="line"></span><br><span class="line">    if (self.taskNeedNewBodyStream) &#123;</span><br><span class="line">        inputStream = self.taskNeedNewBodyStream(session, task);</span><br><span class="line">    &#125; else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) &#123;</span><br><span class="line">        inputStream = [task.originalRequest.HTTPBodyStream copy];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.jianshu.com/p/856f0e26279d" target="_blank" rel="noopener">https://www.jianshu.com/p/856f0e26279d</a></p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/02/27/内存分配/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/27/内存分配/" itemprop="url">内存分配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-27T15:07:05+08:00">
                2018-02-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文分析内存使用Xcode自带的Instruments分析工具Alloctions<br>运行profile下的Alloctions，可以看到有一栏统计All Heap &amp; Anonymous VM使用的内存<br>All Heap:堆上分配的内存情况<br>Anonymous VM:虚拟内存分配</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>当应用向系统申请分配内存时，系统不会返回需要的物理内存地址，而是返回虚拟内存地址。当开始真正使用申请到的虚拟内存的时候，系统才将虚拟内存映射到具体的物理内存上。</p>
<h2 id="内存页"><a href="#内存页" class="headerlink" title="内存页"></a>内存页</h2><p>系统将内存页分为三种状态。</p>
<p>活跃内存页（active pages）- 这种内存页已经被映射到物理内存中，而且近期被访问过，处于活跃状态。<br>非活跃内存页（inactive pages）- 这种内存页已经被映射到物理内存中，但是近期没有被访问过。<br>可用的内存页（free pages）- 没有关联到虚拟内存页的物理内存页集合。</p>
<p>当可用的内存页降低到一定的阀值时，系统就会采取低内存应对措施，在OSX中，系统会将非活跃内存页交换到硬盘上，而在iOS中，则会触发Memory Warning，如果你的App没有处理低内存警告并且还在后台占用太多内存，则有可能被杀掉。</p>
<h2 id="VM-Region-Size"><a href="#VM-Region-Size" class="headerlink" title="VM Region Size"></a>VM Region Size</h2><p><img src="/images/内存分配-1.png" alt="内存分配"><br>上图是mac OS应用的 VM Tracker分析图，可以看到VM Tree Region有4种size</p>
<ul>
<li>Dirty Size</li>
<li>Swapped Size:交换到硬盘上的大小 仅OSX系统适用</li>
<li>Resident Size:实际使用物理内存的大小</li>
<li>Virtual Size:虚拟内存大小</li>
</ul>
<h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>我们常使用以下几种方式来分配内存</p>
<ul>
<li>NSObject的 alloc 方法</li>
<li>c函数的 malloc 方法<br>malloc有一个缺陷，必须配合memset将内存区中所有的值设置为0。这样就导致了一个问题:malloc出一块内存区域时，系统并没有分配物理内存。然而调用memset后，系统将会把malloc出的所有虚拟内存关联到物理内存上<br>因此系统建议使用calloc方法,calloc返回的内存区域会自动清零，而且只有使用时才会关联到物理内存并清零。</li>
</ul>
<p>以OC当中创建实例对象为例，最终调用方法_class_createInstanceFromZone<br>方法内部调用calloc来分配内存，下图显示调用栈的情况<br><img src="/images/内存分配-alloc.png" alt="内存分配-alloc"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              bool cxxConstruct = true,</span><br><span class="line">                              size_t *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    if (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">        obj = (id)calloc(1, size);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (zone) &#123;</span><br><span class="line">            obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj = (id)calloc(1, size);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://juejin.im/post/5a5e13c45188257327399e19" target="_blank" rel="noopener">https://juejin.im/post/5a5e13c45188257327399e19</a></p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/02/23/Aspects源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/23/Aspects源码解析/" itemprop="url">Aspects源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-23T15:37:15+08:00">
                2018-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文源码解析来自官方1.4.2版本</p>
<h2 id="AspectInfo"><a href="#AspectInfo" class="headerlink" title="AspectInfo"></a>AspectInfo</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AspectInfo</span> : <span class="title">NSObject</span> &lt;<span class="title">AspectInfo</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">unsafe_unretained</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> instance;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *arguments;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSInvocation</span> *originalInvocation;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="AspectIdentifier"><a href="#AspectIdentifier" class="headerlink" title="AspectIdentifier"></a>AspectIdentifier</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AspectIdentifier</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SEL selector;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> block;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMethodSignature</span> *blockSignature;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> object;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AspectOptions options;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="AspectsContainer"><a href="#AspectsContainer" class="headerlink" title="AspectsContainer"></a>AspectsContainer</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AspectsContainer</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)removeAspect:(<span class="keyword">id</span>)aspect;</span><br><span class="line">- (<span class="built_in">BOOL</span>)hasAspects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *beforeAspects;</span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *insteadAspects;</span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *afterAspects;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="AspectTracker"><a href="#AspectTracker" class="headerlink" title="AspectTracker"></a>AspectTracker</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AspectTracker</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Class trackedClass;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *trackedClassName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span> *selectorNames;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *selectorNamesToSubclassTrackers;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithTrackedClass:(Class)trackedClass;</span><br><span class="line">- (<span class="keyword">void</span>)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(<span class="built_in">NSString</span> *)selectorName;</span><br><span class="line">- (<span class="keyword">void</span>)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(<span class="built_in">NSString</span> *)selectorName;</span><br><span class="line">- (<span class="built_in">BOOL</span>)subclassHasHookedSelectorName:(<span class="built_in">NSString</span> *)selectorName;</span><br><span class="line">- (<span class="built_in">NSSet</span> *)subclassTrackersHookingSelectorName:(<span class="built_in">NSString</span> *)selectorName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>调试，首先调用aspect_add方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> aspect_add(<span class="keyword">id</span> <span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="keyword">id</span> block, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(block);</span><br><span class="line"></span><br><span class="line">    __block AspectIdentifier *identifier = <span class="literal">nil</span>;</span><br><span class="line">    aspect_performLocked(^&#123;</span><br><span class="line">        <span class="keyword">if</span> (aspect_isSelectorAllowedAndTrack(<span class="keyword">self</span>, selector, options, error)) &#123;</span><br><span class="line">            AspectsContainer *aspectContainer = aspect_getContainerForObject(<span class="keyword">self</span>, selector);</span><br><span class="line">            identifier = [AspectIdentifier identifierWithSelector:selector object:<span class="keyword">self</span> options:options block:block error:error];  <span class="comment">//生成AspectIdentifier</span></span><br><span class="line">            <span class="keyword">if</span> (identifier) &#123;</span><br><span class="line">                [aspectContainer addAspect:identifier withOptions:options];</span><br><span class="line">                <span class="comment">//区分options向aspectContainer的数组添加aspect</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Modify the class to allow message interception.</span></span><br><span class="line">                aspect_prepareClassAndHookSelector(<span class="keyword">self</span>, selector, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> identifier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> AspectsContainer *aspect_getContainerForObject(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</span><br><span class="line">    SEL aliasSelector = aspect_aliasForSelector(selector);<span class="comment">//拼接生成新selector</span></span><br><span class="line">    AspectsContainer *aspectContainer = objc_getAssociatedObject(<span class="keyword">self</span>, aliasSelector);</span><br><span class="line">    <span class="keyword">if</span> (!aspectContainer) &#123;</span><br><span class="line">        aspectContainer = [AspectsContainer new];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, aliasSelector, aspectContainer, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前对象如果不存在aliasSelector,给当前对象绑定属性aliasSelector</span></span><br><span class="line">    <span class="keyword">return</span> aspectContainer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>aspect_performLocked 使用OSSpinLock</li>
<li>aspect_isSelectorAllowedAndTrack 过滤当前aspect的selector是否为合法的selector</li>
<li>生成AspectIdentifier,根据block生成block签名,根据options加入AspectContainer的相应数组</li>
<li>aspect_prepareClassAndHookSelector hook方法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_prepareClassAndHookSelector(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line">    Class klass = aspect_hookClass(<span class="keyword">self</span>, error);</span><br><span class="line">    Method targetMethod = class_getInstanceMethod(klass, selector);</span><br><span class="line">    IMP targetMethodIMP = method_getImplementation(targetMethod);</span><br><span class="line">    <span class="keyword">if</span> (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *typeEncoding = method_getTypeEncoding(targetMethod);</span><br><span class="line">        SEL aliasSelector = aspect_aliasForSelector(selector);</span><br><span class="line">        <span class="keyword">if</span> (![klass instancesRespondToSelector:aliasSelector]) &#123;</span><br><span class="line">            __unused <span class="built_in">BOOL</span> addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);</span><br><span class="line">            <span class="built_in">NSCAssert</span>(addedAlias, <span class="string">@"Original implementation for %@ is already copied to %@ on %@"</span>, <span class="built_in">NSStringFromSelector</span>(selector), <span class="built_in">NSStringFromSelector</span>(aliasSelector), klass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We use forwardInvocation to hook in.</span></span><br><span class="line">        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(<span class="keyword">self</span>, selector), typeEncoding);</span><br><span class="line">        AspectLog(<span class="string">@"Aspects: Installed hook for -[%@ %@]."</span>, klass, <span class="built_in">NSStringFromSelector</span>(selector));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>aspect_prepareClassAndHookSelector 方法主要操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - Hook Class</span><br><span class="line"></span><br><span class="line">static Class aspect_hookClass(NSObject *self, NSError **error) &#123;</span><br><span class="line">    NSCParameterAssert(self);</span><br><span class="line">	Class statedClass = self.class;</span><br><span class="line">	Class baseClass = object_getClass(self);</span><br><span class="line">	NSString *className = NSStringFromClass(baseClass);</span><br><span class="line"></span><br><span class="line">	if ([className hasSuffix:AspectsSubclassSuffix]) &#123;</span><br><span class="line">		return baseClass;</span><br><span class="line">	&#125;else if (class_isMetaClass(baseClass)) &#123;</span><br><span class="line">        return aspect_swizzleClassInPlace((Class)self);</span><br><span class="line">        // Probably a KVO&apos;ed class. Swizzle in place. Also swizzle meta classes in place.</span><br><span class="line">    &#125;else if (statedClass != baseClass) &#123;</span><br><span class="line">        return aspect_swizzleClassInPlace(baseClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  //生成子类subclass</span><br><span class="line">	const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;</span><br><span class="line">	Class subclass = objc_getClass(subclassName);</span><br><span class="line"></span><br><span class="line">	if (subclass == nil) &#123;</span><br><span class="line">		subclass = objc_allocateClassPair(baseClass, subclassName, 0);//Allocate subclass</span><br><span class="line">		if (subclass == nil) &#123;</span><br><span class="line">            NSString *errrorDesc = [NSString stringWithFormat:@&quot;objc_allocateClassPair failed to allocate class %s.&quot;, subclassName];</span><br><span class="line">            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		aspect_swizzleForwardInvocation(subclass);//替换子类forwardInvocation方法</span><br><span class="line">		aspect_hookedGetClass(subclass, statedClass);//替换子类class方法为原类statedClass</span><br><span class="line">		aspect_hookedGetClass(object_getClass(subclass), statedClass);//替换子类的元类的class方法为原类statedClass</span><br><span class="line">		objc_registerClassPair(subclass);//注册子类</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	object_setClass(self, subclass);//替换当前对象的isa为subclass obj-&gt;changeIsa(cls)</span><br><span class="line">	return subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先 对当前self进行hook class<br>此处self为AspectsViewController类型的对象，hook后为AspectsViewController<em>Aspects</em></li>
<li>给子类也就是hook后的类AspectsViewController<em>Aspects</em>添加方法，name为aspect_aliasForSelector(selector),方法实现method_getImplementation(原selector的method实现)</li>
<li><p>替换子类的原selector实现为aspect_getMsgForwardIMP(self, selector)</p>
</li>
<li><p>aspect_getMsgForwardIMP 作用<br>返回IMP,用于当消息转发的时候use forwardInvocation to hook</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> IMP aspect_getMsgForwardIMP(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector) &#123;</span><br><span class="line">    IMP msgForwardIMP = _objc_msgForward;</span><br><span class="line"><span class="meta">#if !defined(__arm64__)</span></span><br><span class="line"></span><br><span class="line">    Method method = class_getInstanceMethod(<span class="keyword">self</span>.class, selector);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *encoding = method_getTypeEncoding(method);</span><br><span class="line">    <span class="built_in">BOOL</span> methodReturnsStructValue = encoding[<span class="number">0</span>] == _C_STRUCT_B;</span><br><span class="line">    <span class="keyword">if</span> (methodReturnsStructValue) &#123;</span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            <span class="built_in">NSUInteger</span> valueSize = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">NSGetSizeAndAlignment</span>(encoding, &amp;valueSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (valueSize == <span class="number">1</span> || valueSize == <span class="number">2</span> || valueSize == <span class="number">4</span> || valueSize == <span class="number">8</span>) &#123;</span><br><span class="line">                methodReturnsStructValue = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">@catch</span> (__unused <span class="built_in">NSException</span> *e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (methodReturnsStructValue) &#123;</span><br><span class="line">        msgForwardIMP = (IMP)_objc_msgForward_stret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">return</span> msgForwardIMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>至此，准备工作已经结束，下面进行调试工作<br>当点击按钮的时候，查看到左边的函数调用栈，消息转发进入<strong>ASPECTS_ARE_BEING_CALLED</strong>这里是关键<br>之前说过，当前class已经被修改isa为子类，子类的selector方法被hook了IMP，消息进入转发流程<br><img src="/images/Aspects_hook原selector.png" alt="hook原selector"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the swizzled forwardInvocation: method.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ASPECTS_ARE_BEING_CALLED__(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSInvocation</span> *invocation) &#123;</span><br><span class="line">    ...</span><br><span class="line">    SEL originalSelector = invocation.selector;</span><br><span class="line">	  SEL aliasSelector = aspect_aliasForSelector(invocation.selector);</span><br><span class="line">    invocation.selector = aliasSelector;</span><br><span class="line">    AspectsContainer *objectContainer = objc_getAssociatedObject(<span class="keyword">self</span>, aliasSelector);</span><br><span class="line">    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(<span class="keyword">self</span>), aliasSelector);</span><br><span class="line">    AspectInfo *info = [[AspectInfo alloc] initWithInstance:<span class="keyword">self</span> invocation:invocation];</span><br><span class="line">    <span class="built_in">NSArray</span> *aspectsToRemove = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before hooks.</span></span><br><span class="line">    aspect_invoke(classContainer.beforeAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.beforeAspects, info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类执行 aliasSelector ，也就是原selector对应的method</span></span><br><span class="line">    <span class="comment">// Instead hooks.</span></span><br><span class="line">    <span class="built_in">BOOL</span> respondsToAlias = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123;</span><br><span class="line">        aspect_invoke(classContainer.insteadAspects, info);</span><br><span class="line">        aspect_invoke(objectContainer.insteadAspects, info);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        Class klass = object_getClass(invocation.target);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123;</span><br><span class="line">                [invocation invoke];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行block的方法</span></span><br><span class="line">    <span class="comment">// After hooks.</span></span><br><span class="line">    aspect_invoke(classContainer.afterAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.afterAspects, info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有实现alias方法，执行原来的selector</span></span><br><span class="line">    <span class="keyword">if</span> (!respondsToAlias) &#123;</span><br><span class="line">        invocation.selector = originalSelector;</span><br><span class="line">        SEL originalForwardInvocationSEL = <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName);</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:originalForwardInvocationSEL]) &#123;</span><br><span class="line">            ((<span class="keyword">void</span>( *)(<span class="keyword">id</span>, SEL, <span class="built_in">NSInvocation</span> *))objc_msgSend)(<span class="keyword">self</span>, originalForwardInvocationSEL, invocation);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span> doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove any hooks that are queued for deregistration.</span></span><br><span class="line">    [aspectsToRemove makeObjectsPerformSelector:<span class="keyword">@selector</span>(remove)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>宏aspect_invoke<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#define aspect_invoke(aspects, info) \</span><br><span class="line">for (AspectIdentifier *aspect in aspects) &#123;\</span><br><span class="line">    [aspect invokeWithInfo:info];\</span><br><span class="line">    if (aspect.options &amp; AspectOptionAutomaticRemoval) &#123; \</span><br><span class="line">        aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用AspectIdentifier的实例方法</span><br><span class="line">- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info &#123;</span><br><span class="line">    NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:self.blockSignature];</span><br><span class="line">    NSInvocation *originalInvocation = info.originalInvocation;</span><br><span class="line">    NSUInteger numberOfArguments = self.blockSignature.numberOfArguments;</span><br><span class="line"></span><br><span class="line">    // Be extra paranoid. We already check that on hook registration.</span><br><span class="line">    if (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123;</span><br><span class="line">        AspectLogError(@&quot;Block has too many arguments. Not calling %@&quot;, info);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The `self` of the block will be the AspectInfo. Optional.</span><br><span class="line">    if (numberOfArguments &gt; 1) &#123;</span><br><span class="line">        [blockInvocation setArgument:&amp;info atIndex:1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	  void *argBuf = NULL;</span><br><span class="line">    for (NSUInteger idx = 2; idx &lt; numberOfArguments; idx++) &#123;</span><br><span class="line">        const char *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">		NSUInteger argSize;</span><br><span class="line">		NSGetSizeAndAlignment(type, &amp;argSize, NULL);</span><br><span class="line"></span><br><span class="line">		if (!(argBuf = reallocf(argBuf, argSize))) &#123;</span><br><span class="line">            AspectLogError(@&quot;Failed to allocate memory for block invocation.&quot;);</span><br><span class="line">			return NO;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		[originalInvocation getArgument:argBuf atIndex:idx];</span><br><span class="line">		[blockInvocation setArgument:argBuf atIndex:idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [blockInvocation invokeWithTarget:self.block]; //执行blockInvocation</span><br><span class="line"></span><br><span class="line">    if (argBuf != NULL) &#123;</span><br><span class="line">        free(argBuf);</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此流程调用分析结束</p>
<h2 id="Aspects原理"><a href="#Aspects原理" class="headerlink" title="Aspects原理"></a>Aspects原理</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    IMP imp = class_getMethodImplementation(<span class="keyword">self</span>-&gt;isa, SEL op);</span><br><span class="line">    imp(<span class="keyword">self</span>, op, ...); <span class="comment">//调用这个函数，伪代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找IMP</span></span><br><span class="line">IMP class_getMethodImplementation(Class cls, SEL sel) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls || !sel) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (!imp) <span class="keyword">return</span> _objc_msgForward; <span class="comment">//_objc_msgForward 用于消息转发</span></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息的发送最终走到objc_msgSend<br>消息转发流程图:<br><img src="/images/Aspects_SEL invoke流程图.png" alt="Aspects_SEL invoke流程图"></p>
<p>Aspects 正是利用其中最灵活的forwardInvocation进行封装的<br>对于待 hook 的 selector，将其指向 objc_msgForward /objc_msgForward_stret ,<br>同时生成一个新的 aliasSelector 指向原来的 IMP，<br>并且 hook 住 forwardInvocation 函数，使他指向自己的实现。按照上面的思路，当被 hook 的 selector 被执行的时候，首先根据 selector 找到了 objc_msgForward /objc_msgForward_stret ,而这个会触发消息转发，从而进入 forwardInvocation。同时由于 forwardInvocation 的指向也被修改了，因此会转入新的 forwardInvocation 函数，在里面执行需要嵌入的附加代码，完成之后，再转回原来的 IMP。</p>
<h2 id="Aspects-执行流程"><a href="#Aspects-执行流程" class="headerlink" title="Aspects 执行流程"></a>Aspects 执行流程</h2><p>这里以实例对象为例,运行官方demo,对象方法的hook，首先需要先添加待hook的方法，aspect_add<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) &#123;</span><br><span class="line">    ...</span><br><span class="line">    __block AspectIdentifier *identifier = nil;</span><br><span class="line">    aspect_performLocked(^&#123;</span><br><span class="line">        if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) &#123;//1判断能否hook</span><br><span class="line">            ... //2 记录数据结构</span><br><span class="line">            aspect_prepareClassAndHookSelector(self, selector, error);//3 swizzling</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>aspect_isSelectorAllowedAndTrack判断方法能否被hook,对于forwardInvocation、dealloc等方法在黑名单之中</li>
<li>对于元类，需要保证类的方法只在继承链中被hook一次,,先从当前类开始查找方法是否已经被hook,否则从父类中查找,找到了说明能被hook且被hook过一次</li>
<li><p>以下源码 从当前类开始，添加所有继承链上的AspectTracker的selectorNames或者subclassTracker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AspectTracker *tracker = nil;</span><br><span class="line">AspectTracker *subclassTracker = nil;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">       tracker = swizzledClassesDict[currentClass];</span><br><span class="line">       if (!tracker) &#123;</span><br><span class="line">           tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass]; //初始化</span><br><span class="line">           swizzledClassesDict[(id&lt;NSCopying&gt;)currentClass] = tracker; //赋值操作</span><br><span class="line">      &#125;</span><br><span class="line">      if (subclassTracker) &#123;</span><br><span class="line">           [tracker addSubclassTracker:subclassTracker hookingSelectorName:selectorName];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">           [tracker.selectorNames addObject:selectorName];</span><br><span class="line">      &#125;</span><br><span class="line">      // All superclasses get marked as having a subclass that is modified.</span><br><span class="line">      subclassTracker = tracker;</span><br><span class="line">&#125;while ((currentClass = class_getSuperclass(currentClass)));</span><br></pre></td></tr></table></figure>
</li>
<li><p>aspect_prepareClassAndHookSelector 最重要的就是hook ForwardInvocation方法<br>刚注册子类的时候，子类没有forwardInvocation方法，aspect_swizzleForwardInvocation内class_addMethod不会执行，所以不会生成  NSSelectorFromString(AspectsForwardInvocationSelectorName)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void aspect_swizzleForwardInvocation(Class klass) &#123;</span><br><span class="line">    NSCParameterAssert(klass);</span><br><span class="line">    // If there is no method, replace will act like class_addMethod.</span><br><span class="line">    IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, &quot;v@:@&quot;);</span><br><span class="line">    if (originalImplementation) &#123;</span><br><span class="line">        class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, &quot;v@:@&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    AspectLog(@&quot;Aspects: %@ is now aspect aware.&quot;, NSStringFromClass(klass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>aspect_hookClass之后，添加aliasSelector，方法指向原selector的实现，原selector指向转发IMP</p>
</li>
<li>方法转发<strong>ASPECTS_ARE_BEING_CALLED</strong> 最终执行到这个方法,依次处理before/instead/after逻辑以及调用原来的逻辑，如果不存在hook方法，能响应原始函数则执行原始函数，否则报错</li>
</ul>
<h2 id="加深了解"><a href="#加深了解" class="headerlink" title="加深了解"></a>加深了解</h2><ul>
<li>block转化为NSInvocation<br>消息转发的时候，需要调用NSInvocation,hook的时候缓存的是block,因此需要将block转化为NSInvocation，<br>AspectIdentifier 内含有NSMethodSignature  <code>*blockSignature,包括执行 block 所需要用到的具体信息如方法签名、参数等</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static NSMethodSignature *aspect_blockMethodSignature(id block, NSError **error) &#123;</span><br><span class="line">    AspectBlockRef layout = (__bridge void *)block;</span><br><span class="line">	if (!(layout-&gt;flags &amp; AspectBlockFlagsHasSignature)) &#123;</span><br><span class="line">        NSString *description = [NSString stringWithFormat:@&quot;The block %@ doesn&apos;t contain a type signature.&quot;, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">	void *desc = layout-&gt;descriptor;</span><br><span class="line">	desc += 2 * sizeof(unsigned long int);</span><br><span class="line">	if (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) &#123;</span><br><span class="line">		desc += 2 * sizeof(void *);</span><br><span class="line">    &#125;</span><br><span class="line">	if (!desc) &#123;</span><br><span class="line">        NSString *description = [NSString stringWithFormat:@&quot;The block %@ doesn&apos;t has a type signature.&quot;, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">	const char *signature = (*(const char **)desc);</span><br><span class="line">	return [NSMethodSignature signatureWithObjCTypes:signature];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>NSInvocation的创建, 需要signature, argument.<br>signature可以从block中转换过来, 而参数则可以从原来的AspectInfo对象中取出来做转换<br>从Block获得编码的Signature，可以转化为方法签名<br>在源码block签名方法中打上断点，可以查看block具体结构体<br><img src="/images/Aspects_block_signature.png" alt="Aspects_block_signature"></p>
<p><code>void *desc = layout-&gt;descriptor</code> 这个指针就是用于获取block的签名, 根据clang的源码, 签名位于descriptor结构体的第三个变量, 所以将指针移动两个单位.<br>flag用于判断block的具体类型BLOCK_HAS_COPY_DISPOSE, 代表这个block是否有捕获外部参数, 如果有捕获则descriptor中会多插入两个变量, 所以需要将desc指针再移动两个单位</p>
</li>
</ul>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>以下code实践将block转化为NSInvocation执行<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_literal_1 &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa; <span class="comment">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor_1 &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;         <span class="comment">// NULL</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;         <span class="comment">// sizeof(struct Block_literal_1)</span></span><br><span class="line">        <span class="comment">// optional helper functions</span></span><br><span class="line">        <span class="keyword">void</span> (*copy_helper)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);     <span class="comment">// IFF (1&lt;&lt;25)</span></span><br><span class="line">        <span class="keyword">void</span> (*dispose_helper)(<span class="keyword">void</span> *src);             <span class="comment">// IFF (1&lt;&lt;25)</span></span><br><span class="line">        <span class="comment">// required ABI.2010.3.16</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *signature;                         <span class="comment">// IFF (1&lt;&lt;30)</span></span><br><span class="line">    &#125; *descriptor;</span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMethodSignature</span> *blockSignature(<span class="keyword">id</span> blockObj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> Block_literal_1 *block = (__bridge <span class="keyword">void</span> *)blockObj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> signatureFlag = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    assert(block-&gt;flags &amp; signatureFlag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *desc = block-&gt;descriptor;</span><br><span class="line">    desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>); <span class="comment">//signature</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> copyDisposeFlag = <span class="number">1</span> &lt;&lt; <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">if</span> (block-&gt;flags &amp; copyDisposeFlag) &#123;</span><br><span class="line">        desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *signature = (*(<span class="keyword">const</span> <span class="keyword">char</span> **)desc);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:signature];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testBlockInvocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span>* (^myblock) (<span class="built_in">NSString</span>* , <span class="built_in">NSString</span>* ) = ^(<span class="built_in">NSString</span>* a, <span class="built_in">NSString</span>* b)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"a:%@,b:%@"</span>,a,b);</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"a:%@,b:%@"</span>,a,b];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *result = myblock(<span class="string">@"Tom"</span>,<span class="string">@"Jerry"</span>);</span><br><span class="line">    <span class="built_in">XCTAssertTrue</span>([result isEqualToString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"a:Tom,b:Jerry"</span>]], <span class="string">@"result Must be a:Tom,b:Jerry"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *sig = blockSignature(myblock);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:sig];</span><br><span class="line">    invocation.target = myblock;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *args = @[<span class="string">@"Patty"</span>,<span class="string">@"Cat"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; args.count ; ++i)&#123;</span><br><span class="line">        <span class="built_in">NSString</span> *object = args[i];</span><br><span class="line">        [invocation setArgument:&amp;object atIndex:i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    [invocation setTarget:myblock];</span><br><span class="line">    [invocation invoke];</span><br><span class="line">    <span class="comment">// 获取返回值</span></span><br><span class="line">    <span class="keyword">id</span> returnValue = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (sig.methodReturnLength) &#123;</span><br><span class="line">        <span class="comment">//获取返回值</span></span><br><span class="line">        [invocation getReturnValue:&amp;returnValue];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取返回值的类型</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *returnType = [sig methodReturnType];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"返回值的类型 %s"</span>,returnType);</span><br><span class="line">    <span class="built_in">XCTAssertTrue</span>([returnValue isEqualToString:<span class="string">@"a:Patty,b:Cat"</span>], <span class="string">@"result Must be a:Patty,b:Cat"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印结果如下<br>a:Tom,b:Jerry<br>a:Patty,b:Cat<br>返回值的类型 @”NSString”</p>
<ul>
<li>注意NSInvocation的返回值<br>首先当被调用函数是以new，copy,mutableCopy和alloc开头的特殊函数时，函数返回的的对象持有引用计数，所以我们设置returnValue的类型是__strong，这样在这个returnValue的作用域结束时，会进行release，内存处理正常。</li>
</ul>
<p>当被调用函数是普通函数时，函数内部最后执行了autorelease导致引用计数为0时。所以我们一定要设置returnValue的类型为<br><code>__autoreleasing id returnValue;</code><br>因为如果设置为__strong，则会在returnValue的作用域结束时，对这个引用计数为0的对象再进行一次release，导致内存问题。</p>
<h2 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h2><ul>
<li>respondsToSelector<br>之前小组分析讨论的时候，存在疑点，现在贴出来研究下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (![self respondsToSelector:selector] &amp;&amp; ![self.class instancesRespondToSelector:selector]) &#123;</span><br><span class="line">    NSString *errorDesc = [NSString stringWithFormat:@&quot;Unable to find selector -[%@ %@].&quot;, NSStringFromClass(self.class), selectorName];</span><br><span class="line">    AspectError(AspectErrorDoesNotRespondToSelector, errorDesc);</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>此处<code>[self respondsToSelector:selector]</code> 和 <code>[self.class instancesRespondToSelector:selector]</code><br>一时没有搞清楚为什么需要写两遍，两者在什么情况下才会不一样</p>
<p>respondsToSelector : 调用者可以是类(实例)，用来判断是否包含类方法(实例方法)</p>
<p>instancesRespondToSelector: 调用者必须是类，用来判断该类的实例是否包含实例方法</p>
<p>此处当self是实例情况下，两者是一样的<br>当self是类，就不一样了</p>
<ul>
<li>objc_msgForward 和 objc_msgForward_stret</li>
</ul>
<p>在Aspects.m的方法<code>aspect_getMsgForwardIMP</code>内部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> IMP msgForwardIMP = _objc_msgForward;</span><br><span class="line"> ...</span><br><span class="line"> Method method = class_getInstanceMethod(self.class, selector);</span><br><span class="line"> const char *encoding = method_getTypeEncoding(method);</span><br><span class="line"> BOOL methodReturnsStructValue = encoding[0] == _C_STRUCT_B;</span><br><span class="line"> ...</span><br><span class="line"> if (methodReturnsStructValue) &#123;</span><br><span class="line">      msgForwardIMP = (IMP)_objc_msgForward_stret;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>此处是获取方法对应的IMP的类型<br>可见，当方法返回值是结构体类型，对应的IMP是<code>_objc_msgForward_stret</code><br>当方法返回值是普通的数据类型或者对象等，是<code>_objc_msgForward</code></p>
<h2 id="阅读链接"><a href="#阅读链接" class="headerlink" title="阅读链接"></a>阅读链接</h2><p><a href="https://wereadteam.github.io/2016/06/30/Aspects/" target="_blank" rel="noopener">https://wereadteam.github.io/2016/06/30/Aspects/</a><br><a href="http://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="noopener">http://clang.llvm.org/docs/Block-ABI-Apple.html</a></p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/02/13/Objc-autoreleasePool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/13/Objc-autoreleasePool/" itemprop="url">Objc-autoreleasePool</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-13T10:55:28+08:00">
                2018-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇开始学习OC的内存管理，先来说说autoreleasepool相关的原理<br>一般来说，线程和autoreleasepool是对应存在的，主线程，默认含有自动释放池</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        for (int i=0; i&lt;100; i++) &#123;</span><br><span class="line">            @autoreleasepool&#123;</span><br><span class="line">                SampleClass *sample = [[SampleClass alloc] init];</span><br><span class="line">                [sample startAction];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的for循环内，断点执行，可以看到方法执行函数调用栈<br><img src="/images/autoreleasepool1.png" alt="函数调用栈"></p>
<p>@autoreleasepool 通过反编译之后得到的是<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line"><span class="comment">// do whatever you want</span></span><br><span class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br></pre></td></tr></table></figure></p>
<h2 id="push操作"><a href="#push操作" class="headerlink" title="push操作"></a>push操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#   define POOL_BOUNDARY nil  （哨兵对象）</span><br><span class="line"></span><br><span class="line">void *</span><br><span class="line">objc_autoreleasePoolPush(void)</span><br><span class="line">&#123;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void *push()</span><br><span class="line">   &#123;</span><br><span class="line">       id *dest;</span><br><span class="line">       if (DebugPoolAllocation) &#123;</span><br><span class="line">           // Each autorelease pool starts on a new pool page.</span><br><span class="line">           dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           dest = autoreleaseFast(POOL_BOUNDARY); //执行</span><br><span class="line">       &#125;</span><br><span class="line">       assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">       return dest;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //在每个autoreleasepool初始化的时候，都会先放入一个哨兵对象</span><br><span class="line">   static inline id *autoreleaseFast(id obj)</span><br><span class="line">   &#123;</span><br><span class="line">       AutoreleasePoolPage *page = hotPage();</span><br><span class="line">       if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">           return page-&gt;add(obj);</span><br><span class="line">       &#125; else if (page) &#123;</span><br><span class="line">           return autoreleaseFullPage(obj, page);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return autoreleaseNoPage(obj);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一般所指的hot page ，即最新添加的 autoreleased 对象所在的那个 page</li>
</ul>
<p>autoreleaseFast 函数的作用可以分为三种情况</p>
<ul>
<li>判断当前是否存在page，存在<ul>
<li>page存储满,autoreleaseFullPage初始化新的页</li>
<li>page有空间，page-&gt;add(obj)</li>
</ul>
</li>
<li>不存在page，创建 autoreleaseNoPage创建一个hotPage<br>最后的都会调用 page-&gt;add(obj) 将对象添加到自动释放池中。</li>
</ul>
<h2 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h2><p>autoreleasepool 没有单独的内存结构，它是以autoreleasepoolPage为结点的双向链表来实现的<br>每个自动释放池，都是由一系列的autoreleasepoolPage组成的，每个autoreleasepoolPage大小都是4096字节<br>其中有 56 bit 用于存储 AutoreleasePoolPage 的成员变量，剩下的都是用来存储加入到自动释放池中的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage</span><br><span class="line">&#123;</span><br><span class="line">    static pthread_key_t const key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    static uint8_t const SCRIBBLE = 0xA3;  // 0xA3A3A3A3 after releasing</span><br><span class="line">    static size_t const SIZE = PAGE_MAX_SIZE;  // size and alignment, power of 2</span><br><span class="line">    static size_t const COUNT = SIZE / sizeof(id);</span><br><span class="line">    ...</span><br><span class="line">    magic_t const magic;</span><br><span class="line">    id *next;</span><br><span class="line">    pthread_t const thread;</span><br><span class="line">    AutoreleasePoolPage * const parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    uint32_t const depth;</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>下面是空AutoreleasePoolPage的内存结构图:<br><img src="/images/空AutoreleasePoolPage.png" alt="空AutoreleasePoolPage"></p>
<ul>
<li>magic 用来校验 AutoreleasePoolPage 的结构是否完整；</li>
<li>next 指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 begin() ；<br>thread 指向当前线程；</li>
<li>parent 指向父结点，第一个结点的 parent 值为 nil ；</li>
<li>child 指向子结点，最后一个结点的 child 值为 nil ；</li>
<li>depth 代表深度，从 0 开始，往后递增 1；</li>
<li>hiwat 代表 high water mark 。</li>
<li>当 next == begin() 时，表示 AutoreleasePoolPage 为空；</li>
<li>当 next == end() 时，表示 AutoreleasePoolPage 已满。</li>
</ul>
<p>根据断点调试，进入 page-&gt;add(obj)</p>
<ul>
<li>将当前page的next指针处存入obj对象，next指针指向下一个位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id *add(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!full());</span><br><span class="line">    unprotect();</span><br><span class="line">    id *ret = next;  // faster than `return next-1` because of aliasing</span><br><span class="line">    *next++ = obj;</span><br><span class="line">    protect();</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可见push方法返回的结果是哨兵对象（插入对象之前next指针）的地址</p>
<h2 id="Pop操作"><a href="#Pop操作" class="headerlink" title="Pop操作"></a>Pop操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void pop(void *token)</span><br><span class="line">   &#123;</span><br><span class="line">       AutoreleasePoolPage *page;</span><br><span class="line">       id *stop;</span><br><span class="line"></span><br><span class="line">       if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">          ...</span><br><span class="line">          setHotPage(nil);</span><br><span class="line">          ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       page = pageForPointer(token); //取出对应的page 通过对4096取模</span><br><span class="line">       stop = (id *)token;</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       page-&gt;releaseUntil(stop); //释放token之后所有的对象</span><br><span class="line"></span><br><span class="line">       // memory: delete empty children</span><br><span class="line">       if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">           // special case: delete everything during page-per-pool debugging</span><br><span class="line">           AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">           page-&gt;kill();</span><br><span class="line">           setHotPage(parent);</span><br><span class="line">       &#125; else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">           // special case: delete everything for pop(top)</span><br><span class="line">           // when debugging missing autorelease pools</span><br><span class="line">           page-&gt;kill();</span><br><span class="line">           setHotPage(nil);</span><br><span class="line">       &#125;</span><br><span class="line">       else if (page-&gt;child) &#123;</span><br><span class="line">           // hysteresis: keep one empty child if page is more than half full</span><br><span class="line">           if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">               page-&gt;child-&gt;kill();</span><br><span class="line">           &#125;</span><br><span class="line">           else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">               page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void releaseUntil(id *stop)</span><br><span class="line">   &#123;</span><br><span class="line">     while (this-&gt;next != stop) &#123;</span><br><span class="line"></span><br><span class="line">           AutoreleasePoolPage *page = hotPage();</span><br><span class="line"></span><br><span class="line">           while (page-&gt;empty()) &#123;</span><br><span class="line">               page = page-&gt;parent;</span><br><span class="line">               setHotPage(page);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           page-&gt;unprotect();</span><br><span class="line">           id obj = *--page-&gt;next; //取出next指向的内容</span><br><span class="line">           memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));//将next区域清为0xA3</span><br><span class="line">           page-&gt;protect();</span><br><span class="line"></span><br><span class="line">           if (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">               objc_release(obj); //释放obj对象</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       setHotPage(this);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过循环遍历当前page以及父page，<br>内存地址在 stop 之后的所有 autoreleased 对象都会被 release ,直到 stop 所在 page 的 next 指向 stop 为止。</p>
<h2 id="autorelease操作"><a href="#autorelease操作" class="headerlink" title="autorelease操作"></a>autorelease操作</h2><p>通过 NSObject.mm 源文件，找到以下方法的实现</p>
<ul>
<li>(id)autorelease {<br>  return ((id)self)-&gt;rootAutorelease();<br>}<br>通过查看 ((id)self)-&gt;rootAutorelease() 的方法调用，我们发现最终调用的就是 AutoreleasePoolPage 的 autorelease 函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">inline id objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;</span><br><span class="line"></span><br><span class="line">    return rootAutorelease2();</span><br><span class="line">&#125;</span><br><span class="line">id objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line">    return AutoreleasePoolPage::autorelease((id)this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/images/对象release堆栈图.png" alt="对象release堆栈图"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static inline id autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line">    assert(!obj-&gt;isTaggedPointer());</span><br><span class="line">    id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    assert(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到autorelease操作和push非常相似<br>push插入的是POOL_BOUNDARY 即nil<br>autorelease插入具体需要释放的对象</p>
<h2 id="release-操作"><a href="#release-操作" class="headerlink" title="release 操作"></a>release 操作</h2><p>源码来啦<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>)release &#123;</span><br><span class="line">    ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRelease();</span><br><span class="line">&#125;</span><br><span class="line">objc_object::rootRelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRelease(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终是对obj的retainCount执行减1操作，如果obj的retainCount为0，直接dealloc</p>
<p>在isa篇其实知道，OC对象都有isa 表示其所属的类，isa_t结构体中有两个字段表示对象的引用计数<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  isa_t() &#123; &#125;</span><br><span class="line">  isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  Class cls;</span><br><span class="line">  uintptr_t bits;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">    uintptr_t nonpointer        : <span class="number">1</span>;</span><br><span class="line">    uintptr_t has_assoc         : <span class="number">1</span>;</span><br><span class="line">    uintptr_t has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">    uintptr_t shiftcls          : <span class="number">44</span>; </span><br><span class="line">    uintptr_t magic             : <span class="number">6</span>;</span><br><span class="line">    uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">    uintptr_t deallocating      : <span class="number">1</span>;  </span><br><span class="line">    uintptr_t has_sidetable_rc  : <span class="number">1</span>; <span class="comment">// 相关</span></span><br><span class="line">    uintptr_t extra_rc          : <span class="number">8</span>; <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>has_sidetable_rc</code>和<code>extra_rc</code>用来表示引用计数相关<br>在上面的<code>rootRelease</code>方法用到了相关方面<br>当对象的引用计数超过了<code>extra_rc</code>能存储的位数，需要将<code>has_sidetable_rc</code>置为1，同时剩下的引用计数存在sideTable相关的表中，此处可以看下对象的存储retain相关，就知道为什么了<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">id</span> </span><br><span class="line">objc_object::<span class="keyword">retain</span>()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123; <span class="comment">//如果没有自定义retain方法</span></span><br><span class="line">        <span class="keyword">return</span> rootRetain();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_retain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终调用以下方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">objc_object::rootRetain(<span class="keyword">bool</span> tryRetain, <span class="keyword">bool</span> handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>; <span class="comment">//如果优化 ，直接return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits); <span class="comment">//取出对象的isa</span></span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123; </span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">if</span> (tryRetain) <span class="keyword">return</span> sidetable_tryRetain() ? (<span class="keyword">id</span>)<span class="keyword">this</span> : <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> sidetable_retain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don't check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++  此处执行extra_rc+1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123; <span class="comment">//如果溢出，说明需要进行另存</span></span><br><span class="line">            <span class="comment">// newisa.extra_rc++ overflowed</span></span><br><span class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                <span class="keyword">return</span> rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Leave half of the retain counts inline and </span></span><br><span class="line">            <span class="comment">// prepare to copy the other half to the side table. //另一半存到sidetable</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            transcribeToSideTable = <span class="literal">true</span>;</span><br><span class="line">            newisa.extra_rc = RC_HALF;  <span class="comment">//extra_rc保留一半</span></span><br><span class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>; <span class="comment">//has_sidetable_rc置为1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        <span class="comment">// Copy the other half of the retain counts to the side table.</span></span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>retain流程如上，所以release操作也需要类似操作，此处就省略代码了</p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p><code>void *memset(void *s, int ch, size_t n);</code><br>函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。<br><code>memset</code>：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看到这里，对autoreleasePool已经有了基本的认识原理，了解push和pop操作，对象的autorelease和release</p>
<h2 id="顺便一提"><a href="#顺便一提" class="headerlink" title="顺便一提"></a>顺便一提</h2><p>接触了Hopper Disassembler之后，反编译二进制代码得到伪代码非常方便可以观察<br>前提是先获取到二进制可执行文件，可以通过xcode编译得到，也可以通过clang的命令获取</p>
<ul>
<li>通过xcode编译文件<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Pig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Pig</span>()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Pig</span></span></span><br><span class="line">- (<span class="keyword">void</span>)getPig</span><br><span class="line">&#123;</span><br><span class="line">    Pig *pig = [[Pig alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">- (Pig *)getPig1</span><br><span class="line">&#123;</span><br><span class="line">    Pig *pig = [[Pig alloc] init];</span><br><span class="line">    <span class="keyword">return</span> pig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将可执行文件拖进Hopper，得到Pig的两个方法的反编译代码<br><img src="/images/autoreleasepool_pig.png" alt="autoreleasepool_pig"><br><img src="/images/autoreleasepool_pig1.png" alt="autoreleasepool_pig1"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void -[Pig getPig](void * self, void * _cmd) &#123;</span><br><span class="line">    rdi = var_18;</span><br><span class="line">    [[Pig alloc] init];</span><br><span class="line">    objc_storeStrong(rdi, 0x0);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void * -[Pig getPig1](void * self, void * _cmd) &#123;</span><br><span class="line">    var_18 = [[Pig alloc] init];</span><br><span class="line">    var_28 = [var_18 retain];</span><br><span class="line">    objc_storeStrong(var_18, 0x0);</span><br><span class="line">    rax = [var_28 autorelease];</span><br><span class="line">    return rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是ARC下系统对autorelease的返回值优化策略</p>
<ul>
<li>objc_storeStrong源码<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_storeStrong(<span class="keyword">id</span> *location, <span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> prev = *location;</span><br><span class="line">    <span class="keyword">if</span> (obj == prev) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    objc_retain(obj);</span><br><span class="line">    *location = obj;</span><br><span class="line">    objc_release(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>赋值strong类型的属性的时候会调用<code>objc_storeStrong</code><br>copy,weak等都不会调用<br>第一个入参，有值的<br>第二个入参，赋值的时候有值，也有存在ox0的情况<br>1.当init方法时候给成员赋值，obj有值，当init方法return的时候，obj为ox0<br>2.当dealloc对象的时候，obj为ox0情况居多<br>总结:在__strong类型的变量的作用域结束时，自动添加release函数进行释放。</p>
<p>打印类地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p (objc_class *)[Pig class]</span><br></pre></td></tr></table></figure></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">http://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a></p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/02/12/Objc-protocol篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/12/Objc-protocol篇/" itemprop="url">Objc-protocol篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-12T11:28:59+08:00">
                2018-02-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇研究以下问题</p>
<ul>
<li>Protocol的实践</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@protocol DogProtocol</span><br><span class="line">@required</span><br><span class="line">- (void)printName;</span><br><span class="line">@optional</span><br><span class="line">- (void)printAge;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Dog: NSObject</span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@property (nonatomic) NSInteger age;</span><br><span class="line">@property (nonatomic, weak) id delegate;</span><br><span class="line">- (void)printDetails;</span><br><span class="line">@end</span><br><span class="line">@implementation Dog</span><br><span class="line">-(void)printDetails</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;I&apos;m Dog&quot;);</span><br><span class="line">    [self.delegate printName];</span><br><span class="line">    [self.delegate printAge];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface SampleClass:NSObject&lt;DogProtocol&gt;</span><br><span class="line">@property (nonatomic, strong) Dog *littleDog;</span><br><span class="line">- (void)startAction;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SampleClass</span><br><span class="line"></span><br><span class="line">- (void)startAction&#123;</span><br><span class="line">    Dog *dog = [[Dog alloc]init];</span><br><span class="line">    dog.name = @&quot;PattyDog&quot;;</span><br><span class="line">    dog.age = 10;</span><br><span class="line">    dog.delegate = self;</span><br><span class="line"></span><br><span class="line">    self.littleDog = dog;</span><br><span class="line">    [dog printDetails];</span><br><span class="line">&#125;</span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;name:%@&quot;,self.littleDog.name);</span><br><span class="line">&#125;</span><br><span class="line">- (void)printAge</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;age:%zd&quot;,self.littleDog.age);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark -main</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        SampleClass *sample = [[SampleClass alloc] init];</span><br><span class="line">        [sample startAction];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看控制台打印输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m Dog</span><br><span class="line">name:PattyDog</span><br><span class="line">age:10</span><br></pre></td></tr></table></figure></p>
<h2 id="protocol-t结构"><a href="#protocol-t结构" class="headerlink" title="protocol_t结构"></a>protocol_t结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct protocol_t : objc_object &#123;</span><br><span class="line">    const char *mangledName;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    method_list_t *instanceMethods;</span><br><span class="line">    method_list_t *classMethods;</span><br><span class="line">    method_list_t *optionalInstanceMethods;</span><br><span class="line">    method_list_t *optionalClassMethods;</span><br><span class="line">    property_list_t *instanceProperties;</span><br><span class="line">    uint32_t size;   // sizeof(protocol_t)</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    // Fields below this point are not always present on disk.</span><br><span class="line">    const char **_extendedMethodTypes;</span><br><span class="line">    const char *_demangledName;</span><br><span class="line">    property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    const char *demangledName();</span><br><span class="line"></span><br><span class="line">    const char *nameForLogging() &#123;</span><br><span class="line">        return demangledName();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="分别申明-required和-optional方法"><a href="#分别申明-required和-optional方法" class="headerlink" title="分别申明@required和@optional方法"></a>分别申明@required和@optional方法</h2><p>下面打印验证协议方法<br>打印方法类似之前文章中介绍消息缓存<br>现在查看SampleClass遵循的协议</p>
<p><img src="/images/protocol_t.png" alt="protocol_t结构证明"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">2018-02-13 09:51:09.129854+0800 debug-objc[26530:1205183] 0x100002610</span><br><span class="line">(lldb) p (objc_class *)0x100002610</span><br><span class="line">(objc_class *) $0 = 0x0000000100002610</span><br><span class="line">(lldb) p (class_data_bits_t *)0x0000000100002630</span><br><span class="line">(class_data_bits_t *) $1 = 0x0000000100002630</span><br><span class="line">(lldb) p (class_rw_t *)$1-&gt;data()</span><br><span class="line">(class_rw_t *) $2 = 0x0000000100a21a80</span><br><span class="line">(lldb) p $2-&gt;protocols</span><br><span class="line">(protocol_array_t) $3 = &#123;</span><br><span class="line">  list_array_tt&lt;unsigned long, protocol_list_t&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = 0x0000000100002370</span><br><span class="line">      arrayAndFlag = 4294976368</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $3.beginLists()</span><br><span class="line">(protocol_list_t **) $4 = 0x0000000100a21aa0</span><br><span class="line">(lldb) p **$4</span><br><span class="line">(protocol_list_t) $5 = (count = 1, list = protocol_ref_t [] @ 0x00007fbc7e780c58)</span><br><span class="line">(lldb) p $5.list[0]</span><br><span class="line">(protocol_ref_t) $6 = 4294977080</span><br><span class="line">(lldb) p (protocol_t *)$6</span><br><span class="line">(protocol_t *) $7 = 0x0000000100002638</span><br><span class="line">(lldb) p *$7</span><br><span class="line">(protocol_t) $8 = &#123;</span><br><span class="line">  objc_object = &#123;</span><br><span class="line">    isa = &#123;</span><br><span class="line">      cls = Protocol</span><br><span class="line">      bits = 4302295240</span><br><span class="line">       = &#123;</span><br><span class="line">        nonpointer = 0</span><br><span class="line">        has_assoc = 0</span><br><span class="line">        has_cxx_dtor = 0</span><br><span class="line">        shiftcls = 537786905</span><br><span class="line">        magic = 0</span><br><span class="line">        weakly_referenced = 0</span><br><span class="line">        deallocating = 0</span><br><span class="line">        has_sidetable_rc = 0</span><br><span class="line">        extra_rc = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mangledName = 0x0000000100001f5e &quot;DogProtocol&quot;   //证明协议名称</span><br><span class="line">  protocols = 0x0000000000000000</span><br><span class="line">  instanceMethods = 0x0000000100002320</span><br><span class="line">  classMethods = 0x0000000000000000</span><br><span class="line">  optionalInstanceMethods = 0x0000000100002340</span><br><span class="line">  optionalClassMethods = 0x0000000000000000</span><br><span class="line">  instanceProperties = 0x0000000000000000</span><br><span class="line">  size = 96</span><br><span class="line">  flags = 0</span><br><span class="line">  _extendedMethodTypes = 0x0000000100002360</span><br><span class="line">  _demangledName = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  _classProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $8.instanceMethods  //打印实例方法</span><br><span class="line">(method_list_t *) $9 = 0x0000000100002320</span><br><span class="line">(lldb) p $9-&gt;get(0)</span><br><span class="line">(method_t) $10 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $11 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 1</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从打印记录可以看到，SampleClass 含有的协议是”DogProtocol”<br>协议含有的实例方法列表 只有required方法<br>如果将DogProtocol协议中的@optional申明注释，打印协议里面的实例方法</p>
<h2 id="required申明方法"><a href="#required申明方法" class="headerlink" title="required申明方法"></a>required申明方法</h2><p>可以看到协议的实例方法列表含有两个方法,分别是printName和printAge，都是@required申明的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *$7</span><br><span class="line">(protocol_t) $8 = &#123;</span><br><span class="line">  objc_object = &#123;</span><br><span class="line">    isa = &#123;</span><br><span class="line">      cls = Protocol</span><br><span class="line">      bits = 4302295240</span><br><span class="line">       = &#123;</span><br><span class="line">        nonpointer = 0</span><br><span class="line">        has_assoc = 0</span><br><span class="line">        has_cxx_dtor = 0</span><br><span class="line">        shiftcls = 537786905</span><br><span class="line">        magic = 0</span><br><span class="line">        weakly_referenced = 0</span><br><span class="line">        deallocating = 0</span><br><span class="line">        has_sidetable_rc = 0</span><br><span class="line">        extra_rc = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mangledName = 0x0000000100001f5e &quot;DogProtocol&quot;</span><br><span class="line">  protocols = 0x0000000000000000</span><br><span class="line">  instanceMethods = 0x0000000100002320</span><br><span class="line">  classMethods = 0x0000000000000000</span><br><span class="line">  optionalInstanceMethods = 0x0000000000000000</span><br><span class="line">  optionalClassMethods = 0x0000000000000000</span><br><span class="line">  instanceProperties = 0x0000000000000000</span><br><span class="line">  size = 96</span><br><span class="line">  flags = 0</span><br><span class="line">  _extendedMethodTypes = 0x0000000100002358</span><br><span class="line">  _demangledName = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  _classProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $8.instanceMethods()</span><br><span class="line">error: called object type &apos;method_list_t *&apos; is not a function or function pointer</span><br><span class="line">(lldb) p $8.instanceMethods</span><br><span class="line">(method_list_t *) $9 = 0x0000000100002320</span><br><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $10 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 2</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(0)</span><br><span class="line">(method_t) $11 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10-&gt;get(1)</span><br><span class="line">(method_t) $12 = &#123;</span><br><span class="line">  name = &quot;printAge&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="默认不申明"><a href="#默认不申明" class="headerlink" title="默认不申明"></a>默认不申明</h2><p>打印说明默认的就是required<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $10 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 2</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(0)</span><br><span class="line">(method_t) $11 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(1)</span><br><span class="line">(method_t) $12 = &#123;</span><br><span class="line">  name = &quot;printAge&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="将方法都申明为optional"><a href="#将方法都申明为optional" class="headerlink" title="将方法都申明为optional"></a>将方法都申明为optional</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@protocol DogProtocol</span><br><span class="line">@optional</span><br><span class="line">- (void)printName;</span><br><span class="line">- (void)printAge;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>打印,可以看到协议的实例方法为空，但是optionalInstanceMethods有两个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)0x100002608</span><br><span class="line">(objc_class *) $0 = 0x0000000100002608</span><br><span class="line">(lldb) p (class_data_bits_t *)0x0000000100002628</span><br><span class="line">(class_data_bits_t *) $1 = 0x0000000100002628</span><br><span class="line">(lldb) p (class_rw_t *)$1-&gt;data()</span><br><span class="line">(class_rw_t *) $2 = 0x0000000100b909a0</span><br><span class="line">(lldb) p $2-&gt;protocols</span><br><span class="line">(protocol_array_t) $3 = &#123;</span><br><span class="line">  list_array_tt&lt;unsigned long, protocol_list_t&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = 0x0000000100002368</span><br><span class="line">      arrayAndFlag = 4294976360</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $3.beginLists()</span><br><span class="line">(protocol_list_t **) $4 = 0x0000000100b909c0</span><br><span class="line">(lldb) p $5.list[0]</span><br><span class="line">error: use of undeclared identifier &apos;$5&apos;</span><br><span class="line">(lldb) p **$4</span><br><span class="line">(protocol_list_t) $5 = (count = 1, list = protocol_ref_t [] @ 0x00007fbc7e1dad48)</span><br><span class="line">(lldb) p $5.list[0]</span><br><span class="line">(protocol_ref_t) $6 = 4294977072</span><br><span class="line">(lldb) p (protocol_t *)$6</span><br><span class="line">(protocol_t *) $7 = 0x0000000100002630</span><br><span class="line">(lldb) p *$7</span><br><span class="line">(protocol_t) $8 = &#123;</span><br><span class="line">  objc_object = &#123;</span><br><span class="line">    isa = &#123;</span><br><span class="line">      cls = Protocol</span><br><span class="line">      bits = 4302295240</span><br><span class="line">       = &#123;</span><br><span class="line">        nonpointer = 0</span><br><span class="line">        has_assoc = 0</span><br><span class="line">        has_cxx_dtor = 0</span><br><span class="line">        shiftcls = 537786905</span><br><span class="line">        magic = 0</span><br><span class="line">        weakly_referenced = 0</span><br><span class="line">        deallocating = 0</span><br><span class="line">        has_sidetable_rc = 0</span><br><span class="line">        extra_rc = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mangledName = 0x0000000100001f5e &quot;DogProtocol&quot;</span><br><span class="line">  protocols = 0x0000000000000000</span><br><span class="line">  instanceMethods = 0x0000000000000000</span><br><span class="line">  classMethods = 0x0000000000000000</span><br><span class="line">  optionalInstanceMethods = 0x0000000100002320</span><br><span class="line">  optionalClassMethods = 0x0000000000000000</span><br><span class="line">  instanceProperties = 0x0000000000000000</span><br><span class="line">  size = 96</span><br><span class="line">  flags = 0</span><br><span class="line">  _extendedMethodTypes = 0x0000000100002358</span><br><span class="line">  _demangledName = 0x0000000000000000 &lt;no value available&gt;</span><br><span class="line">  _classProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $8.optionalInstanceMethods</span><br><span class="line">(method_list_t *) $9 = 0x0000000100002320</span><br><span class="line">(lldb) p *$9</span><br><span class="line">(method_list_t) $10 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 3&gt; = &#123;</span><br><span class="line">    entsizeAndFlags = 24</span><br><span class="line">    count = 2</span><br><span class="line">    first = &#123;</span><br><span class="line">      name = &quot;printName&quot;</span><br><span class="line">      types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">      imp = 0x0000000000000000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(0)</span><br><span class="line">(method_t) $11 = &#123;</span><br><span class="line">  name = &quot;printName&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $10.get(1)</span><br><span class="line">(method_t) $12 = &#123;</span><br><span class="line">  name = &quot;printAge&quot;</span><br><span class="line">  types = 0x0000000100001f6a &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/02/11/Objc-category篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/11/Objc-category篇/" itemprop="url">Objc category篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-11T11:05:02+08:00">
                2018-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在之前的文章中，分析load有提到对category中的load方法进行存储调用<br>现在我们来窥探一下category的作用</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>category主要用于动态的为类添加一些方法和属性<br>在OC中，catefory是在运行期决议的。当编译完成,对象的内存布局已经确定，我们无法为类添加实例变量，通过category,可以设置关联对象，为类动态添加属性,也可以添加方法</p>
<p>注:<br>extension它是在编译期，和类的.h和.m构成类的结构，可以添加实例变量，一般用于隐藏类的私有属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Category</span><br><span class="line">@interface PattyDog (Category)</span><br><span class="line">// 只会生成set,get方法的声明,创建的对象没有name属性.</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Extension(类扩展)</span><br><span class="line">@interface PattyDog</span><br><span class="line">// 创建name成员变量,并声明和实现set,get方法</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>在objc-runtime-new.h中,申明了category的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct category_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    struct method_list_t *instanceMethods;</span><br><span class="line">    struct method_list_t *classMethods;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    struct property_list_t *instanceProperties;</span><br><span class="line">    // Fields below this point are not always present on disk.</span><br><span class="line">    struct property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *methodsForMeta(bool isMeta) &#123;</span><br><span class="line">        if (isMeta) return classMethods;</span><br><span class="line">        else return instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以了解到，category包含了</p>
<ul>
<li>类的名字</li>
<li>类</li>
<li>给类添加的  实例方法列表</li>
<li>给类添加的  类方法列表</li>
<li>给类添加的  协议列表</li>
<li>给类添加的  属性列表</li>
<li>给类添加的  类属性列表</li>
</ul>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Dog.h</span><br><span class="line">@interface Dog: NSObject</span><br><span class="line">- (void)printName;</span><br><span class="line">@end</span><br><span class="line">@interface Dog (Patty)</span><br><span class="line">@property(nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//Dog.m</span><br><span class="line">@implementation Dog</span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;CommonDog&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Dog(Patty)</span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;PattyDog&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>下面将Dog.m文件进行clang编译，看下编译之后有哪些改动，以下是主要的变化</p>
<ul>
<li>category_t 结构体含有实例方法_CATEGORY_INSTANCE_METHODS<em>Dog</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Dog_$_Patty,</span><br><span class="line"></span><br><span class="line">具体实现存储的方法只有一个，方法名称是printName，方法编码，函数地址都存储在里面</span><br><span class="line">__attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line"> sizeof(_objc_method),</span><br><span class="line"> 1,</span><br><span class="line"> &#123;&#123;(struct objc_selector *)&quot;printName&quot;, &quot;v16@0:8&quot;, (void *)_I_Dog_Patty_printName&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">static __NSConstantStringImpl __NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_0 __attribute__ ((section (&quot;__DATA, __cfstring&quot;))) = &#123;__CFConstantStringClassReference,0x000007c8,&quot;CommonDog&quot;,9&#125;;</span><br><span class="line">static __NSConstantStringImpl __NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_1 __attribute__ ((section (&quot;__DATA, __cfstring&quot;))) = &#123;__CFConstantStringClassReference,0x000007c8,&quot;PattyDog&quot;,8&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// @implementation Dog</span><br><span class="line"></span><br><span class="line">static void _I_Dog_printName(Dog * self, SEL _cmd) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_0);</span><br><span class="line">&#125;</span><br><span class="line">// @end</span><br><span class="line">// @implementation Dog(Patty)</span><br><span class="line"></span><br><span class="line">static void _I_Dog_Patty_printName(Dog * self, SEL _cmd) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main1_a5e2f0_mi_1);</span><br><span class="line">&#125;</span><br><span class="line">// @end</span><br><span class="line"></span><br><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">	unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">	unsigned int method_count;</span><br><span class="line">	struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Dog_$_Patty __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">	sizeof(_objc_method),</span><br><span class="line">	1,</span><br><span class="line">	&#123;&#123;(struct objc_selector *)&quot;printName&quot;, &quot;v16@0:8&quot;, (void *)_I_Dog_Patty_printName&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_Dog;</span><br><span class="line"></span><br><span class="line">static struct _category_t _OBJC_$_CATEGORY_Dog_$_Patty __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) =</span><br><span class="line">&#123;</span><br><span class="line">	&quot;Dog&quot;,</span><br><span class="line">	0, // &amp;OBJC_CLASS_$_Dog,</span><br><span class="line">	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Dog_$_Patty,</span><br><span class="line">	0,</span><br><span class="line">	0,</span><br><span class="line">	0,</span><br><span class="line">&#125;;</span><br><span class="line">static void OBJC_CATEGORY_SETUP_$_Dog_$_Patty(void ) &#123;</span><br><span class="line">	_OBJC_$_CATEGORY_Dog_$_Patty.cls = &amp;OBJC_CLASS_$_Dog;</span><br><span class="line">&#125;</span><br><span class="line">#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)</span><br><span class="line">__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">	(void *)&amp;OBJC_CATEGORY_SETUP_$_Dog_$_Patty,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">	&amp;OBJC_CLASS_$_Dog,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">	&amp;_OBJC_$_CATEGORY_Dog_$_Patty,</span><br><span class="line">&#125;;</span><br><span class="line">static struct IMAGE_INFO &#123; unsigned version; unsigned flag; &#125; _OBJC_IMAGE_INFO = &#123; 0, 2 &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>category是由OC动态加载（runtime）,多个category的调用顺序是无法保证的，<br>一般来说category内的方法需要添加前缀可避免重复添加导致编译出错<br>OC的运行入口，在objc-os.mm内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized = false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized = true;</span><br><span class="line"></span><br><span class="line">    // fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_2_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的方法，在map_2_images函数里面进入加载images,最终调用到_read_images方法</p>
<ul>
<li>获取OC的category列表catlist</li>
<li>然后remapClass</li>
<li>如果category含有实例方法，协议或者属性列表，添加到类上</li>
<li>如果category含有类方法列表，协议,添加到类的metaclass上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">// Discover categories.</span><br><span class="line">    for (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist =</span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);//从表中取出cat对应的cls</span><br><span class="line"></span><br><span class="line">            if (!cls) &#123;</span><br><span class="line">                // Category&apos;s target class is missing (probably weak-linked).</span><br><span class="line">                // Disavow any knowledge of this category.</span><br><span class="line">                catlist[i] = nil;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span><br><span class="line">                                 &quot;missing weak-linked target class&quot;,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bool classExists = NO;</span><br><span class="line">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties)</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                if (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,</span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name,</span><br><span class="line">                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                if (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,</span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>绑定category的方法、协议等映射到类上，内部调用方法addUnattachedCategoryForClass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void addUnattachedCategoryForClass(category_t *cat, Class cls,</span><br><span class="line">                                          header_info *catHeader)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    // DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead</span><br><span class="line">    NXMapTable *cats = unattachedCategories();  //初始化NXMapTable</span><br><span class="line">    category_list *list;</span><br><span class="line"></span><br><span class="line">    list = (category_list *)NXMapGet(cats, cls);//去Table表中查找对应cls的category列表</span><br><span class="line">    if (!list) &#123;</span><br><span class="line">        list = (category_list *)</span><br><span class="line">            calloc(sizeof(*list) + sizeof(list-&gt;list[0]), 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        list = (category_list *)</span><br><span class="line">            realloc(list, sizeof(*list) + sizeof(list-&gt;list[0]) * (list-&gt;count + 1));</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;list[list-&gt;count++] = (locstamped_category_t)&#123;cat, catHeader&#125;;//扩大list</span><br><span class="line">    NXMapInsert(cats, cls, list); //将cls对应的list插入到表中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>remethodizeClass 将cat一系列方法添加到类上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">static void remethodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // Re-methodizing: check for more categories</span><br><span class="line">    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        attachCategories(cls, cats, true /*flush caches*/);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // fixme rearrange to remove these intermediate allocations</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int propcount = 0;</span><br><span class="line">    int protocount = 0;</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    bool fromBundle = NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        property_list_t *proplist =</span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键在attachLists方法，将cls的rw对应的方法列表，属性列表，协议列表进行添加列表</p>
<ul>
<li>memmove<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">       if (addedCount == 0) return;</span><br><span class="line"></span><br><span class="line">       if (hasArray()) &#123;</span><br><span class="line">           // many lists -&gt; many lists</span><br><span class="line">           uint32_t oldCount = array()-&gt;count;</span><br><span class="line">           uint32_t newCount = oldCount + addedCount;</span><br><span class="line">           setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">           array()-&gt;count = newCount;</span><br><span class="line">           memmove(array()-&gt;lists + addedCount, array()-&gt;lists,</span><br><span class="line">                   oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">           memcpy(array()-&gt;lists, addedLists,</span><br><span class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">       &#125;</span><br><span class="line">       else if (!list  &amp;&amp;  addedCount == 1) &#123;</span><br><span class="line">           // 0 lists -&gt; 1 list</span><br><span class="line">           list = addedLists[0];</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123;</span><br><span class="line">           // 1 list -&gt; many lists</span><br><span class="line">           List* oldList = list;</span><br><span class="line">           uint32_t oldCount = oldList ? 1 : 0;</span><br><span class="line">           uint32_t newCount = oldCount + addedCount;</span><br><span class="line">           setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">           array()-&gt;count = newCount;</span><br><span class="line">           if (oldList) array()-&gt;lists[addedCount] = oldList;</span><br><span class="line">           memcpy(array()-&gt;lists, addedLists,</span><br><span class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>memmove和memcpy 两个C函数的操作，<br>将array先前的列表内容拷贝到新数组的末尾，然后将新添加的list插入到新数组的头部<br>解释了category的特性</p>
<ul>
<li>category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加方法后，类的方法列表里会有两个methodA</li>
<li>category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，也就是我们常说category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会停止查找，殊不知后面可能还有一样名字的方法。</li>
<li>category关联对象特性在之前文章中，请自行翻阅</li>
</ul>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>memmove(p2, p1, len) 内存拷贝<br>将p1的前面len长度的字符，拷贝到p2</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li>c函数 memmove和memcpy的区别 <a href="http://blog.jobbole.com/108842/" target="_blank" rel="noopener">http://blog.jobbole.com/108842/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/02/03/Objc关联对象的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/03/Objc关联对象的实现/" itemprop="url">Objc关联对象的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-03T15:36:52+08:00">
                2018-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天主要来聊一聊以下三个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void *key) &#123;</span><br><span class="line">    return _object_get_associative_reference(object, (void *)key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">    _object_set_associative_reference(object, (void *)key, value, policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void objc_removeAssociatedObjects(id object)</span><br><span class="line">&#123;</span><br><span class="line">    if (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        _object_remove_assocations(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分类添加属性的时候，由于系统没有办法自动将属性添加set和get方法，需要自动实现，就需要以上的方法来实现</p>
<h2 id="事例code"><a href="#事例code" class="headerlink" title="事例code"></a>事例code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@interface Dog: NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation Dog</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Dog(DanceCategory)</span><br><span class="line">@property (nonatomic, strong) NSString *categoryProperty;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog(DanceCategory)</span><br><span class="line">- (NSString *)categoryProperty</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">- (void)setCategoryProperty:(NSString *)categoryProperty</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(categoryProperty), categoryProperty, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark -main</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Dog *dd = [[Dog alloc] init];</span><br><span class="line">        dd.categoryProperty = @&quot;分类属性&quot;;</span><br><span class="line">        dd.categoryProperty;</span><br><span class="line">        objc_removeAssociatedObjects(dd);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>先看下设置属性的方法调用顺序<br><img src="/images/分类属性-调用堆栈.png" alt="调用堆栈.png"></p>
<h3 id="object-set-associative-reference"><a href="#object-set-associative-reference" class="headerlink" title="object_set_associative_reference"></a>object_set_associative_reference</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line"></span><br><span class="line">    ObjcAssociation old_association(0, nil); //生成旧对象</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;  </span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i != associations.end()) &#123;</span><br><span class="line">                // secondary table exists</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second; //如果存在之前的值，给旧对象赋值</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // create the new association (first time).</span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // setting the association to nil breaks the association.</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果旧对象有值，进行释放</span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有几个主要的类</p>
<ul>
<li>AssociationsManager   全局，持有spinlock_t 和 AssociationsHashMap</li>
<li>AssociationsHashMap   全局单例</li>
<li>ObjectAssociationMap  </li>
<li>ObjcAssociation       真正关联对象的类，包含policy和value</li>
</ul>
<p>此处有个简单例子说明下关联对象在内存的存储形式，例子和图片出自此处(<a href="https://draveness.me/ao" target="_blank" rel="noopener">https://draveness.me/ao</a>)<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">        objc_setAssociatedObject(obj, <span class="keyword">@selector</span>(hello), <span class="string">@"Hello"</span>, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/association结构.png" alt="association结构"></p>
<p>接着分析上面源代码:</p>
<ul>
<li>初始生成old_association，便于存储旧对象以及清除旧值</li>
<li>acquireValue 方法内部是对value进行copy或者retain</li>
<li>初始化生成或者取出唯一的全局单例AssociationsManager 和 AssociationsHashMap</li>
<li>disguised_object 是根据object生成的</li>
</ul>
<p><strong>两种情况</strong><br>下面根据newValue是否为空来处理的</p>
<ol>
<li><p>newValue 存在:设置或更新值的时候</p>
<ul>
<li>在AssociationsHashMap中根据disguised_object作为key去取对应的object的AssociationsHashMap</li>
<li><p>如果map存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectAssociationMap *refs = i-&gt;second</span><br><span class="line">ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">if (j != refs-&gt;end()) &#123; //如果存在旧值，将旧值赋值给临时变量old_association，便于最后释放</span><br><span class="line">    old_association = j-&gt;second;</span><br><span class="line">    j-&gt;second = ObjcAssociation(policy, new_value);//然后重新赋值</span><br><span class="line">&#125; else &#123; //如果不存在旧值，给map表设置key和value</span><br><span class="line">    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果map不存在，新生成ObjectAssociationMap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAssociationMap *refs = new ObjectAssociationMap; //新生成ObjectAssociationMap</span><br><span class="line">associations[disguised_object] = refs; //将disguised_object作为key ,value是ObjectAssociationMap</span><br><span class="line">(*refs)[key] = ObjcAssociation(policy, new_value) //在ObjectAssociationMap中插入key和对应的ObjcAssociation</span><br><span class="line">object-&gt;setHasAssociatedObjects();//标记对象对应的标记位</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>newValue=nil 删除一个关联对象</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">if (i !=  associations.end()) &#123; //如果存在该object对应的map表，</span><br><span class="line">    ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">    ObjectAssociationMap::iterator j = refs-&gt;find(key); //从ObjectAssociationMap表中取出对应的key所对应的association</span><br><span class="line">    if (j != refs-&gt;end()) &#123;</span><br><span class="line">        old_association = j-&gt;second; //将存在的值赋值给old_association</span><br><span class="line">        refs-&gt;erase(j); //从表中将key对应的ObjcAssociation进行擦除</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>最后 如果存在旧值，将旧值释放即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (old_association.hasValue()) ReleaseValue()(old_association);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="object-get-associative-reference"><a href="#object-get-associative-reference" class="headerlink" title="object_get_associative_reference"></a>object_get_associative_reference</h3><p><img src="/images/分类属性-get.png" alt="getAssociation堆栈图"><br>上图是调用对象属性的get方法执行的堆栈结构图</p>
<p>流程比上面的方法相对简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id _object_get_associative_reference(id object, void *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object); //从AssociationsHashMap表中查找对象</span><br><span class="line">        if (i != associations.end()) &#123; //如果存在对象的话</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key); //从对象对应的ObjectAssociationMap表中根据key取出对应的value</span><br><span class="line">            if (j != refs-&gt;end()) &#123; //如果存在value</span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.value(); //将存在的ObjcAssociation属性对应赋值</span><br><span class="line">                policy = entry.policy();</span><br><span class="line">                if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);   //对value进行retain</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);</span><br><span class="line">    &#125;</span><br><span class="line">    return value; //最后将关联对象 ObjcAssociation 的值进行返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="objc-removeAssociatedObjects"><a href="#objc-removeAssociatedObjects" class="headerlink" title="objc_removeAssociatedObjects"></a>objc_removeAssociatedObjects</h2><p>先来看下调用remove方法的函数调用<br><img src="/images/分类属性-remove.png" alt="remove"><br>打印isa的结构，可以看到对象的has_assoc 标记为1，也就是存在关联对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void _object_remove_assocations(id object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        if (associations.size() == 0) return; //如果不存在 返回</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object); //查找object对应的表</span><br><span class="line">        if (i != associations.end()) &#123;</span><br><span class="line">            // copy all of the associations that need to be removed.</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second; //存在的话取出对应的object表</span><br><span class="line">            for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);//将表的元素存入elements</span><br><span class="line">            &#125;</span><br><span class="line">            delete refs; //移除object对应的表</span><br><span class="line">            associations.erase(i); //同时在AssociationsHashMap表中将object也移除</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // the calls to releaseValue() happen outside of the lock.</span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue()); //通过循环将elements元素都进行释放</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文就是对于如何给分类添加属性操作进行解读</p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/02/02/KVO-实现原理分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/02/KVO-实现原理分析/" itemprop="url">KVO 实现原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-02T11:59:38+08:00">
                2018-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在之前，一直以为类的isa结构图就是那张很经典的图，但是才发现有个特例情况下，有点变化</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  PattyCat *pcat = [[PattyCat alloc] init];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   NSLog(@&quot;%p--pcat的isa:%p--%@-%@-%@&quot;,(object_getClass([PattyCat class])),object_getClass(pcat),object_getClass(pcat),pcat.superclass,[object_getClass(pcat) superclass]);</span><br><span class="line">   /*</span><br><span class="line">    0x10408c910--pcat的isa:0x10408c870--PattyCat-Cat-Cat</span><br><span class="line">    */</span><br><span class="line">   [pcat addObserver:self</span><br><span class="line">         forKeyPath:@&quot;address&quot;</span><br><span class="line">         options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld</span><br><span class="line">         context:nil];</span><br><span class="line">   pcat.address = @&quot;有地址了&quot;;</span><br><span class="line">//    NSLog(@&quot;%@--%p&quot;,(object_getClass([PattyCat class])),object_getClass(pcat));</span><br><span class="line"></span><br><span class="line">   NSLog(@&quot;%p---pcat的isa:%p-新的子类是:%@-新的子类的isa:%p-%@-%@&quot;,(object_getClass([PattyCat class])),object_getClass(pcat),object_getClass(pcat),object_getClass(object_getClass(pcat)),pcat.superclass,[object_getClass(pcat) superclass]);</span><br><span class="line">   /*</span><br><span class="line">    0x10408c910---pcat的isa:0x7b24000260a0-新的子类是:NSKVONotifying_PattyCat-新的子类的isa:0x7b2400026130-Cat-PattyCat</span><br><span class="line">    */</span><br><span class="line">   [pcat removeObserver:self forKeyPath:@&quot;address&quot;];</span><br><span class="line"></span><br><span class="line">  NSLog(@&quot;%p--pcat的isa:%p--%@-%@-%@&quot;,(object_getClass([PattyCat class])),object_getClass(pcat),object_getClass(pcat),pcat.superclass,[object_getClass(pcat) superclass]);</span><br><span class="line">   /*</span><br><span class="line">    0x10408c910--pcat的isa:0x10408c870--PattyCat-Cat-Cat</span><br><span class="line">    */</span><br></pre></td></tr></table></figure>
<p>在当前类中引入对象pcat,监听它的KVO变化之后，然后移除KVO，对象的isa以及superClass前后的变化如上</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>苹果文档介绍</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class ..</p>
</blockquote>
<p>简要的来说，在我们对某个对象完成监听的注册后，编译器会修改监听对象（上文中的pcat）的isa指针，让这个指针指向一个新生成的中间类，中间类的命名格式如 NSKVONotifying_XX (XX 是pcat对象的class)</p>
<p>苹果还 <strong>重写了这个子类的class方法跟description方法</strong> 来掩人耳目。<br>另外，新类相对于父类添加了一个NSKVONotifying_前缀，添加这个前缀是为了避免多次创建监听子类，节省资源</p>
<p>以上通过object_getClass(pcat)命令得到了KVO前为PattyCat   KVO后值为 NSKVONotifying_PattyCat</p>
<p>注: 以下两个方式得到类的指针是一样的哦<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p object_getClass(pcat)</span><br><span class="line">(Class) $0 = PattyCat</span><br><span class="line">(lldb) p (void *)$0</span><br><span class="line">(void *) $1 = 0x0000000100001188</span><br><span class="line"></span><br><span class="line">(lldb) p (objc_class *)[PattyCat class]</span><br><span class="line">(objc_class *) $2 = 0x0000000100001188</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对实例对象进行KVO观察的时候，实际上对象的isa已经不是之前的类对象了<br>移除KVO之后，恢复之前效果</p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/flower.jpg"
               alt="Patty" />
          <p class="site-author-name" itemprop="name">Patty</p>
           
              <p class="site-description motion-element" itemprop="description">Life's like a movie, write your own ending, keep believing, keep pretending.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Patty</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_uv">
  本站总访问量<span id="busuanzi_value_site_uv"></span>次
</span>
<span class="post-count"> 博客全站共68.4k字</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
