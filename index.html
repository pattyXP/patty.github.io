<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, Patty" />





  <link rel="alternate" href="/atom.xml" title="温暖的弦" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Life&apos;s like a movie, write your own ending, keep believing, keep pretending.">
<meta property="og:type" content="website">
<meta property="og:title" content="温暖的弦">
<meta property="og:url" content="https://pattyxp.github.io/index.html">
<meta property="og:site_name" content="温暖的弦">
<meta property="og:description" content="Life&apos;s like a movie, write your own ending, keep believing, keep pretending.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="温暖的弦">
<meta name="twitter:description" content="Life&apos;s like a movie, write your own ending, keep believing, keep pretending.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://pattyxp.github.io/"/>





  <title>温暖的弦</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">温暖的弦</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/07/02/WWDC-Notification/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/WWDC-Notification/" itemprop="url">WWDC-Notification</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T21:00:00+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2018年WWDC召开至今， 围绕User Notification相关的iOS12特性介绍非常多<br>此次主要是针对用户体验带来的分组通知特性及相关的交互，下面围绕以下几点展开说明</p>
<ul>
<li>Grouped Notifications</li>
<li>Notification content extensions</li>
<li>Notification management</li>
<li>Provisional authorization</li>
<li>Critical alerts</li>
</ul>
<h3 id="Grouped-Notifications"><a href="#Grouped-Notifications" class="headerlink" title="Grouped Notifications"></a>Grouped Notifications</h3><p><img src="/images/WWDC-group1.png" alt="WWDC-group1"></p>
<p>iOS12 之后</p>
<p><img src="/images/WWDC-group2.png" alt="WWDC-group2"></p>
<p>同一APP的通知可被合成一个通知组，点击可以展开组里的通知<br>通知的分组可以采用两种方式实现:</p>
<ul>
<li>自动实现 （Automatic grouping）系统根据APP的bundle id 分组，开发者不需要进行额外操作</li>
<li>线程标识 （Thread identifier） <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本地通知</span></span><br><span class="line"><span class="keyword">let</span> content = <span class="type">UNMutableNotificationContent</span>()</span><br><span class="line">content.title = <span class="string">"New Photo"</span></span><br><span class="line">content.body = <span class="string">"Jane Doe posted a new photo"</span></span><br><span class="line">content.threadIdentifier = <span class="string">"thread-identifier"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程通知</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aps"</span> : &#123;</span><br><span class="line">        <span class="string">"alert"</span> : &#123;</span><br><span class="line">            <span class="string">"title"</span> : <span class="string">"New Photo"</span>,</span><br><span class="line">            <span class="string">"body"</span> : <span class="string">"Jane Doe posted a new photo"</span>,</span><br><span class="line">            <span class="string">"thread-id"</span> : <span class="string">"thread-identifier"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/images/WWDC-group3.png" alt="WWDC-group3"></p>
<p>用户可以在设置里控制管理方式<br><img src="/images/WWDC-group4.png" alt="WWDC-group4"><br><img src="/images/WWDC-group5.png" alt="WWDC-group5"></p>
<h3 id="Notification-content-extensions"><a href="#Notification-content-extensions" class="headerlink" title="Notification content extensions"></a>Notification content extensions</h3><p>此特性在iOS 10就出现了,用于自定义通知视图的样式,在iOS 12上针对此做了提升</p>
<p><img src="/images/WWDC-group12.png" alt="WWDC-group12"></p>
<ul>
<li>在plist中设置属性，会影响通知界面的交互功能</li>
</ul>
<p><img src="/images/WWDC-group13.png" alt="WWDC-group13"></p>
<p><img src="/images/WWDC-group14.png" alt="WWDC-group14"></p>
<ul>
<li>默认中间部分交互是没有的，需要在plist表中增加属性<code>UNNotificationExtensionUserInteractionEnabled</code>为<code>YES</code></li>
</ul>
<p><img src="/images/WWDC-group15.png" alt="WWDC-group15"></p>
<ul>
<li>notificationActions<br><code>notificationActions</code>允许获取用户当前的操作，更新新的操作</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSExtensionContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">12.0</span>, *)</span><br><span class="line">    <span class="keyword">var</span> notificationActions: [<span class="type">UNNotificationAction</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notification Content Extensions</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationViewController</span>: <span class="title">UIViewController</span>, <span class="title">UNNotificationContentExtension</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> response: UNNotificationResponse, completionHandler completion:</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="params">(UNNotificationContentExtensionResponseOption)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> response.actionIdentifier == <span class="string">"like-action"</span> &#123;</span><br><span class="line">            <span class="comment">// Update state...</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> unlikeAction = <span class="type">UNNotificationAction</span>(identifier: <span class="string">"unlike-action"</span>,</span><br><span class="line">                                                             title: <span class="string">"Unlike"</span>, options: [])</span><br><span class="line">                <span class="keyword">let</span> currentActions = extensionContext?.notificationActions</span><br><span class="line">                <span class="keyword">let</span> commentAction = currentActions![<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">let</span> newActions = [ unlikeAction, commentAction ]</span><br><span class="line">                extensionContext?.notificationActions = newActions</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>添加Actions</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> likeAction = <span class="type">UNNotificationAction</span>(identifier: <span class="string">"like-action"</span>,</span><br><span class="line">                                           title: <span class="string">"Like"</span>,</span><br><span class="line">                                         options: [])</span><br><span class="line"><span class="keyword">let</span> commentAction = <span class="type">UNTextInputNotificationAction</span>(identifier: <span class="string">"comment-action"</span>,</span><br><span class="line">                                                       title: <span class="string">"Comment"</span>,</span><br><span class="line">                                                     options: [],</span><br><span class="line">                                        textInputButtonTitle: <span class="string">"Comment"</span>,</span><br><span class="line">                                        textInputPlaceholder: <span class="string">"Type here..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> category = <span class="type">UNNotificationCategory</span>(identifier: <span class="string">"extension-example"</span>,</span><br><span class="line">                                         actions: [ likeAction, commentAction ],</span><br><span class="line">                               intentIdentifiers: [],</span><br><span class="line">                                         options: [])</span><br><span class="line"></span><br><span class="line"><span class="type">UNUserNotificationCenter</span>.current().setNotificationCategories([ category ])</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理Actions</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UserNotifications</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppDelegate</span>: <span class="title">UNUserNotificationCenterDelegate</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">userNotificationCenter</span><span class="params">(<span class="number">_</span> center: UNUserNotificationCenter,</span></span></span><br><span class="line"><span class="function"><span class="params">            didReceive response: UNNotificationResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">            withCompletionHandler completionHandler: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Handle action response here</span></span><br><span class="line">            <span class="keyword">if</span> response.actionIdentifier == <span class="string">"like-action"</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                likeLabel?.text = <span class="string">"You liked this photo"</span></span><br><span class="line">                likedPhoto()</span><br><span class="line">            &#125;</span><br><span class="line">            completion(.doNotDismiss)</span><br><span class="line">            completion(.dismiss)</span><br><span class="line">            completion(.dismissAndForward)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动App</p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSExtensionContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@available</span>(iOS <span class="number">12.0</span>, *)</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">performNotificationDefaultAction</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UserNotificationsUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationViewController</span>: <span class="title">UIViewController</span>, <span class="title">UNNotificationContentExtension</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@IBOutlet</span> <span class="keyword">var</span> allCommentsButton: <span class="type">UIButton</span>?</span><br><span class="line">        ...</span><br><span class="line">        allCommentsButton?.addTarget(<span class="keyword">self</span>, action: #selector(launchApp), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">        ...</span><br><span class="line">        <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">launchApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">              extensionContext?.performNotificationDefaultAction()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>隐藏通知内容扩展界面<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSExtensionContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">12.0</span>, *)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dismissNotificationContentExtension</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UserNotificationsUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationViewController</span>: <span class="title">UIViewController</span>, <span class="title">UNNotificationContentExtension</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> likeButton: <span class="type">UIButton</span>?</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    likeButton?.addTarget(<span class="keyword">self</span>, action: #selector(likeButtonTapped), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">likeButtonTapped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        likedPhoto()</span><br><span class="line">        extensionContext?.dismissNotificationContentExtension()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的是，调用这个 API 并不会移除那条通知，如果需要移除通知可以调用下面的 API<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UNUserNotificationCenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeDeliveredNotifications</span><span class="params">(withIdentifiers identifiers: [String])</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Notification-management"><a href="#Notification-management" class="headerlink" title="Notification management"></a>Notification management</h3><p>为方便用户操作应用的设置通知页面，在推送页面上加入了全新的管理页面方便操作</p>
<p><img src="/images/WWDC-group6.png" alt="WWDC-group6"></p>
<ul>
<li>隐式通知 (Deliver Quietly )    只会显示在通知中心，不会带有声音提醒，应用角标</li>
<li>显式推送（Deliver Prominently） 显示推送会开启所有的通知选项。</li>
</ul>
<p>管理页面的入口有三种方式进入</p>
<ul>
<li>系统根据用户操作自动给出<br><img src="/images/WWDC-group7.png" alt="WWDC-group7"></li>
<li>左滑通知<br><img src="/images/WWDC-group8.png" alt="WWDC-group8"></li>
<li>点击通知详情<br><img src="/images/WWDC-group9.png" alt="WWDC-group9"></li>
</ul>
<p>当然，在新的通知管理页面，iOS12 提供了新的方法可以根据需要自定义，当点击页面的按钮操作<br>可以通过以下方法获取该行为<br><img src="/images/WWDC-group10.png" alt="WWDC-group10"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> UserNotifications</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIApplicationDelegate</span>, <span class="title">UNUserNotificationCenterDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userNotificationCenter</span><span class="params">(<span class="number">_</span> center: UNUserNotificationCenter, openSettingsFor notification: UNNotification? )</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Provisional-authorization"><a href="#Provisional-authorization" class="headerlink" title="Provisional authorization"></a>Provisional authorization</h3><p>ios 12 提供了一种新的授权机制:临时授权<br>给用户推送的消息不需要通过用户授权弹窗，不过只能隐式推送给用户，不带系统声音和角标<br>在代码中只需要设置参数<code>provisional</code>即可</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Requesting Provisional Authorization</span></span><br><span class="line"><span class="keyword">let</span> notificationCenter = <span class="type">UNUserNotificationCenter</span>.current()</span><br><span class="line">    </span><br><span class="line">    notificationCenter.requestAuthorization(</span><br><span class="line">        options:[.badge, .sound, .alert, .provisional]) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Critical-alerts"><a href="#Critical-alerts" class="headerlink" title="Critical alerts"></a>Critical alerts</h3><p>在勿扰模式或关闭铃声的情况下依然可以收到重要的通知或App设置的铃声</p>
<blockquote>
<p>此类通知是需要用户里面采取行动的如医疗与健康相关的通知，家庭安全相关的通知，公共安全相关的通知</p>
</blockquote>
<p>如果需要设置，需要前往<img src="https://developer.apple.com/contact/request/?notifications-critical-alerts-entitlement/" alt="申请授权"></p>
<p>在通知的设置页面会有单独的设置开关<br><img src="/images/WWDC-group11.png" alt="WWDC-group11"></p>
<p>如需要设置，在代码中需要设置参数<code>criticalAlert</code>，用户会收到单独的重要提醒授权<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> notificationCenter = <span class="type">UNUserNotificationCenter</span>.current()</span><br><span class="line"></span><br><span class="line">    notificationCenter.requestAuthorization(</span><br><span class="line">        options:[.sound, .badge, .alert, .criticalAlert]) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地重要通知</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Critical alert with default sound</span></span><br><span class="line"><span class="keyword">let</span> content = <span class="type">UNMutableNotificationContent</span>()</span><br><span class="line">content.title = <span class="string">"WARNING: LOW BLOOD SUGAR"</span></span><br><span class="line">content.body = <span class="string">"Glucose level at 57."</span></span><br><span class="line">content.categoryIdentifier = <span class="string">"low-glucose—alert"</span></span><br><span class="line"><span class="comment">// 使用系统默认的重要提醒音</span></span><br><span class="line">content.sound = <span class="type">UNNotificationSound</span>.defaultCritical</span><br><span class="line"><span class="comment">// 使用自定义的重要提醒音和音量</span></span><br><span class="line">content.sound = <span class="type">UNNotificationSound</span>.criticalSoundNamed(@<span class="string">"warning-sound"</span> withAudioVolume: <span class="number">1.00</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程重要通知</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"aps"</span> : &#123;</span><br><span class="line">        <span class="string">"sound"</span> : &#123;</span><br><span class="line">            <span class="string">"critical"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"warning-sound.aiff"</span>,</span><br><span class="line">            <span class="string">"volume"</span>: <span class="number">1.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://devstreaming-cdn.apple.com/videos/wwdc/2018/710kz0ncc1u8bfxn6/710/710_whats_new_in_user_notifications.pdf" target="_blank" rel="noopener">https://devstreaming-cdn.apple.com/videos/wwdc/2018/710kz0ncc1u8bfxn6/710/710_whats_new_in_user_notifications.pdf</a></p>
<p><a href="https://juejin.im/post/5b1b7c3de51d4506ca62d787" target="_blank" rel="noopener">https://juejin.im/post/5b1b7c3de51d4506ca62d787</a></p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/06/20/YYModel解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/20/YYModel解析/" itemprop="url">YYModel解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-20T14:10:04+08:00">
                2018-06-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>Model的定义与实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYTemplateModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> type;   </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span>  *templateNames;      </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span>  *templateId;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>  *items;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYTemplateModel</span></span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)modelContainerPropertyGenericClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">             <span class="string">@"items"</span>: [YYItem <span class="keyword">class</span>]</span><br><span class="line">             &#125;;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)modelCustomPropertyMapper &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">             <span class="string">@"name"</span>: @[<span class="string">@"name"</span>, <span class="string">@"Name"</span>],</span><br><span class="line">             <span class="string">@"templateNames"</span>:@[<span class="string">@"templateName"</span>],         </span><br><span class="line">             <span class="string">@"templateId"</span>:<span class="string">@"id"</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际在使用中，通常是将Model与json进行相互转换</p>
<h2 id="YYModel-解析流程"><a href="#YYModel-解析流程" class="headerlink" title="YYModel 解析流程"></a>YYModel 解析流程</h2><h3 id="yy-modelToJSONObject-NSObject-YYModel-m-model转为json"><a href="#yy-modelToJSONObject-NSObject-YYModel-m-model转为json" class="headerlink" title="yy_modelToJSONObject (NSObject+YYModel.m)  model转为json"></a>yy_modelToJSONObject (NSObject+YYModel.m)  model转为json</h3><p>实际是对<code>ModelToJSONObjectRecursive</code>封装</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)yy_modelToJSONObject &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Apple said:</span></span><br><span class="line"><span class="comment">     The top level object is an NSArray or NSDictionary.</span></span><br><span class="line"><span class="comment">     All objects are instances of NSString, NSNumber, NSArray, NSDictionary, or NSNull.</span></span><br><span class="line"><span class="comment">     All dictionary keys are instances of NSString.</span></span><br><span class="line"><span class="comment">     Numbers are not NaN or infinity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">id</span> jsonObject = ModelToJSONObjectRecursive(<span class="keyword">self</span>); </span><br><span class="line">    <span class="comment">//对Model进行类型判断，符合指定类型才返回，否则返回nil</span></span><br><span class="line">    <span class="comment">//返回值类型包括 NSString,NSNumber，NSArray,NSDictionary,or NSNull</span></span><br><span class="line">    <span class="keyword">if</span> ([jsonObject isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> jsonObject;</span><br><span class="line">    <span class="keyword">if</span> ([jsonObject isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> jsonObject;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ModelToJSONObjectRecursive"><a href="#ModelToJSONObjectRecursive" class="headerlink" title="ModelToJSONObjectRecursive"></a>ModelToJSONObjectRecursive</h3><p>将Object转为json并返回</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> ModelToJSONObjectRecursive(<span class="built_in">NSObject</span> *model) &#123;</span><br><span class="line">    <span class="comment">//进行基础类型判断，如果满足直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!model || model == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSURL</span> *)model).absoluteString;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSAttributedString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSAttributedString</span> *)model).string;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDate</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> [YYISODateFormatter() stringFromDate:(<span class="keyword">id</span>)model];</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是自定义类型判断</span></span><br><span class="line"></span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model <span class="keyword">class</span>]];</span><br><span class="line">    <span class="comment">//根据model转为YYModelMeta,，此处对modelMeta的获取和设置都有加信号量控制，防止出现线程问题</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!modelMeta || modelMeta-&gt;_keyMappedCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *result = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">64</span>];</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSMutableDictionary</span> *dic = result; <span class="comment">// avoid retain and release in block</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历mapper</span></span><br><span class="line">    [modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!propertyMeta-&gt;_<span class="keyword">getter</span>) <span class="keyword">return</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_isCNumber) &#123; <span class="comment">//匹配CNumber类型</span></span><br><span class="line">            value = ModelCreateNumberFromProperty(model, propertyMeta);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMeta-&gt;_nsType) &#123; <span class="comment">//大部分情况执行</span></span><br><span class="line">            <span class="keyword">id</span> v = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);<span class="comment">//从model获取对应属性propertyMeta的值，赋值给V</span></span><br><span class="line">            value = ModelToJSONObjectRecursive(v); <span class="comment">//对V的类型做判断，如果是基础类型直接返回赋值给value</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeObject: &#123;</span><br><span class="line">                    <span class="keyword">id</span> v = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = ModelToJSONObjectRecursive(v);</span><br><span class="line">                    <span class="keyword">if</span> (value == (<span class="keyword">id</span>)kCFNull) value = <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeClass: &#123;</span><br><span class="line">                    Class v = ((Class (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromClass</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeSEL: &#123;</span><br><span class="line">                    SEL v = ((SEL (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)((<span class="keyword">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromSelector</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!value) <span class="keyword">return</span>; <span class="comment">//非空判断</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyPath) &#123; </span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *superDic = dic;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *subDic = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *key = propertyMeta-&gt;_mappedToKeyPath[i];</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> == max) &#123; <span class="comment">// end</span></span><br><span class="line">                    <span class="keyword">if</span> (!superDic[key]) superDic[key] = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                subDic = superDic[key];</span><br><span class="line">                <span class="keyword">if</span> (subDic) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ([subDic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                        subDic = subDic.mutableCopy;</span><br><span class="line">                        superDic[key] = subDic;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    subDic = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">                    superDic[key] = subDic;</span><br><span class="line">                &#125;</span><br><span class="line">                superDic = subDic;</span><br><span class="line">                subDic = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//大部分情况</span></span><br><span class="line">            <span class="keyword">if</span> (!dic[propertyMeta-&gt;_mappedToKey]) &#123;</span><br><span class="line">                dic[propertyMeta-&gt;_mappedToKey] = value;  <span class="comment">//dic 赋值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomTransformToDictionary) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> suc = [((<span class="keyword">id</span>&lt;YYModel&gt;)model) modelCustomTransformToDictionary:dic];</span><br><span class="line">        <span class="keyword">if</span> (!suc) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// result = dic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ModelToJSONObjectRecursive</code>方法总结</p>
<ul>
<li>判断基础类型，直接返回</li>
<li>自定义类型，初始化生成<code>YYModelMeta</code>实例</li>
<li>遍历mapper方法，执行propertyMeta的getter方法，将返回值赋给dic返回</li>
</ul>
<h3 id="YYModelMeta初始化"><a href="#YYModelMeta初始化" class="headerlink" title="YYModelMeta初始化"></a>YYModelMeta初始化</h3><p><img src="/images/YYModelMeta初始化.png" alt="YYModelMeta初始化"></p>
<p><code>- (instancetype)initWithClass:(Class)cls</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithClass:(Class)cls &#123;</span><br><span class="line">    //初始化YYClassInfo</span><br><span class="line">    YYClassInfo *classInfo = [YYClassInfo classInfoWithClass:cls];</span><br><span class="line">    if (!classInfo) return nil;</span><br><span class="line">    self = [super init];</span><br><span class="line">    </span><br><span class="line">    // Get black list 判断当前类是否实现黑名单</span><br><span class="line">    NSSet *blacklist = nil;</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelPropertyBlacklist)]) &#123;</span><br><span class="line">        NSArray *properties = [(id&lt;YYModel&gt;)cls modelPropertyBlacklist]; //获取黑名单数组</span><br><span class="line">        if (properties) &#123; </span><br><span class="line">            blacklist = [NSSet setWithArray:properties]; //赋值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Get white list  判断当前类是否实现白名单</span><br><span class="line">    NSSet *whitelist = nil;</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelPropertyWhitelist)]) &#123;</span><br><span class="line">        NSArray *properties = [(id&lt;YYModel&gt;)cls modelPropertyWhitelist];</span><br><span class="line">        if (properties) &#123;</span><br><span class="line">            whitelist = [NSSet setWithArray:properties];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Get container property&apos;s generic class</span><br><span class="line">    //判断当前类是否实现属性与类对应方法</span><br><span class="line">    NSDictionary *genericMapper = nil;</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelContainerPropertyGenericClass)]) &#123;</span><br><span class="line">        genericMapper = [(id&lt;YYModel&gt;)cls modelContainerPropertyGenericClass];</span><br><span class="line">        if (genericMapper) &#123; //获取到实现的字典</span><br><span class="line">            NSMutableDictionary *tmp = [NSMutableDictionary new]; </span><br><span class="line">            // 遍历字典</span><br><span class="line">            [genericMapper enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">                if (![key isKindOfClass:[NSString class]]) return; //如果key不满足类型，返回</span><br><span class="line">                Class meta = object_getClass(obj); //返回obj的isa所指向的类</span><br><span class="line">                if (!meta) return;</span><br><span class="line">                if (class_isMetaClass(meta)) &#123; //如果是元类</span><br><span class="line">                    tmp[key] = obj;  //赋值</span><br><span class="line">                &#125; else if ([obj isKindOfClass:[NSString class]]) &#123; //如果obj是NSString</span><br><span class="line">                    Class cls = NSClassFromString(obj); //转为Cls</span><br><span class="line">                    if (cls) &#123;</span><br><span class="line">                        tmp[key] = cls; //赋值Cls</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">            genericMapper = tmp; //赋值genericMapper</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Create all property metas. 遍历所有属性含父类，但忽略 NSObject/NSProxy类</span><br><span class="line">    NSMutableDictionary *allPropertyMetas = [NSMutableDictionary new];</span><br><span class="line">    //allPropertyMetas 存储所以属性对应的propertyMeta</span><br><span class="line"></span><br><span class="line">    YYClassInfo *curClassInfo = classInfo;</span><br><span class="line">    //遍历至根类，将所有的属性进行赋值</span><br><span class="line">    while (curClassInfo &amp;&amp; curClassInfo.superCls != nil) &#123; // recursive parse super class, but ignore root class (NSObject/NSProxy)</span><br><span class="line">        for (YYClassPropertyInfo *propertyInfo in curClassInfo.propertyInfos.allValues) &#123;</span><br><span class="line">            if (!propertyInfo.name) continue;</span><br><span class="line">            if (blacklist &amp;&amp; [blacklist containsObject:propertyInfo.name]) continue;</span><br><span class="line">            if (whitelist &amp;&amp; ![whitelist containsObject:propertyInfo.name]) continue;</span><br><span class="line"></span><br><span class="line">            // 根据classInfo propertyInfo genericMapper初始化YYModelPropertyMeta</span><br><span class="line">            _YYModelPropertyMeta *meta = [_YYModelPropertyMeta metaWithClassInfo:classInfo</span><br><span class="line">                                                                    propertyInfo:propertyInfo</span><br><span class="line">                                                                         generic:genericMapper[propertyInfo.name]];</span><br><span class="line">            if (!meta || !meta-&gt;_name) continue;</span><br><span class="line">            if (!meta-&gt;_getter || !meta-&gt;_setter) continue;</span><br><span class="line">            if (allPropertyMetas[meta-&gt;_name]) continue;</span><br><span class="line">            allPropertyMetas[meta-&gt;_name] = meta;</span><br><span class="line">        &#125;</span><br><span class="line">        curClassInfo = curClassInfo.superClassInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    if (allPropertyMetas.count) _allPropertyMetas = allPropertyMetas.allValues.copy;</span><br><span class="line">    </span><br><span class="line">    // create mapper</span><br><span class="line">    NSMutableDictionary *mapper = [NSMutableDictionary new];</span><br><span class="line">    NSMutableArray *keyPathPropertyMetas = [NSMutableArray new];</span><br><span class="line">    NSMutableArray *multiKeysPropertyMetas = [NSMutableArray new];</span><br><span class="line">    </span><br><span class="line">    //实现对应的自定义属性方法</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelCustomPropertyMapper)]) &#123;</span><br><span class="line">        NSDictionary *customMapper = [(id &lt;YYModel&gt;)cls modelCustomPropertyMapper];//获取实现方法的字典</span><br><span class="line">        [customMapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyName, NSString *mappedToKey, BOOL *stop) &#123;</span><br><span class="line">            //获取属性列表中对应属性的meta</span><br><span class="line">            _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName];</span><br><span class="line">            if (!propertyMeta) return; //如果不存在return掉</span><br><span class="line">            [allPropertyMetas removeObjectForKey:propertyName];//如果存在自定义属性，先从属性列表中删除</span><br><span class="line">            </span><br><span class="line">            if ([mappedToKey isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">                  /** 根据上面示例源码</span><br><span class="line">                     mappedToKey:  id</span><br><span class="line">                    */</span><br><span class="line">                if (mappedToKey.length == 0) return;</span><br><span class="line">                </span><br><span class="line">                propertyMeta-&gt;_mappedToKey = mappedToKey; //赋值mappedToKey</span><br><span class="line">                NSArray *keyPath = [mappedToKey componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">                for (NSString *onePath in keyPath) &#123;</span><br><span class="line">                    if (onePath.length == 0) &#123;</span><br><span class="line">                        NSMutableArray *tmp = keyPath.mutableCopy;</span><br><span class="line">                        [tmp removeObject:@&quot;&quot;]; //将空值移除</span><br><span class="line">                        keyPath = tmp;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (keyPath.count &gt; 1) &#123; //对应多个.</span><br><span class="line">                    propertyMeta-&gt;_mappedToKeyPath = keyPath;</span><br><span class="line">                    [keyPathPropertyMetas addObject:propertyMeta];</span><br><span class="line">                &#125;</span><br><span class="line">                propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;</span><br><span class="line">                mapper[mappedToKey] = propertyMeta;</span><br><span class="line">                </span><br><span class="line">                /** mapper</span><br><span class="line">                mapper:</span><br><span class="line">                &#123;</span><br><span class="line">                     id = &quot;&lt;_YYModelPropertyMeta: 0x6040006eb800&gt;&quot;;</span><br><span class="line">                     (</span><br><span class="line">                        templateName</span><br><span class="line">                     ) = &quot;&lt;_YYModelPropertyMeta: 0x604000ae6980&gt;&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                */</span><br><span class="line">            &#125; else if ([mappedToKey isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">                /** 根据上面示例源码</span><br><span class="line">                mappedToKey:</span><br><span class="line">                &lt;__NSSingleObjectArrayI 0x600000204190&gt;(</span><br><span class="line">                    templateName</span><br><span class="line">                )</span><br><span class="line">                */</span><br><span class="line">                NSMutableArray *mappedToKeyArray = [NSMutableArray new];</span><br><span class="line">                for (NSString *oneKey in ((NSArray *)mappedToKey)) &#123;</span><br><span class="line">                    if (![oneKey isKindOfClass:[NSString class]]) continue;</span><br><span class="line">                    if (oneKey.length == 0) continue;</span><br><span class="line">                    </span><br><span class="line">                    NSArray *keyPath = [oneKey componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">                    if (keyPath.count &gt; 1) &#123;</span><br><span class="line">                        [mappedToKeyArray addObject:keyPath];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        [mappedToKeyArray addObject:oneKey];</span><br><span class="line">                        /** mappedToKeyArray:</span><br><span class="line">                        &lt;__NSArrayM 0x60400685ee70&gt;(</span><br><span class="line">                            templateName</span><br><span class="line">                        )</span><br><span class="line">                        */</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    if (!propertyMeta-&gt;_mappedToKey) &#123;</span><br><span class="line">                        propertyMeta-&gt;_mappedToKey = oneKey; //赋值mappedToKey</span><br><span class="line">                        propertyMeta-&gt;_mappedToKeyPath = keyPath.count &gt; 1 ? keyPath : nil;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!propertyMeta-&gt;_mappedToKey) return; //判断如果为空，return</span><br><span class="line">                </span><br><span class="line">                propertyMeta-&gt;_mappedToKeyArray = mappedToKeyArray; //赋值mappedToKeyArray</span><br><span class="line">                [multiKeysPropertyMetas addObject:propertyMeta];// 赋值multiKeysPropertyMetas</span><br><span class="line">                </span><br><span class="line">                propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;</span><br><span class="line">                mapper[mappedToKey] = propertyMeta; </span><br><span class="line">                /**</span><br><span class="line">                mapper:</span><br><span class="line">                &#123;</span><br><span class="line">                         (</span><br><span class="line">                         templateName</span><br><span class="line">                        ) = &quot;&lt;_YYModelPropertyMeta: 0x604000ae6980&gt;&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                */</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [allPropertyMetas enumerateKeysAndObjectsUsingBlock:^(NSString *name, _YYModelPropertyMeta *propertyMeta, BOOL *stop) &#123;</span><br><span class="line">        propertyMeta-&gt;_mappedToKey = name; //赋值_mappedToKey</span><br><span class="line">        propertyMeta-&gt;_next = mapper[name] ?: nil;</span><br><span class="line">        mapper[name] = propertyMeta; //赋值mapper 此时mapper内元素数量是和当前Model的属性数量一致的</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    if (mapper.count) _mapper = mapper; </span><br><span class="line">    if (keyPathPropertyMetas) _keyPathPropertyMetas = keyPathPropertyMetas;</span><br><span class="line">    if (multiKeysPropertyMetas) _multiKeysPropertyMetas = multiKeysPropertyMetas;</span><br><span class="line">    </span><br><span class="line">    _classInfo = classInfo;</span><br><span class="line">    _keyMappedCount = _allPropertyMetas.count;</span><br><span class="line">    _nsType = YYClassGetNSType(cls);</span><br><span class="line">    _hasCustomWillTransformFromDictionary = ([cls instancesRespondToSelector:@selector(modelCustomWillTransformFromDictionary:)]);</span><br><span class="line">    _hasCustomTransformFromDictionary = ([cls instancesRespondToSelector:@selector(modelCustomTransformFromDictionary:)]);</span><br><span class="line">    _hasCustomTransformToDictionary = ([cls instancesRespondToSelector:@selector(modelCustomTransformToDictionary:)]);</span><br><span class="line">    _hasCustomClassFromDictionary = ([cls respondsToSelector:@selector(modelCustomClassForDictionary:)]);</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>YYModelMeta</code>初始化方法总结</p>
<ul>
<li>初始化YYClassInfo, 内部初始化会实现superClassInfo的赋值 直到根类</li>
<li>解析内部实现的方法如黑名单，白名单</li>
<li>解析方法modelContainerPropertyGenericClass，此方法较常见<br> genericMapper字典存储该方法内对指定字段的替换，如通常情况下是<code>items</code>字段，数组类型，内部包含相同类型的model<br> 比如genericMapper:<br>  {<pre><code>items = YYItem;
</code></pre>  }</li>
<li>while循环，allPropertyMetas字典存储当前classInfo对象的属性，并循环到父类的所有属性（直到superCls != nil）<br>  比如allPropertyMetas:<br>  {<br>  items = “<_yymodelpropertymeta: 0x6000004e1700="">“;<br>  type = “<_yymodelpropertymeta: 0x6000008f7c00="">“;<br>  templateNames = “<_yymodelpropertymeta: 0x6000008a5c02="">“;<br>  templateId =  “<_yymodelpropertymeta: 0x6000008b2a00="">“;<br>  }</_yymodelpropertymeta:></_yymodelpropertymeta:></_yymodelpropertymeta:></_yymodelpropertymeta:></li>
<li>解析方法modelCustomPropertyMapper<br>  赋值每个propertyMeta的mappedToKey/mappedToKeyPath/next/_mappedToKeyArray<br>  赋值mapper  如<code>mapper[mappedToKey] = propertyMeta;</code></li>
<li>遍历allPropertyMetas字典 将对应propertyMeta 正确赋值 ，mapper数组添加每个遍历到的propertyMeta保证mapper数组内元素和当前Model的属性一致</li>
<li>剩余的属性赋值</li>
</ul>
<p>此时可以查看到 当前Model的mapper值<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mapper:</span><br><span class="line">&#123;</span><br><span class="line">    items = <span class="string">"&lt;_YYModelPropertyMeta: 0x6000004f3300&gt;"</span>;</span><br><span class="line">    <span class="keyword">id</span> = <span class="string">"&lt;_YYModelPropertyMeta: 0x6000006e9a00&gt;"</span>;</span><br><span class="line">    type = <span class="string">"&lt;_YYModelPropertyMeta: 0x6000008efc80&gt;"</span>;</span><br><span class="line">    (</span><br><span class="line">        templateName,</span><br><span class="line">        templateNames</span><br><span class="line">    ) = <span class="string">"&lt;_YYModelPropertyMeta: 0x6000008eeb00&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>补下照<br><img src="/images/YYModelPropertyMeta初始化.png" alt="YYModelPropertyMeta初始化"></p>
<p>以上是初始化方法，那么实际使用，就需要开始运用这些属性了</p>
<p>通常在解析拿到的json数据，调用方法<code>yy_modelWithDictionary</code></p>
<h3 id="yy-modelWithDictionary-json转Model"><a href="#yy-modelWithDictionary-json转Model" class="headerlink" title="yy_modelWithDictionary  json转Model"></a>yy_modelWithDictionary  json转Model</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)yy_modelWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionary &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dictionary || dictionary == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">nil</span>;  <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span> (![dictionary isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">//不是字典类型，直接返回</span></span><br><span class="line">    </span><br><span class="line">    Class cls = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:cls]; <span class="comment">//获取model对应的YYModelMeta，如果已经初始化，直接从缓存字典获取</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomClassFromDictionary) &#123;</span><br><span class="line">        cls = [cls modelCustomClassForDictionary:dictionary] ?: cls;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *one = [cls new];</span><br><span class="line">    <span class="keyword">if</span> ([one yy_modelSetWithDictionary:dictionary]) <span class="keyword">return</span> one;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部封装<code>yy_modelSetWithDictionary</code><br>方法调用栈如下<br><img src="/images/YYModel解析底层.png" alt="YYModel解析底层"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)yy_modelSetWithDictionary:(<span class="built_in">NSDictionary</span> *)dic &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dic || dic == (<span class="keyword">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(<span class="keyword">self</span>)];</span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_keyMappedCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>; <span class="comment">//如果没有属性，返回</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在这里能修改数据源字典</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomWillTransformFromDictionary) &#123;</span><br><span class="line">        dic = [((<span class="keyword">id</span>&lt;YYModel&gt;)<span class="keyword">self</span>) modelCustomWillTransformFromDictionary:dic];</span><br><span class="line">        <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ModelSetContext context = &#123;<span class="number">0</span>&#125;; <span class="comment">//上下文的几个属性都赋值给context</span></span><br><span class="line">    context.modelMeta = (__bridge <span class="keyword">void</span> *)(modelMeta);</span><br><span class="line">    context.model = (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>);</span><br><span class="line">    context.dictionary = (__bridge <span class="keyword">void</span> *)(dic);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_keyMappedCount &gt;= <span class="built_in">CFDictionaryGetCount</span>((<span class="built_in">CFDictionaryRef</span>)dic)) &#123;</span><br><span class="line">        <span class="built_in">CFDictionaryApplyFunction</span>((<span class="built_in">CFDictionaryRef</span>)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class="line">        <span class="keyword">if</span> (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class="line">            <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class="line">                                 <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="built_in">CFArrayGetCount</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class="line">            <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class="line">                                 <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="built_in">CFArrayGetCount</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_allPropertyMetas,</span><br><span class="line">                             <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, modelMeta-&gt;_keyMappedCount),</span><br><span class="line">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                             &amp;context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123;</span><br><span class="line">        <span class="keyword">return</span> [((<span class="keyword">id</span>&lt;YYModel&gt;)<span class="keyword">self</span>) modelCustomTransformFromDictionary:dic];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ModelSetWithPropertyMetaArrayFunction"><a href="#ModelSetWithPropertyMetaArrayFunction" class="headerlink" title="ModelSetWithPropertyMetaArrayFunction"></a>ModelSetWithPropertyMetaArrayFunction</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Apply function for model property meta, to set dictionary to model.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param _propertyMeta should not be nil, _YYModelPropertyMeta.</span></span><br><span class="line"><span class="comment"> @param _context      _context.model and _context.dictionary should not be nil.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ModelSetWithPropertyMetaArrayFunction(<span class="keyword">const</span> <span class="keyword">void</span> *_propertyMeta, <span class="keyword">void</span> *_context) &#123;</span><br><span class="line">    ModelSetContext *context = _context;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSDictionary</span> *dictionary = (__bridge <span class="built_in">NSDictionary</span> *)(context-&gt;dictionary);</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *propertyMeta = (__bridge _YYModelPropertyMeta *)(_propertyMeta);</span><br><span class="line">    <span class="keyword">if</span> (!propertyMeta-&gt;_<span class="keyword">setter</span>) <span class="keyword">return</span>; <span class="comment">//propertyMeta没有setter方法，返回</span></span><br><span class="line">    <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyArray) &#123;   <span class="comment">// 多个key对应同一属性赋值</span></span><br><span class="line">        value = YYValueForMultiKeys(dictionary, propertyMeta-&gt;_mappedToKeyArray);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyPath) &#123;  <span class="comment">// keyPath赋值</span></span><br><span class="line">        value = YYValueForKeyPath(dictionary, propertyMeta-&gt;_mappedToKeyPath);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = [dictionary objectForKey:propertyMeta-&gt;_mappedToKey];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model = (__bridge <span class="keyword">id</span>)(context-&gt;model);</span><br><span class="line">        ModelSetValueForProperty(model, value, propertyMeta); <span class="comment">//属性赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ModelSetWithDictionaryFunction"><a href="#ModelSetWithDictionaryFunction" class="headerlink" title="ModelSetWithDictionaryFunction"></a>ModelSetWithDictionaryFunction</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ModelSetWithDictionaryFunction(<span class="keyword">const</span> <span class="keyword">void</span> *_key, <span class="keyword">const</span> <span class="keyword">void</span> *_value, <span class="keyword">void</span> *_context) &#123;</span><br><span class="line">    ModelSetContext *context = _context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据上下文结构体 ModelSetContext 取出 _YYModelMeta / _YYModelPropertyMeta / model</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelMeta *meta = (__bridge _YYModelMeta *)(context-&gt;modelMeta);</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *propertyMeta = [meta-&gt;_mapper objectForKey:(__bridge <span class="keyword">id</span>)(_key)];</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> model = (__bridge <span class="keyword">id</span>)(context-&gt;model);</span><br><span class="line">    <span class="keyword">while</span> (propertyMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_<span class="keyword">setter</span>) &#123; <span class="comment">//调用对应的setter方法赋值model的value属性</span></span><br><span class="line">            ModelSetValueForProperty(model, (__bridge __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>)_value, propertyMeta);</span><br><span class="line">            <span class="comment">//底层调用msg_send方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        propertyMeta = propertyMeta-&gt;_next;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul>
<li>CFArrayApplyFunction<br>为数组内指定范围的每个元素调用一次指定的方法,上面指定的方法有<code>ModelSetWithPropertyMetaArrayFunction</code>/<code>ModelSetWithDictionaryFunction</code></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体上YYmodel数据解析</p>
<ul>
<li>根据cls进行初始化生成model对应的<code>YYModelMeta</code>，包含mapper,里面含有每个属性（YYModelPropertyMeta）</li>
<li>根据对应的json 与 YYModelMeta 进行相互转换赋值，会进行各种类型及判空处理</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/06/07/Dispatch系列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/07/Dispatch系列/" itemprop="url">Dispatch系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-07T09:46:16+08:00">
                2018-06-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本系列源码地址 <a href="https://opensource.apple.com/tarballs/libdispatch" target="_blank" rel="noopener">libdispatch</a><br>研读版本 <code>libdispatch-339.92.1</code></p>
<p>思维导图<br><img src="/images/dispatch重要函数.png" alt="dispatch重要函数"></p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/05/22/Objc-protocol原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/22/Objc-protocol原理/" itemprop="url">Objc-protocol实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-22T17:24:40+08:00">
                2018-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文直接运行的是runtime Objc4-706版本，debug-objc的target，mac运行</p>
<p>本篇研究以下问题</p>
<ul>
<li>Protocol的实现原理</li>
</ul>
<p>若要查看category实现原理，请自行查阅之前的<a href="https://pattyxp.github.io/2018/02/11/Objc-category%E7%AF%87/">博客</a></p>
<p>源码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt;pig.h</span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">pigProtocol</span></span></span><br><span class="line">- (<span class="keyword">void</span>)updateAge;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Pig</span> : <span class="title">NSObject</span>&lt;<span class="title">pigProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line">+ (<span class="keyword">id</span>)createPig;</span><br><span class="line">- (<span class="keyword">void</span>)updateAge;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">&gt;pig.m</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Pig</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)createPig</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> new];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)updateAge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.age = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"对象age:%@"</span>,<span class="keyword">self</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">&gt;main.m</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Pig *pigObject = [Pig createPig];</span><br><span class="line">        [pigObject updateAge];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先在整个应用中，在main函数打上断点，可以观察到最初函数调用栈如图<br><img src="/images/OC4-init.png" alt="OC4-init"></p>
<p>在<code>objc-runtime-new.mm</code>文件 L:2284 方法<code>_read_images</code>内有对<code>protocol</code>、<code>category</code>等的赋值操作<br><code>_read_images</code>方法是从当前镜像内加载相应的类及其属性</p>
<p>在方法内部<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">        Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">        assert(cls);</span><br><span class="line">        NXMapTable *protocol_map = protocols(); <span class="comment">//创建表</span></span><br><span class="line">        <span class="keyword">bool</span> isPreoptimized = hi-&gt;isPreoptimized();</span><br><span class="line">        <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line"></span><br><span class="line">        protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            readProtocol(protolist[i], cls, protocol_map, </span><br><span class="line">                         isPreoptimized, isBundle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>protocols()</code>内部实现是有个静态变量，判断是否存在表，不存在就创建<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NXMapTable *protocols(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> NXMapTable *protocol_map = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    INIT_ONCE_PTR(protocol_map, </span><br><span class="line">                  NXCreateMapTable(NXStrValueMapPrototype, <span class="number">16</span>), </span><br><span class="line">                  NXFreeMapTable(v) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> protocol_map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>_getObjc2ProtocolList</code>获取该路径下的协议列表，此处没有源码<br>下面还有个重要的方法<code>readProtocol</code><br>可以先看下里面的一些变量，这里很多协议都会走这里，如<code>NSCopying</code>、<code>NSCoding</code><br><img src="/images/OC4-protocol.png" alt="OC4-protocol"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readProtocol(protocol_t *newproto, Class protocol_class,</span><br><span class="line">             NXMapTable *protocol_map, </span><br><span class="line">             <span class="keyword">bool</span> headerIsPreoptimized, <span class="keyword">bool</span> headerIsBundle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This is not enough to make protocols in unloaded bundles safe, </span></span><br><span class="line">    <span class="comment">// but it does prevent crashes when looking up unrelated protocols.</span></span><br><span class="line">    auto insertFn = headerIsBundle ? NXMapKeyCopyingInsert : NXMapInsert;</span><br><span class="line"></span><br><span class="line">    protocol_t *oldproto = (protocol_t *)getProtocol(newproto-&gt;mangledName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldproto) &#123;  <span class="comment">//如果存在oldproto 结束</span></span><br><span class="line">        <span class="comment">// Some other definition already won.</span></span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s  "</span></span><br><span class="line">                         <span class="string">"(duplicate of %p)"</span>,</span><br><span class="line">                         newproto, oldproto-&gt;nameForLogging(), oldproto);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (headerIsPreoptimized) &#123;</span><br><span class="line">        <span class="comment">// Shared cache initialized the protocol object itself, </span></span><br><span class="line">        <span class="comment">// but in order to allow out-of-cache replacement we need </span></span><br><span class="line">        <span class="comment">// to add it to the protocol table now.</span></span><br><span class="line"></span><br><span class="line">        protocol_t *cacheproto = (protocol_t *)</span><br><span class="line">            getPreoptimizedProtocol(newproto-&gt;mangledName);</span><br><span class="line">        protocol_t *installedproto;</span><br><span class="line">        <span class="keyword">if</span> (cacheproto  &amp;&amp;  cacheproto != newproto) &#123;</span><br><span class="line">            <span class="comment">// Another definition in the shared cache wins (because </span></span><br><span class="line">            <span class="comment">// everything in the cache was fixed up to point to it).</span></span><br><span class="line">            installedproto = cacheproto;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This definition wins.</span></span><br><span class="line">            installedproto = newproto;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        assert(installedproto-&gt;getIsa() == protocol_class);</span><br><span class="line">        assert(installedproto-&gt;size &gt;= <span class="keyword">sizeof</span>(protocol_t));</span><br><span class="line">        insertFn(protocol_map, installedproto-&gt;mangledName, </span><br><span class="line">                 installedproto);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s"</span>, </span><br><span class="line">                         installedproto, installedproto-&gt;nameForLogging());</span><br><span class="line">            <span class="keyword">if</span> (newproto != installedproto) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s  "</span></span><br><span class="line">                             <span class="string">"(duplicate of %p)"</span>, </span><br><span class="line">                             newproto, installedproto-&gt;nameForLogging(), </span><br><span class="line">                             installedproto);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newproto-&gt;size &gt;= <span class="keyword">sizeof</span>(protocol_t)) &#123; <span class="comment">//如果新协议size大于96 sizeof(protocol_t)=96</span></span><br><span class="line">        <span class="comment">// New protocol from an un-preoptimized image</span></span><br><span class="line">        <span class="comment">// with sufficient storage. Fix it up in place.</span></span><br><span class="line">        <span class="comment">// fixme duplicate protocols from unloadable bundle</span></span><br><span class="line">        newproto-&gt;initIsa(protocol_class);  <span class="comment">// fixme pinned  //初始化isa</span></span><br><span class="line">        insertFn(protocol_map, newproto-&gt;mangledName, newproto);<span class="comment">// 插入协议到指定的protocol_map</span></span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s"</span>,</span><br><span class="line">                         newproto, newproto-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// New protocol from an un-preoptimized image </span></span><br><span class="line">        <span class="comment">// with insufficient storage. Reallocate it.</span></span><br><span class="line">        <span class="comment">// fixme duplicate protocols from unloadable bundle</span></span><br><span class="line">        size_t size = max(<span class="keyword">sizeof</span>(protocol_t), (size_t)newproto-&gt;size);</span><br><span class="line">        protocol_t *installedproto = (protocol_t *)calloc(size, <span class="number">1</span>);</span><br><span class="line">        memcpy(installedproto, newproto, newproto-&gt;size);</span><br><span class="line">        installedproto-&gt;size = (<span class="keyword">typeof</span>(installedproto-&gt;size))size;</span><br><span class="line">        </span><br><span class="line">        installedproto-&gt;initIsa(protocol_class);  <span class="comment">// fixme pinned</span></span><br><span class="line">        insertFn(protocol_map, installedproto-&gt;mangledName, installedproto);</span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s  "</span>, </span><br><span class="line">                         installedproto, installedproto-&gt;nameForLogging());</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: protocol at %p is %s  "</span></span><br><span class="line">                         <span class="string">"(reallocated to %p)"</span>, </span><br><span class="line">                         newproto, installedproto-&gt;nameForLogging(), </span><br><span class="line">                         installedproto);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要监听自己需要的协议如<code>pigProtocol</code>，可以打断点<br><img src="/images/OC4-pigProtol断点.png" alt="OC4-pigProtol断点"><br><img src="/images/OC4-pigProtocol.png" alt="OC4-pigProtocol"></p>
<p>当协议存储在协议表之后，调用协议，其实就是方法查找的问题，可以看下之前的文章<em>消息的发送与查找</em><br><img src="/images/OC4-pigProtocol查找调用.png" alt="OC4-pigProtocol查找调用"></p>
<p>此处关于<code>NXMapTable</code>将在下章进行分析</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul>
<li><p>calloc<br>  <code>calloc()</code> 函数用来动态地分配内存空间并初始化为 0，其原型为：<br>  <code>void* calloc (size_t num, size_t size);</code></p>
<p>  <code>calloc()</code> 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</p>
<p>  【返回值】分配成功返回指向该内存的地址，失败则返回 NULL。</p>
<p>  <code>calloc()</code> 与 <code>malloc()</code>的一个重要区别是：<code>calloc()</code> 在动态分配完内存后，自动初始化该内存空间为零，而 <code>malloc()</code> 不初始化，里边数据是未知的垃圾数据</p>
</li>
<li><p>memcpy<br>  函数原型<code>void *memcpy(void*dest, const void *src, size_t n);</code><br>  由src指向地址为起始地址的连续n个字节的数据复制到以destin指向地址为起始地址的空间内。<br>  【返回值】函数返回一个指向dest的指针</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/05/18/Objc-load调查/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/Objc-load调查/" itemprop="url">Objc-load调查</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T17:28:19+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇研究以下问题</p>
<ul>
<li>load方法调用时机和顺序问题</li>
<li>多个分类中有load方法是怎么处理的</li>
<li>为什么load方法不存在方法缓存覆盖问题</li>
</ul>
<p>先来看下load方法的加载时机<br>源码主要包含以下类:</p>
<ul>
<li>Pig类</li>
<li>PigCate1</li>
<li><p>PigCate2<br>每个类都包含<code>load</code>方法,打印当前<code>_cmd</code><br>在每个<code>load</code>处添加断点，函数调用栈如下<br>!(OC4-load)(/images/OC4-load.png)</p>
</li>
<li><p>load方法并不需要调用就会执行<br>从方法的调用栈可以知道，此时方法的调用顺序<br><code>load_images</code> 是镜像加载</p>
<blockquote>
<p>此处的镜像，一部分是系统准备的一些框架如CoreFoundation，还有很多的动态链接库</p>
</blockquote>
</li>
</ul>
<h3 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="comment">//判断是否存在load方法</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);<span class="comment">//准备加载load方法的工作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant) //调用load方法</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="prepare-load-methods"><a href="#prepare-load-methods" class="headerlink" title="prepare_load_methods"></a>prepare_load_methods</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> prepare_load_methods(<span class="keyword">const</span> headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);<span class="comment">//获取所有的类的列表</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">        <span class="comment">//remapClass 获取类对应的指针</span></span><br><span class="line">        <span class="comment">//schedule_class_load 递归调用当前(没有调用过load方法的类及其父类)加入列表中，优先加入父类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="comment">//将分类加入到列表中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="schedule-class-load"><a href="#schedule-class-load" class="headerlink" title="schedule_class_load"></a>schedule_class_load</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//保证当前类还没有调用load方法</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    <span class="comment">//优先调用当前类的父类加入到列表中</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将当前cls加入到loadable_classes列表中</span></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确保父类的load方法优先于子类调用</p>
<h3 id="add-class-to-loadable-list"><a href="#add-class-to-loadable-list" class="headerlink" title="add_class_to_loadable_list"></a>add_class_to_loadable_list</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> add_class_to_loadable_list(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked(); <span class="comment">//递归锁</span></span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod(); <span class="comment">//获取cls的load方法</span></span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果当前数组已经存满，需要重新分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (<span class="keyword">struct</span> loadable_class *)</span><br><span class="line">            realloc(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用工作"><a href="#调用工作" class="headerlink" title="调用工作"></a>调用工作</h2><p>下次将重点分析下<code>call_load_methods()</code></p>
<h3 id="call-load-methods"><a href="#call-load-methods" class="headerlink" title="call_load_methods"></a>call_load_methods</h3><p>当在<code>load_images</code>方法内只调用一次<code>call_load_methods</code>,保证将所有含有load方法的类或分类全部调用load方法，按顺序先执行类方法，然后执行分类方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>; <span class="comment">//保证在load_images方法期间只执行一次该方法</span></span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush(); <span class="comment">//创建autoreleasePool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">//loadable_classes_used是全局静态变量，存储需要调用load方法的类数量</span></span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads(); <span class="comment">//分类加载load方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories); </span><br><span class="line"> </span><br><span class="line">    objc_autoreleasePoolPop(pool);      <span class="comment">//释放autoreleasePool</span></span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="call-class-loads"><a href="#call-class-loads" class="headerlink" title="call_class_loads"></a>call_class_loads</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> call_class_loads(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> loadable_class *classes = loadable_classes;</span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;  <span class="comment">//取出loadable_classes_used</span></span><br><span class="line">    loadable_classes = <span class="literal">nil</span>;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过遍历<code>for循环</code>取出所有已加载的类，取出对应的load方法地址<br>通过load方法的地址直接调用的load方法，而不是通过消息机制来调用的，所以不存在<em>方法覆盖</em>问题</p>
<h3 id="call-category-loads"><a href="#call-category-loads" class="headerlink" title="call_category_loads"></a>call_category_loads</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> call_category_loads(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, shift;</span><br><span class="line">    <span class="keyword">bool</span> new_categories_added = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> loadable_category *cats = loadable_categories;</span><br><span class="line">    <span class="keyword">int</span> used = loadable_categories_used;</span><br><span class="line">    <span class="keyword">int</span> allocated = loadable_categories_allocated;</span><br><span class="line">    loadable_categories = <span class="literal">nil</span>;</span><br><span class="line">    loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_categories_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        load_method_t load_method = (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123; </span><br><span class="line">            <span class="comment">//一般情况下都是类方法先于分类方法调用，但是万一存在分类先调用，此处保证如果类存在且可以加载，先调用类的方法如下</span></span><br><span class="line">            <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"LOAD: +[%s(%s) load]\n"</span>, </span><br><span class="line">                             cls-&gt;nameForLogging(), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            &#125;</span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compact detached list (order-preserving)</span></span><br><span class="line">    <span class="comment">//将已经执行完load方法的分类数量进行扣除</span></span><br><span class="line">    shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift++; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -= shift; <span class="comment">//减去相应加载完的分类数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy any new +load candidates from the new list to the detached list.</span></span><br><span class="line">    <span class="comment">//如果有新加载的类，则加入list中</span></span><br><span class="line">    new_categories_added = (loadable_categories_used &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">            cats = (<span class="keyword">struct</span> loadable_category *)</span><br><span class="line">                realloc(cats, allocated *</span><br><span class="line">                                  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the new list.</span></span><br><span class="line">    <span class="comment">//将新加载的类进行释放</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories) free(loadable_categories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reattach the (now augmented) detached list. </span></span><br><span class="line">    <span class="comment">// But if there's nothing left to load, destroy the list.</span></span><br><span class="line">    <span class="comment">//如果还有未加载完成的类，则赋值</span></span><br><span class="line">    <span class="comment">//如果都加载完，则清空列表</span></span><br><span class="line">    <span class="keyword">if</span> (used) &#123;</span><br><span class="line">        loadable_categories = cats;</span><br><span class="line">        loadable_categories_used = used;</span><br><span class="line">        loadable_categories_allocated = allocated;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats) free(cats);</span><br><span class="line">        loadable_categories = <span class="literal">nil</span>;</span><br><span class="line">        loadable_categories_used = <span class="number">0</span>;</span><br><span class="line">        loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loadable_categories_used != <span class="number">0</span>) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: %d categories still waiting for +load\n"</span>,</span><br><span class="line">                         loadable_categories_used);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_categories_added;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法调用栈如下<br>!(OC4_load_cate)(/images/OC4_load_cate.png)<br>流程上和加载类的<code>load</code>方法差不多，就不多说了</p>
<p>至此<code>call_load_methods</code>方法分析的差不多了</p>
<p>因此，<code>load</code>方法的调用时机可以总结如下</p>
<blockquote>
<p>在main方法调用之前，程序调用期间调用一次<br>父类优先子类调用<br>类优先分类</p>
</blockquote>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul>
<li>问题1<br>在调用分类的load方法源码中，存在部分理解问题<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有加载过的分类移除 `loadable_categories` 列表</span></span><br><span class="line">shift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cats[i].cat) &#123;</span><br><span class="line">        cats[i-shift] = cats[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shift++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">used -= shift;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在调用过程中，未进入过if条件，所以不知道是什么情况下进行移除操作的<br>假设cats列表存在4个分类<br>cats[0]、cats[1]、cats[2]、cats[3]<br>其中cats[0]、cats[2]的load方法已经加载过，所以相应的cat已经为nil<br>进行上面code执行结果</p>
<table>
<thead>
<tr>
<th>类</th>
<th style="text-align:left">条件</th>
<th style="text-align:center">结果赋值</th>
</tr>
</thead>
<tbody>
<tr>
<td>cats[0]</td>
<td style="text-align:left">加载过</td>
<td style="text-align:center">shifts=1</td>
</tr>
<tr>
<td>cats[1]</td>
<td style="text-align:left">未加载过</td>
<td style="text-align:center">cats[0]=cats[1]</td>
</tr>
<tr>
<td>cats[2]</td>
<td style="text-align:left">加载过</td>
<td style="text-align:center">shifts=2</td>
</tr>
<tr>
<td>cats[3]</td>
<td style="text-align:left">未加载过</td>
<td style="text-align:center">cats[0]=cats[2]</td>
</tr>
</tbody>
</table>
<p>经过调查，其实这里可以当做是一张表在操作<br>当未加载过的类，进行赋值操作如 <code>cats[0]=cats[1]</code> ，其实就是把cats[0]进行赋值，<br><code>cats[0]=cats[2]</code> 再次进行赋值，cat[2]的内容赋值给cats[0],之前的cats[1]就被移除了</p>
<ul>
<li>问题2<br>此处<code>loadable_categories_used</code>在最开始的时候已经取出赋值给<code>used</code>,然后重新赋为0<br>所以不明白为什么还会存在<code>loadable_categories_used &gt; 0</code>的情况<br>而且还重新开辟空间和赋值<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new_categories_added = (loadable_categories_used &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">            cats = (<span class="keyword">struct</span> loadable_category *)</span><br><span class="line">                realloc(cats, allocated *</span><br><span class="line">                                  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在同一个镜像里面，<code>load_images</code>里面加入了递归锁<code>recursive_mutex_locker_t lock(loadMethodLock);</code><br>按理，前面<code>loadable_categories_used</code>已经清空了，但是存在一种可能，在<code>+laod</code>方法里面给类添加了分类及其<code>load</code><br>那么<code>loadable_categories_used</code>可能存在大于0的情况</p>
<h2 id="extennsion"><a href="#extennsion" class="headerlink" title="extennsion"></a>extennsion</h2><p>extension在源码中是找不到的，因为它存在于编译期，是类的一部分<br><em>extension一般用来隐藏类的私有信息</em><br><em>伴随源码产生</em>所以很多系统的类如<code>NSString</code>无法添加extension</p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/05/09/Block的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/09/Block的实现/" itemprop="url">Block的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T10:16:02+08:00">
                2018-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在OC当中我们经常使用block，block的结构体如下<a href="http://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="noopener">摘自clang</a>:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_literal_1 &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa; <span class="comment">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor_1 &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;         <span class="comment">// NULL</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;         <span class="comment">// sizeof(struct Block_literal_1)</span></span><br><span class="line">        <span class="comment">// optional helper functions</span></span><br><span class="line">        <span class="keyword">void</span> (*copy_helper)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);     <span class="comment">// IFF (1&lt;&lt;25)</span></span><br><span class="line">        <span class="keyword">void</span> (*dispose_helper)(<span class="keyword">void</span> *src);             <span class="comment">// IFF (1&lt;&lt;25)</span></span><br><span class="line">        <span class="comment">// required ABI.2010.3.16</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *signature;                         <span class="comment">// IFF (1&lt;&lt;30)</span></span><br><span class="line">    &#125; *descriptor;</span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对此可以看到 block主要由以下部分构成</p>
<ol>
<li>isa指针</li>
<li>flags 用于表示一些附加信息，如block copy之后需要判断使用</li>
<li>reserved 保留字段</li>
<li>invoke 函数指针，具体实现地址</li>
<li>Block_descriptor_1 结构体表示block的一些附加信息，如大小，copy，dispose函数指针以及方法签名等</li>
<li>imported variables 可能引入的外部变量(或变量的地址)</li>
</ol>
<p>block主要有以下三种类型<br>1._NSConcreteGlobalBlock 全局的静态 block，不会访问任何外部变量。<br>2._NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。<br>3._NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。</p>
<p>下面看下实现</p>
<h2 id="不引用外部变量"><a href="#不引用外部变量" class="headerlink" title="不引用外部变量"></a>不引用外部变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    block1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将以上c文件通过clang进行重写，得到如下精简代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*block1)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结下:</p>
<ul>
<li>isa 类型是<code>_NSConcreteStackBlock</code>,实际在打印的时候会发现类型是_NSConcreteGlobalBlock<br><img src="/images/block_globalBlock.png" alt="block_globalBlock"><br>这是因为 block 的存储区域，与定义在什么位置、是否引用外部变量、是否作为范围值、是被哪种类型的变量所接收等等相关</li>
<li><code>__main_block_impl_0</code> 是实际的函数指针，指向<code>__main_block_func_0</code></li>
<li><code>__main_block_func_0</code> 是函数具体实现地址</li>
</ul>
<h2 id="使用外部变量"><a href="#使用外部变量" class="headerlink" title="使用外部变量"></a>使用外部变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    &#125;;</span><br><span class="line">    block1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过clang重写之后<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main1_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main1_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  __main1_block_impl_0(<span class="keyword">void</span> *fp, struct __main1_block_desc_0 *desc, <span class="keyword">int</span> _a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main1_block_func_0(struct __main1_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> a = __cself-&gt;a; <span class="comment">// bound by copy  值拷贝</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main1_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main1_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main1_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (*block1)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main1_block_impl_0((<span class="keyword">void</span> *)__main1_block_func_0, &amp;__main1_block_desc_0_DATA, a));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以观察到:</p>
<ul>
<li>isa 指向<code>_NSConcreteStackBlock</code>，分配在栈上，实际打印发现是<code>_NSConcreteMallocBlock</code><br><img src="/images/block_mallocBlock.png" alt="block_mallocBlock"></li>
<li><code>__main1_block_impl_0</code> 中增加了一个变量 a，在 block 中引用的变量 a 实际是在申明 block 时，被复制到 <code>main_block_impl_0</code> 结构体中的那个变量a的瞬时值被copy到栈上，作为常量供Block使用。这样我们就能理解，在 block 内部修改变量 a 的内容，不会影响外部的实际变量 a</li>
<li><code>main_block_impl_0</code> 中由于增加了一个变量 a，所以结构体的大小变大了，该结构体大小被写在了 <code>main_block_desc_0</code> 中</li>
</ul>
<h2 id="修改上面的源码，在变量前面增加-block-关键字："><a href="#修改上面的源码，在变量前面增加-block-关键字：" class="headerlink" title="修改上面的源码，在变量前面增加__block 关键字："></a>修改上面的源码，在变量前面增加<code>__block</code> 关键字：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __block <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">        a = <span class="number">99</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    block1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"block之后的变量:%d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将以上c文件通过clang进行重写，得到如下精简代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_a_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_a_0 *a; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_a_0 *a = __cself-&gt;a; <span class="comment">// bound by ref  指针拷贝</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (a-&gt;__forwarding-&gt;a));</span><br><span class="line">  (a-&gt;__forwarding-&gt;a) = <span class="number">99</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;a, (<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_a_0 *)&amp;a, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_a_0), <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="keyword">void</span> (*block1)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, <span class="number">570425344</span>));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"block之后的变量:%d\n"</span>, (a.__forwarding-&gt;a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结下:</p>
<ul>
<li>增加新的结构体<code>__Block_byref_a_0</code>，存储了外部引用的变量a</li>
<li><code>__main_block_impl_0</code>引用的是<code>__Block_byref_a_0</code>结构体，用来改变外部变量a</li>
<li><code>__Block_byref_i_0</code>结构体带有isa,说明是一个对象</li>
<li><p>我们需要负责 Block_byref_i_0 结构体相关的内存管理，所以 main_block_desc_0 中增加了 copy 和 dispose 函数指针，对于在调用前后修改相应变量的引用计数。</p>
</li>
<li><p>为什么<strong>Block_byref_a_0结构体内使用指向其自身的指针</strong>forwarding<br>源码解析:<br><code>__main_block_func_0</code>使用的都是<code>(a-&gt;__forwarding-&gt;a)</code>，<br><strong>forwarding指针这里的作用就是针对堆的Block,原先栈上的`</strong>forwarding`指向自身结构体，当拷贝到堆上之后，换成指向_NSConcreteMallocBlock上复制之后的<strong>block,然后堆上的变量的</strong>forwarding再指向自己。这样不管<strong>block在堆上还是在栈上，都可以通过(a-&gt;</strong>forwarding-&gt;a)来访问到变量值。</p>
<p><img src="/images/block_forwarding.png" alt="block_forwarding"></p>
</li>
<li><p>NSConcreteStackBlock的例子<br>ARC下见到最多的是_NSConcreteMallocBlock，是因为我们会对Block有赋值操作<br>但是也存在<code>_NSConcreteStackBlock</code></p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> __block <span class="keyword">int</span> temp = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"*******%d %p"</span>,temp ++,&amp;temp);&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="/images/block_stackBlock.png" alt="block_stackBlock"></p>
<h2 id="block-copy"><a href="#block-copy" class="headerlink" title="block_copy"></a>block_copy</h2><p>当block经过copy之后，系统会将block拷贝到堆上，此时block属于NSConcreteMallocBlock类型<br><a href="https://opensource.apple.com/source/clang/clang-137/src/projects/compiler-rt/BlocksRuntime/runtime.c" target="_blank" rel="noopener">具体源码在runtime.c</a></p>
<h2 id="block-的自动拷贝和手动拷贝"><a href="#block-的自动拷贝和手动拷贝" class="headerlink" title="block 的自动拷贝和手动拷贝"></a>block 的自动拷贝和手动拷贝</h2><p>那么 block 何时会 copy 到堆上呢？是显式，还是隐式？</p>
<ul>
<li>显式</li>
</ul>
<ol>
<li>在作为属性定义时，用 copy 和 strong 修饰；</li>
<li>手动调用 [block copy]；</li>
</ol>
<p>在开启ARC时，编译器通常会将创建在栈上的 block <strong>自动拷贝</strong>到堆上,除以下情况</p>
<blockquote>
<p>block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法；<br>方法/函数在内部已经实现了一份拷贝了 block 参数的代码，或者如果编译器自动拷贝，那么调用者就不需再手动拷贝，比如：</p>
</blockquote>
<ul>
<li>当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>
<li>当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>
<li>当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝;</li>
</ul>
<p>下面是自动拷贝的例子<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^blk_t)(<span class="keyword">int</span>);</span><br><span class="line">blk_t func(<span class="keyword">int</span> rate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ^(<span class="keyword">int</span> count)&#123;<span class="keyword">return</span> rate * count;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处的blk_t获取了局部变量,因此block创建在栈上<br>当func函数返回时，rate脱离作用范围，如果调用者使用时会出现问题。<br>那 ARC 开启的情况呢？运行这个 block 一切正常。和我们的预期结果不一样，ARC 到底给 block 施了什么魔法？</p>
<p>我们将上面的代码进行反编译<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _func(<span class="keyword">int</span> arg0) &#123;</span><br><span class="line">    rax = objc_retainBlock(__NSConcreteStackBlock);</span><br><span class="line">    rax = [rax autorelease];</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ___func_block_invoke(<span class="keyword">int</span> arg0, <span class="keyword">int</span> arg1) &#123;</span><br><span class="line">    rax = *(int32_t *)(arg0 + <span class="number">0x20</span>) * arg1;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中调用方法<code>objc_retainBlock</code><br>查看runtime源码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_retainBlock(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)_Block_copy(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处调用了<code>_Block_copy</code>，此处实现将block从栈上拷贝到堆上，保证了返回后的 block 仍然可以正确执行。<br>查看block源码发现内部还调用<code>_Block_object_assign</code>将对象赋值给block的结构体成员变量并持有该对象</p>
<h2 id="变量的copy"><a href="#变量的copy" class="headerlink" title="变量的copy"></a>变量的copy</h2><ul>
<li><p>block引用外部变量，默认是将变量进行copy，因此在block内部对变量的修改不会影响外部的使用<br><img src="/images/block的实现_外部变量.png" alt="block的实现_外部变量"></p>
</li>
<li><p><code>__block</code>引用外部变量，默认是将变量的地址进行copy<br><img src="/images/block的实现_外部变量2.png" alt="block的实现_外部变量2"></p>
</li>
</ul>
<h2 id="不看源码看结果（block截获局部变量）"><a href="#不看源码看结果（block截获局部变量）" class="headerlink" title="不看源码看结果（block截获局部变量）"></a>不看源码看结果（block截获局部变量）</h2><ul>
<li><p>普通版</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)block0</span><br><span class="line">&#123;</span><br><span class="line">    blk_t blk;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        blk = ^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">            [array addObject:obj];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"array count: = %zd"</span>,[array count]);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    blk([[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    blk([[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     array count: = 1</span></span><br><span class="line"><span class="comment">     array count: = 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__weak</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)block1</span><br><span class="line">&#123;</span><br><span class="line">    blk_t blk;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="keyword">id</span> __<span class="keyword">weak</span> array2 = array;</span><br><span class="line">        blk = [^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">            [array2 addObject:obj];</span><br><span class="line">            <span class="comment">//如果打开这句话，两个数组都有值，array被blk持有，array2不为nil</span></span><br><span class="line"><span class="comment">//            NSLog(@"array count: = %zd",[array count]);</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"array2 count: = %zd"</span>,[array2 count]);</span><br><span class="line">        &#125;<span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    blk([[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    blk([[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     array2 count: = 0</span></span><br><span class="line"><span class="comment">     array2 count: = 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//array 在该变量作用域结束的同时被释放、废弃，nil被赋值在附有__weak修饰符的变量array2 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在上面方法的基础上添加 <code>__block</code>修饰array2 结果同理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)block2</span><br><span class="line">&#123;</span><br><span class="line">    blk_t blk;</span><br><span class="line">    &#123;</span><br><span class="line">        id array = [[NSMutableArray alloc] init];</span><br><span class="line">        __block id __weak array2 = array;</span><br><span class="line">        blk = [^(id obj)&#123;</span><br><span class="line">            [array2 addObject:obj];</span><br><span class="line">            NSLog(@&quot;array2 count: = %zd&quot;,[array2 count]);</span><br><span class="line">        &#125;copy];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    blk([[NSObject alloc] init]);</span><br><span class="line">    blk([[NSObject alloc] init]);</span><br><span class="line">    /*</span><br><span class="line">     array2 count: = 0</span><br><span class="line">     array2 count: = 0</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__unsafe_unretained</code>修饰局部变量</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)block3</span><br><span class="line">&#123;</span><br><span class="line">    blk_t blk;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> array2 = array;</span><br><span class="line">        blk = [^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">            [array2 addObject:obj];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"array2 count: = %zd"</span>,[array2 count]);</span><br><span class="line">        &#125;<span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    blk([[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    blk(@<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     第一次调用blk()的时候，array2是数组，添加obj成功</span></span><br><span class="line"><span class="comment">     当第2次调用blk()的时候，array2是个野指针,不能添加数据，崩溃</span></span><br><span class="line"><span class="comment">     __unsafe_unretained修饰符的变量 与指针相同，和__strong或__weak修饰符不一样的处理，使用的时候需要注意不要通过野指针访问已被废弃的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用计数的变化</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">id</span> block_obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"****block_obj = [%@ , %p] "</span>,block_obj , &amp;block_obj);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"****obj = [%@ , %p]"</span> , obj , &amp;obj);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retain count:%zd\n"</span>,_objc_rootRetainCount(block_obj)); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retain count:%zd\n"</span>,_objc_rootRetainCount(obj)); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"***Block中****block_obj = [%@ , %p] "</span>,block_obj , &amp;block_obj);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"***Block中****obj = [%@ , %p]"</span> , obj , &amp;obj);</span><br><span class="line">&#125;;</span><br><span class="line">myBlock();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retain count:%zd\n"</span>,_objc_rootRetainCount(block_obj)); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retain count:%zd\n"</span>,_objc_rootRetainCount(obj)); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到两个对象的指针在block前后变化了，可以证实对象都被拷贝到了堆上<br><code>myBlock()</code>执行前后两个对象的<code>retainCount</code>的变化 :<br>obj经过从栈上拷贝到堆上之后 引用计数为1 -&gt;  3<br><code>__block</code>修饰的变量block_obj，引用计数没有发生变化 1 -&gt; 1</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>1.上面的普通版例子,block没有进行copy,理论上是处于栈上的，但array是有值的，说明block确实进行了copy赋值到堆上，为什么呢<br>解答:<br>在将block0通过Hopper Disassembler 工具将代码进行反编译，得到如下code<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> -[BlockViewController block0](<span class="keyword">void</span> * self, <span class="keyword">void</span> * _cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var_98 = objc_retainBlock(__NSConcreteStackBlock);</span><br><span class="line">    var_A0 = var_18;</span><br><span class="line">    __tsan_write8(var_18);</span><br><span class="line">    var_18 = var_98;</span><br><span class="line">    [var_90 release];</span><br><span class="line">    objc_storeStrong(var_88, <span class="number">0x0</span>);</span><br><span class="line">    objc_storeStrong(var_20, <span class="number">0x0</span>);</span><br><span class="line">    __tsan_read8(var_A0);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>var_98 = objc_retainBlock(__NSConcreteStackBlock);</code>，内部执行<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a heap based copy of a Block or simply add a reference to an existing one.</span></span><br><span class="line"><span class="comment">// This must be paired with Block_release to recover memory, even when running</span></span><br><span class="line"><span class="comment">// under Objective-C Garbage Collection.</span></span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *aBlock)</span><br></pre></td></tr></table></figure></p>
<p>将block从栈拷贝到了堆上，因此栈上的变量也被一起拷贝到了堆上,block进行clang重写之后得到block实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  id <span class="built_in">array</span>;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, id _array, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="built_in">array</span>(_array) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself, id obj) &#123;</span><br><span class="line">  id <span class="built_in">array</span> = __cself-&gt;<span class="built_in">array</span>; <span class="comment">// bound by copy</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="built_in">array</span>, (<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">blk_t</span> blk;</span><br><span class="line">        &#123;</span><br><span class="line">            id <span class="built_in">array</span> = ((NSMutableArray *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((NSMutableArray *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSMutableArray"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">            blk = ((<span class="keyword">void</span> (*)(id))&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, <span class="built_in">array</span>, <span class="number">570425344</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main方法里<code>__main_block_impl_0</code>传入的参数<code>array</code>是方法定义的<code>array(_array)</code>，传入array的指针而不是内存地址，所以没办法改变array本身<br>block 调用了 copy 方法，在 <code>_Block_object_assign</code> 中，将 array 赋值给 block 成员变量并持有。所以上面代码可以正常运行，打印出来的 array count 依次递增。</p>
<p>猜想一下array的retain值<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> blk_t blk;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"array retain count:%zd\n"</span>,_objc_rootRetainCount(array));<span class="comment">//1</span></span><br><span class="line">    blk = ^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">        [array addObject:obj];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"array retain count:%zd\n"</span>,_objc_rootRetainCount(array)); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.下面例子的blk结构体 存储了Person类的实例对象person, bound by copy ，但是一般来说bound by copy是代表的值引用，为什么在block内部对person的eat字段的改变可以改变到block外部的结果，感觉像是bound by ref<br>此处不知道怎么验证block内部的Person实例对象是和block外是一样的<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">person.eat = <span class="string">@"山珍海味"</span>;</span><br><span class="line">blk_t blk = [</span><br><span class="line">               ^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">                   person.eat = <span class="string">@"牛肉"</span>;</span><br><span class="line">               &#125;<span class="keyword">copy</span>];</span><br><span class="line">  </span><br><span class="line">blk(@<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person.eat);</span><br></pre></td></tr></table></figure></p>
<p>首先blk在执行<code>copy</code>将person对象从栈拷贝到了堆上，引起了对象的引用计数的变化</p>
<p>下面看下clang之后的c++源码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  Person *person; <span class="comment">//引用的外部变量</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, Person *_person, <span class="keyword">int</span> flags=<span class="number">0</span>) : person(_person) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself, id obj) &#123;</span><br><span class="line">  Person *person = __cself-&gt;person; <span class="comment">// bound by copy</span></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;person, (<span class="keyword">void</span>*)src-&gt;person, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;person, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        Person *person = ((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"Person"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(id, SEL, NSString *))(<span class="keyword">void</span> *)objc_msgSend)((id)person, sel_registerName(<span class="string">"setEat:"</span>), (NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main_0a2365_mi_0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">blk_t</span> blk = (<span class="keyword">blk_t</span>)((id (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((<span class="keyword">void</span> (*)(id))&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, person, <span class="number">570425344</span>)), sel_registerName(<span class="string">"copy"</span>));</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSNumber *(*)(Class, SEL, <span class="keyword">int</span>))(<span class="keyword">void</span> *)objc_msgSend)(objc_getClass(<span class="string">"NSNumber"</span>), sel_registerName(<span class="string">"numberWithInt:"</span>), <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p__6yw5xxfs5t1b0fdlr5183_5c0000gn_T_main_0a2365_mi_2,((NSString *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)person, sel_registerName(<span class="string">"eat"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在main里面的blk闭包中的__main_block_impl_0结构体，初始化如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">blk_t</span> blk = (<span class="keyword">blk_t</span>)((id (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((<span class="keyword">void</span> (*)(id))&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, person, <span class="number">570425344</span>)), sel_registerName(<span class="string">"copy"</span>));</span><br><span class="line"></span><br><span class="line">impl.isa = &amp;_NSConcreteMallocBlock;</span><br><span class="line">impl.Flags = <span class="number">570425344</span>;</span><br><span class="line">impl.FuncPtr = __main_block_impl_0; </span><br><span class="line">Desc = &amp;__main_block_desc_0_DATA;</span><br><span class="line">*person = person;</span><br></pre></td></tr></table></figure></p>
<p>__main_block_impl_0结构体就是这样把自动变量捕获进来的</p>
<p><code>__main_block_copy_0</code> 和 <code>__main_block_dispose_0</code>函数实现将捕获的外部变量进行retain和dispose<br>BLOCK_FIELD_IS_OBJECT 标识符代表此处捕获的是OC对象<br>如果是BLOCK_FIELD_IS_BYREF  代表捕获的是__block自动变量</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在ARC环境下，block捕获了外部变量，都会对变量进行copy,<br><code>__block</code>修饰的变量,会被捕获到Block内部持有</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="noopener">https://blog.devtang.com/2013/07/28/a-look-inside-blocks/</a><br><a href="http://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="noopener">http://clang.llvm.org/docs/Block-ABI-Apple.html</a><br><a href="http://www.saitjr.com/ios/advance-block.html" target="_blank" rel="noopener">http://www.saitjr.com/ios/advance-block.html</a><br>《Pro Multithreading and Memory Management for iOS and OS X with ARC》</p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/04/02/ReactiveObjc-RACChannel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/ReactiveObjc-RACChannel/" itemprop="url">ReactiveObjc-RACChannel</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-02T14:10:56+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="RACChannel"><a href="#RACChannel" class="headerlink" title="RACChannel"></a>RACChannel</h2><p>在 RAC 的世界中，消息不仅仅会单向流动，也存在双向流动，对应到 OC，如viewModel的属性和View的属性相互影响,这就体现出 RACChannel的作用,从概念上讲，RACChannel可以看作是双向连接，由两个可控制的信号并行工作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACChannel</span>&lt;<span class="title">ValueType</span>&gt; : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACChannelTerminal&lt;ValueType&gt; *leadingTerminal;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACChannelTerminal&lt;ValueType&gt; *followingTerminal;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p> RACChannel 和 RACChannelTerminal 息息相关</p>
<h3 id="RACChannelTerminal"><a href="#RACChannelTerminal" class="headerlink" title="RACChannelTerminal"></a>RACChannelTerminal</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACChannelTerminal</span>&lt;<span class="title">ValueType</span>&gt; : <span class="title">RACSignal</span>&lt;<span class="title">ValueType</span>&gt; &lt;<span class="title">RACSubscriber</span>&gt;</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init __attribute__((unavailable(<span class="string">"Instantiate a RACChannel instead"</span>)));</span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">nullable</span> ValueType)value;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// The values for this terminal.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;ValueType&gt; *values;</span><br><span class="line"><span class="comment">/// A subscriber will will send values to the other terminal.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;RACSubscriber&gt; otherTerminal;</span><br></pre></td></tr></table></figure>
<p>RACChannelTerminal 既可以发送信号，也可以订阅信号</p>
<ul>
<li>初始化<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithValues:(RACSignal *)values otherTerminal:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)otherTerminal &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(values != <span class="literal">nil</span>);</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(otherTerminal != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">	_values = values;</span><br><span class="line">	_otherTerminal = otherTerminal;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中 values、otherTerminal 分别表示 RACChannelTerminal 的两个端点。在订阅者调用 -subscribeNext: 等方法发起订阅时，实际上订阅的是self.values 信号；如果向当前端点发送消息，会使用 self.otherTerminal 来发送消息，不是使用 self.values 的订阅者来发送消息</p>
<ul>
<li>RACSignal<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span>.values subscribe:subscriber]; <span class="comment">//实际被订阅的是values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>执行<code>RACReplaySubject</code>对象的<code>subscribe</code>方法,向订阅者发送values</p>
<ul>
<li>遵循<code>RACSubscriber</code> 协议<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">	[<span class="keyword">self</span>.otherTerminal sendNext:value]; <span class="comment">//实际调用self.otherTerminal 发送消息</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="RACChannel-初始化"><a href="#RACChannel-初始化" class="headerlink" title="RACChannel 初始化"></a>RACChannel 初始化</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We don't want any starting value from the leadingSubject, but we do want</span></span><br><span class="line">	<span class="comment">// error and completion to be replayed.</span></span><br><span class="line">	RACReplaySubject *leadingSubject = [[RACReplaySubject replaySubjectWithCapacity:<span class="number">0</span>] setNameWithFormat:<span class="string">@"leadingSubject"</span>];</span><br><span class="line">	RACReplaySubject *followingSubject = [[RACReplaySubject replaySubjectWithCapacity:<span class="number">1</span>] setNameWithFormat:<span class="string">@"followingSubject"</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Propagate errors and completion to everything.</span></span><br><span class="line">	[[leadingSubject ignoreValues] subscribe:followingSubject];</span><br><span class="line">	[[followingSubject ignoreValues] subscribe:leadingSubject];</span><br><span class="line"></span><br><span class="line">	_leadingTerminal = [[[RACChannelTerminal alloc] initWithValues:leadingSubject otherTerminal:followingSubject] setNameWithFormat:<span class="string">@"leadingTerminal"</span>];</span><br><span class="line">	_followingTerminal = [[[RACChannelTerminal alloc] initWithValues:followingSubject otherTerminal:leadingSubject] setNameWithFormat:<span class="string">@"followingTerminal"</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>RACReplaySubject 将之前发送的值都进行保存，订阅的时候会向当前的订阅者遍历调用之前接收到的values<br>根据传入的参数capacity，<br><code>leadingSubject</code>的capacity为0, 不需要订阅的时候就执行消息发送<br><code>followingSubject</code>的capacity为1,需要在订阅的时候执行最新一次接收的值，供外部订阅需要初始值</p>
</li>
<li><p>leadingSubject 和 followingSubject 相互订阅<br>默认都接收Completed和Error信号，防止任一信号结束另一个还在执行的问题</p>
</li>
</ul>
<h3 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h3><p>RACChannel 采用了双向绑定的思想，在使用过程中，一般通过它的子类 RACKVOChannel 实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACChannelTo(<span class="keyword">self</span>,nameA) = RACChannelTo(<span class="keyword">self</span>,nameB);</span><br><span class="line"><span class="keyword">self</span>.nameA = <span class="string">@"John"</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"nameA:%@-nameB:%@"</span>,<span class="keyword">self</span>.nameA,<span class="keyword">self</span>.nameB);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>源码<br><code>RACChannelTo</code>是宏，<code>RACChannelTo(self,nameA)</code>展开</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RACKVOChannel alloc] initWithTarget:<span class="keyword">self</span> keyPath:<span class="string">@"nameA"</span> nilValue:<span class="literal">nil</span>][<span class="string">@"followingTerminal"</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用<br>为nameA和nameB 分别创建了channelA和channelB<br>调用channelA[@”followingTerminal”] = channelB[@”followingTerminal”]</p>
</li>
</ul>
<p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameA:John-nameB:John</span><br></pre></td></tr></table></figure></p>
<ul>
<li>实现原理<br>覆写下面两个方法，实现双向绑定<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RACKVOChannel</span> (<span class="title">RACChannelTo</span>)</span></span><br><span class="line"></span><br><span class="line">- (RACChannelTerminal *)objectForKeyedSubscript:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(key != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">	RACChannelTerminal *terminal = [<span class="keyword">self</span> valueForKey:key];</span><br><span class="line">	<span class="built_in">NSCAssert</span>([terminal isKindOfClass:RACChannelTerminal.class], <span class="string">@"Key \"%@\" does not identify a channel terminal"</span>, key);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> terminal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(RACChannelTerminal *)otherTerminal forKeyedSubscript:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(otherTerminal != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">	RACChannelTerminal *selfTerminal = [<span class="keyword">self</span> objectForKeyedSubscript:key];</span><br><span class="line">	[otherTerminal subscribe:selfTerminal];</span><br><span class="line">	[[selfTerminal skip:<span class="number">1</span>] subscribe:otherTerminal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>内部实际是对 <code>followingTerminal</code>相互订阅,在反向绑定的时候就可以skip:1来节约性能</p>
<h2 id="RACChannel-扩展"><a href="#RACChannel-扩展" class="headerlink" title="RACChannel 扩展"></a>RACChannel 扩展</h2><p>这些函数都会返回一个对应的RACChannelTerminal,可以定制使用结合</p>
<ul>
<li>[NSUserDefaults rac_channelTerminalForKey:]</li>
<li>[UIDatePicker rac_newDateChannelWithNilValue:]</li>
<li>[UISegmentedControl rac_newSelectedSegmentIndexChannelWithNilValue:]</li>
<li>[UISlider rac_newValueChannelWithNilValue:]</li>
<li>[UITextField rac_newTextChannel:]</li>
</ul>
<h2 id="RAC相关的宏"><a href="#RAC相关的宏" class="headerlink" title="RAC相关的宏"></a>RAC相关的宏</h2><ul>
<li><code>RAC(TARGET, [KEYPATH, [NIL_VALUE]])</code></li>
</ul>
<p>EXAMPLES:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RAC(<span class="keyword">self</span>, objectProperty) = objectSignal;</span><br><span class="line">RAC(<span class="keyword">self</span>, stringProperty, <span class="string">@"foobar"</span>) = stringSignal;</span><br><span class="line">RAC(<span class="keyword">self</span>, integerProperty, @<span class="number">42</span>) = integerSignal;</span><br></pre></td></tr></table></figure></p>
<p>RAC()总是出现在等号左边，等号右边是一个RACSignal，表示的意义是将一个对象的一个属性和一个signal绑定，signal每产生一个value（id类型），都会自动执行：<code>[TARGET setValue:value ?: NIL_VALUE forKeyPath:KEYPATH];</code></p>
<ul>
<li><code>RACObserve(TARGET, KEYPATH)</code> :观察TARGET的KEYPATH属性，相当于KVO，产生一个RACSignal<br>EXAMPLES:<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *selfSignal = RACObserve(<span class="keyword">self</span>, arrayController.items);</span><br><span class="line"></span><br><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">   RACSignal *signal3 = [anotherSignal flattenMap:^(<span class="built_in">NSArrayController</span> *arrayController) &#123;</span><br><span class="line">       <span class="comment">// Avoids a retain cycle because of RACObserve implicitly referencing self.</span></span><br><span class="line">       @strongify(<span class="keyword">self</span>);</span><br><span class="line">       <span class="keyword">return</span> RACObserve(arrayController, items);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="noopener">http://blog.sunnyxx.com/2014/03/06/rac_1_macros/</a></p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/03/26/ReactiveObjc-RACCommand/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/26/ReactiveObjc-RACCommand/" itemprop="url">ReactiveObjc-RACCommand</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T10:57:28+08:00">
                2018-03-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文源码为 ReactiveObjc 3.1.0 版本</p>
<p>在ReactiveObjc 世界中，不仅仅存在RACSignal这样的信号，还存在一些绑定关系的操作集合，比如按钮的点击事件，按钮点击的时候，事物操作事先就定义好了，RACCommand 可以应用于此</p>
<h2 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACCommand</span>&lt;<span class="title">__contravariant</span> <span class="title">InputType</span>, <span class="title">__covariant</span> <span class="title">ValueType</span>&gt; : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;RACSignal&lt;ValueType&gt; *&gt; *executionSignals;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;<span class="built_in">NSNumber</span> *&gt; *executing;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;<span class="built_in">NSNumber</span> *&gt; *enabled;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;<span class="built_in">NSError</span> *&gt; *errors;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSignalBlock:(RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input))signalBlock;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEnabled:(<span class="keyword">nullable</span> RACSignal&lt;<span class="built_in">NSNumber</span> *&gt; *)enabledSignal signalBlock:(RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input))signalBlock;</span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)execute:(<span class="keyword">nullable</span> InputType)input;</span><br></pre></td></tr></table></figure>
<p>RACCommand 继承自NSObject，是一个对象，但是可以用于创建和订阅信号</p>
<p>对外声明包含四个属性</p>
<ul>
<li><p>executionSignals<br>属于高阶信号，需要进行降级操作,通常使用 flatten，switchToLatest，concat<br>如果在允许Concurrent并发的RACCommand中一般使用flatten。<br>在不允许Concurrent并发的RACCommand中一般使用switchToLatest</p>
</li>
<li><p>executing:当前RACCommand是否在执行</p>
</li>
<li><p>enabled:RACCommand是否可用</p>
</li>
<li><p>errors:RACCommand执行过程中产生的错误信号</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACCommand</span> () </span>&#123;</span><br><span class="line">	<span class="comment">// Atomic backing variable for `allowsConcurrentExecution`.</span></span><br><span class="line">	<span class="keyword">volatile</span> uint32_t _allowsConcurrentExecution;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A subject that sends added execution signals.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSubject *addedExecutionSignalsSubject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A subject that sends the new value of `allowsConcurrentExecution` whenever it changes.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSubject *allowsConcurrentExecutionSubject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `enabled`, but without a hop to the main thread.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Values from this signal may arrive on any thread.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal *immediateEnabled;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The signal block that the receiver was initialized with.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSignal * (^signalBlock)(<span class="keyword">id</span> input);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>allowsConcurrentExecution :是否允许并发执行<br>定义类型是volatile</li>
</ul>
<p>在使用时 重写 get 和 set方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark Properties</span><br><span class="line"></span><br><span class="line">- (BOOL)allowsConcurrentExecution &#123;</span><br><span class="line">	return _allowsConcurrentExecution != 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setAllowsConcurrentExecution:(BOOL)allowed &#123;</span><br><span class="line">	if (allowed) &#123;</span><br><span class="line">		OSAtomicOr32Barrier(1, &amp;_allowsConcurrentExecution); //原子运算，保证只执行一次</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		OSAtomicAnd32Barrier(0, &amp;_allowsConcurrentExecution);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[self.allowsConcurrentExecutionSubject sendNext:@(_allowsConcurrentExecution)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RACCommand 对外暴露两个初始化方法和一个execute方法</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithSignalBlock:(RACSignal * (^)(id input))signalBlock &#123;</span><br><span class="line">    return [self initWithEnabled:nil signalBlock:signalBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部调用 initWithEnabled:signalBlock 方法，对 executionSignals，executing，enabled，errors的初始化<br>初始化方法比较复杂，内部创建了7个高阶信号，如果先简略信号的创建，实现如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithEnabled:(RACSignal *)enabledSignal signalBlock:(RACSignal&lt;<span class="keyword">id</span>&gt; * (^)(<span class="keyword">id</span> input))signalBlock &#123;</span><br><span class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">	_addedExecutionSignalsSubject = [RACSubject new];</span><br><span class="line">	_signalBlock = [signalBlock <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">	_executionSignals = ...;</span><br><span class="line">	_errors = ...;</span><br><span class="line">	RACSignal *immediateExecuting = ...;</span><br><span class="line">	_executing = ...;</span><br><span class="line">	RACSignal *moreExecutionsAllowed = ...;</span><br><span class="line">	_immediateEnabled =...;</span><br><span class="line">	_enabled = ...;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>immediateExecuting 表示当前是否有任务在执行<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *immediateExecuting = [[[[<span class="keyword">self</span>.addedExecutionSignalsSubject</span><br><span class="line">		flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line">			<span class="keyword">return</span> [[[signal</span><br><span class="line">				catchTo:[RACSignal empty]]</span><br><span class="line">				then:^&#123;</span><br><span class="line">					<span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:@<span class="number">-1</span>];</span><br><span class="line">				&#125;]</span><br><span class="line">				startWith:@<span class="number">1</span>];</span><br><span class="line">		&#125;]</span><br><span class="line">		scanWithStart:@<span class="number">0</span> reduce:^(<span class="built_in">NSNumber</span> *running, <span class="built_in">NSNumber</span> *next) &#123;</span><br><span class="line">			<span class="keyword">return</span> @(running.integerValue + next.integerValue);</span><br><span class="line">		&#125;]</span><br><span class="line">		map:^(<span class="built_in">NSNumber</span> *count) &#123;</span><br><span class="line">			<span class="keyword">return</span> @(count.integerValue &gt; <span class="number">0</span>);</span><br><span class="line">		&#125;]</span><br><span class="line">		startWith:@NO];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>1.flattenMap 将每一个信号的开始和结束的时间点转换成 1 和 -1 两个信号<br>    catchTo: 将捕获到的错误信号都返回 RACEmptySignal空信号,当信号发送完毕，执行then方法的block生成RACReturnSignal信号,发送-1.<br>    startWith 先发送1，然后执行原信号<br>2.scanWithStart 初始化值为0，累加原信号发出的所有的值<br>3.map 将大于0的信号转为 YES<br>4.startWith 在信号序列最前面加入 @NO，表示在最开始时，没有任何动作在执行。</p>
<p><a href="https://pattyxp.github.io/2018/03/24/ReactiveObjc-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C/">具体方法的实现分析查看</a></p>
<p>整个流程如下<a href="https://github.com/Draveness/analyze/blob/43d828b6f516a57e12eeff69913ff49cc94a0f36/contents/ReactiveObjC/RACCommand.md" target="_blank" rel="noopener">图片来源</a><br><img src="/images/ImmediateExecutingSignal.png" alt="ImmediateExecutingSignal"></p>
<ul>
<li>moreExecutionsAllowed 判断是否允许并发执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *moreExecutionsAllowed = [RACSignal</span><br><span class="line">		if:[self.allowsConcurrentExecutionSubject startWith:@NO]</span><br><span class="line">		then:[RACSignal return:@YES]</span><br><span class="line">		else:[immediateExecuting not]];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果允许并发执行，那么执行then操作，否则执行else操作<br>else操作是对 immediateExecuting 取反</p>
<ul>
<li>executionSignals<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_executionSignals = [[[self.addedExecutionSignalsSubject</span><br><span class="line">  map:^(RACSignal *signal) &#123;</span><br><span class="line">    return [signal catchTo:[RACSignal empty]];</span><br><span class="line">  &#125;]</span><br><span class="line">  deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">  setNameWithFormat:@&quot;%@ -executionSignals&quot;, self];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>map 函数操作是对信号进行变换,当接收到错误信号会返回空信号<br>executionSignals 将返回的信号都派发到在主线程中。</p>
<p>catchTo方法<a href="https://pattyxp.github.io/2018/03/24/ReactiveObjc-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C/">此文有介绍</a></p>
<ul>
<li>executing信号 :判断是否正在执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_executing = [[[[[immediateExecuting</span><br><span class="line">	deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">	// This is useful before the first value arrives on the main thread.</span><br><span class="line">	startWith:@NO]</span><br><span class="line">	distinctUntilChanged]</span><br><span class="line">	replayLast]</span><br><span class="line">	setNameWithFormat:@&quot;%@ -executing&quot;, self];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>信号在主线程执行，<br>内部调用distinctUntilChanged,初始值为NO，当值变化的时候，通过 replayLast方法 生成 <code>[RACReplaySubject replaySubjectWithCapacity:1]</code>保存最新值的信号，不关心过去的值<br>返回热信号 RACMulticastConnection</p>
<ul>
<li>enabled : 判断RACCommand对象是否能够执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_immediateEnabled = [[[[RACSignal</span><br><span class="line">	combineLatest:@[ enabledSignal, moreExecutionsAllowed ]]</span><br><span class="line">	and]</span><br><span class="line">	takeUntil:self.rac_willDeallocSignal]</span><br><span class="line">	replayLast];</span><br><span class="line"></span><br><span class="line">_enabled = [[[[[self.immediateEnabled</span><br><span class="line">		take:1]</span><br><span class="line">		concat:[[self.immediateEnabled skip:1] deliverOn:RACScheduler.mainThreadScheduler]]</span><br><span class="line">		distinctUntilChanged]</span><br><span class="line">		replayLast]</span><br><span class="line">		setNameWithFormat:@&quot;%@ -enabled&quot;, self];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>依赖于私有信号immediateEnabled<br>这里涉及到了combineLatest:的变换操作，<a href="https://pattyxp.github.io/2018/03/24/ReactiveObjc-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C/">这个操作在这里有介绍</a>。combineLatest:的作用就是把后面数组里面传入的每个信号，不管是谁发送出来一个信号，都会把数组里面所有信号的最新的值组合到一个RACTuple里面。immediateEnabled会把每个RACTuple里面的元素都进行逻辑and运算，这样immediateEnabled信号里面装的也都是BOOL值了。<br>当前 RACCommand 执行 dealloc 之后就不会执行<code>self.rac_willDeallocSignal</code>信号</p>
<p>_enabled 与 enabledSignal、moreExecutionsAllowed、rac_willDeallocSignal 都有关系</p>
<p>immediateEnabled 在每次原信号发送消息时都会重新计算<br>_enabled 有点差别,调用了<code>-distinctUntilChanged</code>方法，所以如果连续几次值相同就不会再次发送任何消息。<br>调用skip:方法，第一个值以后的每个值都发送在主线程上<br>-take:1和 -concat: 第一个值在一订阅的时候就发送出去了，同订阅者所在线程一致。</p>
<ul>
<li>errors 信号初始化<br>RACCommand 能将error信号进行收集统一处理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACMulticastConnection *errorsConnection = [[[self.addedExecutionSignalsSubject</span><br><span class="line">  flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line">    return [[signal</span><br><span class="line">      ignoreValues]</span><br><span class="line">      catch:^(NSError *error) &#123;</span><br><span class="line">        return [RACSignal return:error];</span><br><span class="line">      &#125;];</span><br><span class="line">  &#125;]</span><br><span class="line">  deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">  publish];</span><br><span class="line"></span><br><span class="line">_errors = [errorsConnection.signal setNameWithFormat:@&quot;%@ -errors&quot;, self];</span><br><span class="line">[errorsConnection connect];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>内部调用 ignoreValues/catch 方法 进行信号转换<br>将addedExecutionSignalsSubject 内原信号的错误信息都返回 RACReturnSignal对象</p>
<ul>
<li>execute 执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)execute:(id)input &#123;</span><br><span class="line"></span><br><span class="line">	//判断能够执行任务</span><br><span class="line">	BOOL enabled = [[self.immediateEnabled first] boolValue];</span><br><span class="line">	if (!enabled) &#123;</span><br><span class="line"></span><br><span class="line">		NSError *error = [NSError errorWithDomain:RACCommandErrorDomain code:RACCommandErrorNotEnabled userInfo:@&#123;</span><br><span class="line">			NSLocalizedDescriptionKey: NSLocalizedString(@&quot;The command is disabled and cannot be executed&quot;, nil),</span><br><span class="line">			RACUnderlyingCommandErrorKey: self</span><br><span class="line">		&#125;];</span><br><span class="line">		//如果不能执行，直接返回 Error信号</span><br><span class="line">		return [RACSignal error:error];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//根据初始化时候的signalBlock产生信号</span><br><span class="line">	RACSignal *signal = self.signalBlock(input);</span><br><span class="line">	NSCAssert(signal != nil, @&quot;nil signal returned from signal block for value: %@&quot;, input);</span><br><span class="line"></span><br><span class="line">	//将冷信号转为热信号</span><br><span class="line">	RACMulticastConnection *connection = [[signal</span><br><span class="line">		subscribeOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">		multicast:[RACReplaySubject subject]];</span><br><span class="line"></span><br><span class="line">	//只有在此处对 addedExecutionSignalsSubject对象进行操作 ，生产信息</span><br><span class="line">	[self.addedExecutionSignalsSubject sendNext:connection.signal];</span><br><span class="line"></span><br><span class="line">	// 将 RACSignal 和 RACReplaySubject 进行连接</span><br><span class="line">	[connection connect];</span><br><span class="line">	return [connection.signal setNameWithFormat:@&quot;%@ -execute: %@&quot;, self, RACDescription(input)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 signalBlock 返回一个 RACSignal 之后，会将当前信号包装成一个 RACMulticastConnection，然后调用 -sendNext: 方法发送到 addedExecutionSignalsSubject 上，执行 -connect 方法订阅原有的信号，最后返回。</p>
<ul>
<li>事例</li>
</ul>
<p>通常 RACCommand 特别适合网络请求或者 UI相关操作上，可以结合MVVM模式进行使用，<a href="https://github.com/Draveness/analyze/blob/43d828b6f516a57e12eeff69913ff49cc94a0f36/contents/ReactiveObjC/RACCommand.md" target="_blank" rel="noopener">来源</a><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(<span class="built_in">NSNumber</span> * _Nullable input) &#123;</span><br><span class="line">		<span class="comment">// block1</span></span><br><span class="line">		<span class="keyword">return</span> [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">				<span class="comment">// block2</span></span><br><span class="line">				<span class="built_in">NSInteger</span> integer = [input integerValue];</span><br><span class="line">				[subscriber sendNext:@(integerValue)];</span><br><span class="line">				[subscriber sendCompleted];</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">		&#125;];</span><br><span class="line">&#125;];</span><br><span class="line">[[command.executionSignals switchToLatest] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">		<span class="comment">//block3</span></span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@"value:%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[command execute:@<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p>
<p>订阅 executionSignals和错误信号 来获取请求结果<br>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value:1</span><br></pre></td></tr></table></figure></p>
<p>分析下流程</p>
<ol>
<li>先创建 RACCommand 对象，将入参进行copy<code>[signalBlock copy]</code><br>  初始化内部的信号</li>
<li>执行<code>[[command.executionSignals switchToLatest]</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)switchToLatest &#123;</span><br><span class="line">	// block4</span><br><span class="line">	return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">		// block5</span><br><span class="line">		RACMulticastConnection *connection = [self publish]; //产生热信号</span><br><span class="line"></span><br><span class="line">		RACDisposable *subscriptionDisposable = [[connection.signal</span><br><span class="line">			flattenMap:^(RACSignal *x) &#123;  //对原信号进行变换</span><br><span class="line"></span><br><span class="line">				NSCAssert(x == nil || [x isKindOfClass:RACSignal.class], @&quot;-switchToLatest requires that the source signal (%@) send signals. Instead we got: %@&quot;, self, x);</span><br><span class="line"></span><br><span class="line">				return [x takeUntil:[connection.signal concat:[RACSignal never]]];</span><br><span class="line">			&#125;]</span><br><span class="line">			subscribe:subscriber];</span><br><span class="line"></span><br><span class="line">		RACDisposable *connectionDisposable = [connection connect];</span><br><span class="line">		return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">			[subscriptionDisposable dispose];</span><br><span class="line">			[connectionDisposable dispose];</span><br><span class="line">		&#125;];</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -switchToLatest&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>此处执行 block4,产生新的信号，将block进行copy</li>
<li><p>对<code>[[command.executionSignals switchToLatest] subscribeNext]</code><br>  执行subscribeNext操作，此处将 switchToLatest产生的信号执行订阅操作，调用信号的 didSubscriber闭包, 此处执行 block5<br> 通过<code>flattenMap</code>对热信号的signal进行变换操作产生新的信号signal1</p>
<p> <code>[x takeUntil:[connection.signal concat:[RACSignal never]]];</code><br> 先执行<code>concat</code>方法产生新的信号signal2，<code>takeUntil</code>会一直订阅signal2，signal2如果没有收到新值会一直执行<code>sendNext</code>直到signal2有新值会取消订阅信号x，向订阅者发送<code>sendCompleted</code></p>
<p> 执行<code>[connection connect];</code><br>5.执行<code>execute</code>方法，<code>RACSignal *signal = self.signalBlock(input);</code>调用初始化command时候保存的闭包,此处执行 block1<br> 执行<code>[self.addedExecutionSignalsSubject sendNext:connection.signal];</code><br> 接着执行<code>[connection connect];</code></p>
</li>
<li>执行block2</li>
<li>执行block3</li>
</ol>
<ul>
<li>注意<br>1.如果此处在末尾添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[command execute:@2];</span><br><span class="line">[command execute:@3];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>那么只能收到第一个打印结果<code>value:1</code><br>因为RACCommand 默认是非并发执行的，需要等待命令执行结束才能执行下一次操作，所以在<code>execute</code>方法内部，每次都会判断是否可以执行任务，第二次执行的时候进入if条件语句，返回 Error信号，不打印内容</p>
<p>2.如果此处在末尾添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[RACScheduler.mainThreadScheduler afterDelay:0.1</span><br><span class="line">                                    schedule:^&#123;</span><br><span class="line">                                        [command execute:@2];</span><br><span class="line">                                    &#125;];</span><br><span class="line">[RACScheduler.mainThreadScheduler afterDelay:0.2</span><br><span class="line">                                    schedule:^&#123;</span><br><span class="line">                                        [command execute:@3];</span><br><span class="line">                                    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>可以收到打印结果<br>每次执行execute方法， executionSignals 中发送了新的信号时，switchToLatest 方法返回的信号都会订阅这个最新的信号，这里也就保证了每次都会打印出最新的信号中的值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RACCommand 将外部的变量 InputType 转换成了使用 RACSignal 包裹的 ValueType 对象。<br>从 -execute: 方法中获得输入InputType，最后以向信号发送消息的方式，向订阅者推送结果。</p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/03/24/ReactiveObjc-常用的变换操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/24/ReactiveObjc-常用的变换操作/" itemprop="url">ReactiveObjc 常用的变换操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T16:47:45+08:00">
                2018-03-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文源码为 ReactiveObjc 3.1.0 版本</p>
<p>除了入门篇介绍的一些常用方法，本篇来介绍下过滤和组合相关的方法底层实现</p>
<ul>
<li>filter</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)filter:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^ <span class="keyword">id</span> (<span class="keyword">id</span> value) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (block(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -filter:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部调用flattenMap方法，在上篇已经介绍过了，此处略过。<br>如果满足筛选条件的即返回原信号的值，否则原信号的值被“吞”掉，返回空的信号 RACEmptySignal</p>
<ul>
<li>ignoreValues<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)ignoreValues &#123;</span><br><span class="line">    return [[self filter:^(id _) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -ignoreValues&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>ignoreValues 方法是对 filter 方法的封装，原信号的值都会被变换成empty空信号</p>
<ul>
<li>ignore:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)ignore:(id)value &#123;</span><br><span class="line">    return [[self filter:^ BOOL (id innerValue) &#123;</span><br><span class="line">        return innerValue != value &amp;&amp; ![innerValue isEqual:value];</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -ignore: %@&quot;, self.name, [value rac_description]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对入参的value进行判断，当原信号和value不同的时候 返回原信号</p>
<ul>
<li>distinctUntilChanged<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)distinctUntilChanged &#123;</span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">        __block <span class="keyword">id</span> lastValue = <span class="literal">nil</span>;</span><br><span class="line">        __block <span class="built_in">BOOL</span> initial = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ^(<span class="keyword">id</span> x, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!initial &amp;&amp; (lastValue == x || [x isEqual:lastValue])) <span class="keyword">return</span> [<span class="keyword">class</span> empty];</span><br><span class="line"></span><br><span class="line">            initial = <span class="literal">NO</span>;</span><br><span class="line">            lastValue = x;</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:x];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -distinctUntilChanged"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>每次变换中都记录一下原信号上一次发送过来的值，并与这一次进行比较，如果是相同的值，返回empty信号。只有和原信号上一次发送的值不同，变换后的新信号才把这个值发送出来。</p>
<ul>
<li>take<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)take:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">	Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">		__block <span class="built_in">NSUInteger</span> taken = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ^ <span class="keyword">id</span> (<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">			<span class="keyword">if</span> (taken &lt; count) &#123;</span><br><span class="line">				++taken;</span><br><span class="line">				<span class="keyword">if</span> (taken == count) *stop = <span class="literal">YES</span>;</span><br><span class="line">				<span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@"[%@] -take: %lu"</span>, <span class="keyword">self</span>.name, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>take:实现也非常简单，借助bind函数来实现的。<br>入参的count是原信号取值的个数,在bind的闭包中,taken计数从0开始取原信号的值,当taken取到count个数的时候，就停止取值。</p>
<ul>
<li>takeLast<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)takeLast:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">	<span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">		<span class="built_in">NSMutableArray</span> *valuesTaken = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:count];</span><br><span class="line">		<span class="keyword">return</span> [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">			[valuesTaken addObject:x ? : RACTupleNil.tupleNil];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (valuesTaken.count &gt; count) &#123;</span><br><span class="line">				[valuesTaken removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">			[subscriber sendError:error];</span><br><span class="line">		&#125; completed:^&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">id</span> value <span class="keyword">in</span> valuesTaken) &#123;</span><br><span class="line">				[subscriber sendNext:value == RACTupleNil.tupleNil ? <span class="literal">nil</span> : value];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			[subscriber sendCompleted];</span><br><span class="line">		&#125;];</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@"[%@] -takeLast: %lu"</span>, <span class="keyword">self</span>.name, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>和take相反，先将接受到的值都存储在可变数组valuesTaken上，当数组的数量超过入参count的值，就将之前的数据进行移除<br>订阅完成之后，通过for循环一次次的发送值<br>注:<br>1.如果值是空的RACTupleNil.tupleNil，就发送nil<br>2.如果原信号一直没有completed，那么takeLast:就一直没法发出任何信号来。</p>
<ul>
<li>takeUntilBlock<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)takeUntilBlock:(BOOL (^)(id x))predicate &#123;</span><br><span class="line">	NSCParameterAssert(predicate != nil);</span><br><span class="line"></span><br><span class="line">	Class class = self.class;</span><br><span class="line"></span><br><span class="line">	return [[self bind:^&#123;</span><br><span class="line">		return ^ id (id value, BOOL *stop) &#123;</span><br><span class="line">			if (predicate(value)) return nil;</span><br><span class="line"></span><br><span class="line">			return [class return:value];</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -takeUntilBlock:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>内部也是借助bind方法实现，根据传入的predicate闭包作为筛选条件，如果predicate( )闭包满足条件，那么新信号置为nil,停止发送新信号.</p>
<ul>
<li>takeWhileBlock<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)takeWhileBlock:(BOOL (^)(id x))predicate &#123;</span><br><span class="line">	NSCParameterAssert(predicate != nil);</span><br><span class="line"></span><br><span class="line">	return [[self takeUntilBlock:^ BOOL (id x) &#123;</span><br><span class="line">		return !predicate(x);</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -takeWhileBlock:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>内部调用takeUntilBlock，只是判断条件和之相反<br>如果满足条件，返回 非空的值，<br>如果不满足条件 返回 nil，停止发送新信号</p>
<ul>
<li>takeUntil<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)takeUntil:(RACSignal *)signalTrigger &#123;</span><br><span class="line">	return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">		RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">		void (^triggerCompletion)(void) = ^&#123;</span><br><span class="line">			[disposable dispose];</span><br><span class="line">			[subscriber sendCompleted];</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		RACDisposable *triggerDisposable = [signalTrigger subscribeNext:^(id _) &#123;</span><br><span class="line">			triggerCompletion();</span><br><span class="line">		&#125; completed:^&#123;</span><br><span class="line">			triggerCompletion();</span><br><span class="line">		&#125;];</span><br><span class="line"></span><br><span class="line">		[disposable addDisposable:triggerDisposable];</span><br><span class="line"></span><br><span class="line">		if (!disposable.disposed) &#123;</span><br><span class="line">			RACDisposable *selfDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line">				[subscriber sendNext:x];</span><br><span class="line">			&#125; error:^(NSError *error) &#123;</span><br><span class="line">				[subscriber sendError:error];</span><br><span class="line">			&#125; completed:^&#123;</span><br><span class="line">				[disposable dispose];</span><br><span class="line">				[subscriber sendCompleted];</span><br><span class="line">			&#125;];</span><br><span class="line"></span><br><span class="line">			[disposable addDisposable:selfDisposable];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return disposable;</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -takeUntil: %@&quot;, self.name, signalTrigger];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>产生一个新信号，在新信号中 订阅原信号，只要原信号没有销毁就会一直执行 <code>sendNext</code> ,<br>当入参signalTrigger调用sendNext,那么就会触发triggerCompletion<br>取消原信号，向新产生的信号发送sendCompleted</p>
<ul>
<li>skip<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)skip:(NSUInteger)skipCount &#123;</span><br><span class="line">	Class class = self.class;</span><br><span class="line"></span><br><span class="line">	return [[self bind:^&#123;</span><br><span class="line">		__block NSUInteger skipped = 0;</span><br><span class="line"></span><br><span class="line">		return ^(id value, BOOL *stop) &#123;</span><br><span class="line">			if (skipped &gt;= skipCount) return [class return:value];</span><br><span class="line"></span><br><span class="line">			skipped++;</span><br><span class="line">			return class.empty;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -skip: %lu&quot;, self.name, (unsigned long)skipCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>借助bind方法，判断执行的次数，如果满足skipCount次数，则发送原信号，否则发送空信号</p>
<p>skip方法和take方法是补全关系，take是取前几次，skip是跳过前面几次</p>
<ul>
<li>skipUntilBlock</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)skipUntilBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(predicate != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">	Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">		__block <span class="built_in">BOOL</span> skipping = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ^ <span class="keyword">id</span> (<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">			<span class="keyword">if</span> (skipping) &#123;</span><br><span class="line">				<span class="keyword">if</span> (predicate(value)) &#123;</span><br><span class="line">					skipping = <span class="literal">NO</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@"[%@] -skipUntilBlock:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>skipUntilBlock 和 takeUntilBlock 实现类似<br>以入参 predicate()闭包判断，如果满足条件，skipping = NO,原信号发送的每个值都原封不动的发送出去。<br>不满足条件的时候，即会一直skip原信号的值</p>
<ul>
<li>skipWhileBlock<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)skipWhileBlock:(BOOL (^)(id x))predicate &#123;</span><br><span class="line">	NSCParameterAssert(predicate != nil);</span><br><span class="line"></span><br><span class="line">	return [[self skipUntilBlock:^ BOOL (id x) &#123;</span><br><span class="line">		return !predicate(x);</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -skipWhileBlock:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>skipWhileBlock 方法底层调用skipUntilBlock ,只是判断条件是 不满足predicate()闭包</p>
<ul>
<li>catch<br>高阶操作，是因为这里原信号发生错误之后，错误会升阶成一个信号。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)catch:(RACSignal * (^)(NSError *error))catchBlock &#123;</span><br><span class="line">	NSCParameterAssert(catchBlock != NULL);</span><br><span class="line"></span><br><span class="line">	return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">		RACSerialDisposable *catchDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line"></span><br><span class="line">		RACDisposable *subscriptionDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line">			[subscriber sendNext:x];</span><br><span class="line">		&#125; error:^(NSError *error) &#123;</span><br><span class="line">			RACSignal *signal = catchBlock(error);</span><br><span class="line">			NSCAssert(signal != nil, @&quot;Expected non-nil signal from catch block on %@&quot;, self);</span><br><span class="line">			catchDisposable.disposable = [signal subscribe:subscriber];</span><br><span class="line">		&#125; completed:^&#123;</span><br><span class="line">			[subscriber sendCompleted];</span><br><span class="line">		&#125;];</span><br><span class="line"></span><br><span class="line">		return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">			[catchDisposable dispose];</span><br><span class="line">			[subscriptionDisposable dispose];</span><br><span class="line">		&#125;];</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -catch:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当对原信号进行订阅的时候，如果出现错误，会去执行catchBlock()闭包，入参为刚刚产生的error。catchBlock( )闭包产生的是一个新的RACSignal，并再次用之前的订阅者订阅该信号。</p>
<ul>
<li>catchTo<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)catchTo:(RACSignal *)signal &#123;</span><br><span class="line">    return [[self catch:^(NSError *error) &#123;</span><br><span class="line">        return signal;</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -catchTo: %@&quot;, self.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>底层调用catch方法,实际是对catch方法的封装,如果订阅发生错误，都返回入参signal</p>
<ul>
<li>then<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)then:(RACSignal * (^)(void))block &#123;</span><br><span class="line">    NSCParameterAssert(block != nil);</span><br><span class="line"></span><br><span class="line">    return [[[self</span><br><span class="line">        ignoreValues]</span><br><span class="line">        concat:[RACSignal defer:block]]</span><br><span class="line">        setNameWithFormat:@&quot;[%@] -then:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将操作进行延迟到 原信号发送完毕之后，再执行block闭包</p>
<ul>
<li>defer<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)defer:(RACSignal * (^)(void))block &#123;</span><br><span class="line">    NSCParameterAssert(block != NULL);</span><br><span class="line"></span><br><span class="line">    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        return [block() subscribe:subscriber];</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;+defer:&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当defer返回的新信号被订阅的时候，才会执行入参block( )闭包，block产生信号，订阅者订阅block产生的信号</p>
<ul>
<li>startWith<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)startWith:(id)value &#123;</span><br><span class="line">	return [[[self.class return:value]</span><br><span class="line">		concat:self]</span><br><span class="line">		setNameWithFormat:@&quot;[%@] -startWith: %@&quot;, self.name, RACDescription(value)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>先通过return方法产生 RACReturnSignal,发送产生value，然后这个信号发送完毕之后接上原信号。得到的新的信号就是在原信号前面新加了一个值。</p>
<ul>
<li>scanWithStart:reduceWithIndex<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)scanWithStart:(<span class="keyword">id</span>)startingValue reduceWithIndex:(<span class="keyword">id</span> (^)(<span class="keyword">id</span>, <span class="keyword">id</span>, <span class="built_in">NSUInteger</span>))reduceBlock &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(reduceBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">        __block <span class="keyword">id</span> running = startingValue;</span><br><span class="line">        __block <span class="built_in">NSUInteger</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            running = reduceBlock(running, value, index++);</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:running];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -scanWithStart: %@ reduceWithIndex:"</span>, <span class="keyword">self</span>.name, [startingValue rac_description]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>内部调用bind方法<br>原信号的每个信号都会由变换函数reduceBlock( )进行变换<br>初始值是入参startingValue,然后index进行自增</p>
<p>事例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">                      &#123;</span><br><span class="line">                          [subscriber sendNext:@1];</span><br><span class="line">                          [subscriber sendNext:@2];</span><br><span class="line">                          [subscriber sendNext:@4];</span><br><span class="line">                          return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                          &#125;];</span><br><span class="line">                      &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalB = [signalA scanWithStart:@(2) reduceWithIndex:^id(NSNumber * running, NSNumber * next, NSUInteger index) &#123;</span><br><span class="line">    return @(running.intValue * next.intValue + index);</span><br><span class="line">&#125;];</span><br><span class="line">[signalB subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2    // 2 * 1 + 0 = 2</span><br><span class="line">5    // 2 * 2 + 1 = 5</span><br><span class="line">22  // 5 * 4 + 2 = 22</span><br></pre></td></tr></table></figure></p>
<ul>
<li>scanWithStart:reduce<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)scanWithStart:(<span class="keyword">id</span>)startingValue reduce:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> running, <span class="keyword">id</span> next))reduceBlock &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(reduceBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span></span><br><span class="line">		scanWithStart:startingValue</span><br><span class="line">		reduceWithIndex:^(<span class="keyword">id</span> running, <span class="keyword">id</span> next, <span class="built_in">NSUInteger</span> index) &#123;</span><br><span class="line">			<span class="keyword">return</span> reduceBlock(running, next);</span><br><span class="line">		&#125;]</span><br><span class="line">		setNameWithFormat:<span class="string">@"[%@] -scanWithStart: %@ reduce:"</span>, <span class="keyword">self</span>.name, RACDescription(startingValue)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>内部是对 <code>scanWithStart:reduceWithIndex</code> 方法的简化,返回的是入参 reduceBlock ，不进行自增</p>
<ul>
<li><p>combineLatestWith<br>从名字就可以看到，是将两个信号进行组合<br>当只接收到一个信号的时候，return<br>当收到两个信号的时候，将两者进行打包<code>RACTuplePack(lastSelfValue, lastOtherValue)</code>,然后发送给订阅者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)combineLatestWith:(RACSignal *)signal &#123;</span><br><span class="line">	NSCParameterAssert(signal != nil);</span><br><span class="line"></span><br><span class="line">	return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">		RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">		__block id lastSelfValue = nil;</span><br><span class="line">		__block BOOL selfCompleted = NO;</span><br><span class="line"></span><br><span class="line">		__block id lastOtherValue = nil;</span><br><span class="line">		__block BOOL otherCompleted = NO;</span><br><span class="line"></span><br><span class="line">		void (^sendNext)(void) = ^&#123;</span><br><span class="line">			@synchronized (disposable) &#123;</span><br><span class="line">				if (lastSelfValue == nil || lastOtherValue == nil) return;</span><br><span class="line">				[subscriber sendNext:RACTuplePack(lastSelfValue, lastOtherValue)];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		RACDisposable *selfDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line">			@synchronized (disposable) &#123;</span><br><span class="line">				lastSelfValue = x ?: RACTupleNil.tupleNil;</span><br><span class="line">				sendNext();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; error:^(NSError *error) &#123;</span><br><span class="line">			[subscriber sendError:error];</span><br><span class="line">		&#125; completed:^&#123;</span><br><span class="line">			@synchronized (disposable) &#123;</span><br><span class="line">				selfCompleted = YES;</span><br><span class="line">				if (otherCompleted) [subscriber sendCompleted];//只有两者都完成，才会发送完成信号</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;];</span><br><span class="line"></span><br><span class="line">		[disposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">		RACDisposable *otherDisposable = [signal subscribeNext:^(id x) &#123;</span><br><span class="line">			@synchronized (disposable) &#123;</span><br><span class="line">				lastOtherValue = x ?: RACTupleNil.tupleNil;</span><br><span class="line">				sendNext();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; error:^(NSError *error) &#123;</span><br><span class="line">			[subscriber sendError:error];</span><br><span class="line">		&#125; completed:^&#123;</span><br><span class="line">			@synchronized (disposable) &#123;</span><br><span class="line">				otherCompleted = YES;</span><br><span class="line">				if (selfCompleted) [subscriber sendCompleted]; //只有两者都完成，才会发送完成信号</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;];</span><br><span class="line"></span><br><span class="line">		[disposable addDisposable:otherDisposable];</span><br><span class="line"></span><br><span class="line">		return disposable;</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -combineLatestWith: %@&quot;, self.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>combineLatest</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)combineLatest:(id&lt;NSFastEnumeration&gt;)signals &#123;</span><br><span class="line">	return [[self join:signals block:^(RACSignal *left, RACSignal *right) &#123;</span><br><span class="line">		return [left combineLatestWith:right];</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;+combineLatest: %@&quot;, signals];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>combineLatest:的实现就是把入参数组里面的每个信号都调用一次join: block:方法。传入的闭包是把两个信号combineLatestWith:一下。combineLatest:的实现就是2个操作的组合。</p>
<ul>
<li>join:block<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ (__kindof RACStream *)join:(id&lt;NSFastEnumeration&gt;)streams block:(RACStream * (^)(id, id))block &#123;</span><br><span class="line">	RACStream *current = nil;</span><br><span class="line">  // 第一步</span><br><span class="line">	for (RACStream *stream in streams) &#123;</span><br><span class="line">		if (current == nil) &#123;</span><br><span class="line">			current = [stream map:^(id x) &#123;</span><br><span class="line">				return RACTuplePack(x);</span><br><span class="line">			&#125;];</span><br><span class="line"></span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		current = block(current, stream);</span><br><span class="line">	&#125;</span><br><span class="line">  // 第二步</span><br><span class="line">	if (current == nil) return [self empty];</span><br><span class="line"></span><br><span class="line">	return [current map:^(RACTuple *xs) &#123;</span><br><span class="line"></span><br><span class="line">		NSMutableArray *values = [[NSMutableArray alloc] init];</span><br><span class="line">    //第三步</span><br><span class="line">		while (xs != nil) &#123;</span><br><span class="line">			[values insertObject:xs.last ?: RACTupleNil.tupleNil atIndex:0];</span><br><span class="line">			xs = (xs.count &gt; 1 ? xs.first : nil);</span><br><span class="line">		&#125;</span><br><span class="line">    //第四步</span><br><span class="line">		return [RACTuple tupleWithObjectsFromArray:values];</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>此方法将当前信号流遍历<br>1.先依次打包信号流，首先将第一个信号打包成元组，然后将第一个元组和第二个信号传入block执行，依次类推，知道所有的信号都打包了<br>block操作返回信号，类似于zip，将两个信号进行压缩，只有两个信号都执行完毕才会将最新的值打包出去<br>2.如果current为空，返回空信号<br>3.这一步是把之前第一步打包出来的结果，还原回原信号的过程。经过第一步的循环之后，current会是类似这个样子，(((1), 2), 3)，第三步就是为了把这种多重元组解出来，每个信号流都依次按照顺序放在数组里。注意观察current的特点，最外层的元组，是一个值和一个元组，所以从最外层的元组开始，一层一层往里“剥”。while循环每次都取最外层元组的last，即那个单独的值，插入到数组的第0号位置，然后取出first即是里面一层的元组。然后依次循环。由于每次都插入到数组0号的位置，类似于链表的头插法，最终数组里面的顺序肯定也保证是原信号的顺序<br>4.把还原成原信号顺序 的数组 包装成元组，返回给map操作的闭包<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)tupleWithObjectsFromArray:(<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> tupleWithObjectsFromArray:array convertNullsToNils:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)tupleWithObjectsFromArray:(<span class="built_in">NSArray</span> *)array convertNullsToNils:(<span class="built_in">BOOL</span>)convert &#123;</span><br><span class="line">    RACTuple *tuple = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (convert) &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *newArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:array.count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> array) &#123;</span><br><span class="line">            [newArray addObject:(object == <span class="built_in">NSNull</span>.null ? RACTupleNil.tupleNil : object)];</span><br><span class="line">        &#125;</span><br><span class="line">        tuple.backingArray = newArray;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tuple.backingArray = [array <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tuple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>入参convert为NO，将array进行copy 返回元组</p>
<ul>
<li>switchToLatest</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)switchToLatest &#123;</span><br><span class="line">	<span class="comment">// block4</span></span><br><span class="line">	<span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">		<span class="comment">// block5</span></span><br><span class="line">		RACMulticastConnection *connection = [<span class="keyword">self</span> publish]; <span class="comment">//产生热信号</span></span><br><span class="line"></span><br><span class="line">		RACDisposable *subscriptionDisposable = [[connection.signal</span><br><span class="line">			flattenMap:^(RACSignal *x) &#123;  <span class="comment">//对原信号进行变换</span></span><br><span class="line"></span><br><span class="line">				<span class="built_in">NSCAssert</span>(x == <span class="literal">nil</span> || [x isKindOfClass:RACSignal.class], <span class="string">@"-switchToLatest requires that the source signal (%@) send signals. Instead we got: %@"</span>, <span class="keyword">self</span>, x);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> [x takeUntil:[connection.signal concat:[RACSignal never]]];</span><br><span class="line">			&#125;]</span><br><span class="line">			subscribe:subscriber];</span><br><span class="line"></span><br><span class="line">		RACDisposable *connectionDisposable = [connection connect];</span><br><span class="line">		<span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">			[subscriptionDisposable dispose];</span><br><span class="line">			[connectionDisposable dispose];</span><br><span class="line">		&#125;];</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@"[%@] -switchToLatest"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switchToLatest只能用在高阶信号,通过<code>[self publish];</code>产生热信号<br><code>connection.signal</code> 是 RACSubject 类型, 通过<code>flattenMap</code>方法对信号进行变换<br><code>connection.signal</code>会先<code>concat:</code>一个never信号,</p>
<p>flattenMap:变换中x是一个信号，对x进行takeUntil:变换，效果就是下一个信号到来之前，x会一直发送信号，一旦下一个信号到来，x就会被取消订阅，开始订阅新的信号。</p>
<ul>
<li>zipWith 和 concat</li>
<li>reduceEach / flattenMap / map /<br><a href="https://pattyxp.github.io/2018/03/12/ReactiveObjc%E5%85%A5%E9%97%A8/">请看这篇文章</a></li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.jianshu.com/p/707ece08257e" target="_blank" rel="noopener">https://www.jianshu.com/p/707ece08257e</a></p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pattyxp.github.io/2018/03/22/记录一次坑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patty">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/flower.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温暖的弦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/记录一次坑/" itemprop="url">记录一次坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T10:02:47+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="坑一"><a href="#坑一" class="headerlink" title="坑一"></a>坑一</h2><p>这真是一次莫名其妙的经历<br>场景如下:<br>有一个页面，底下有个按钮，之前都测试的OK,莫名其妙的突然之间不管点击什么地方，都会走按钮的逻辑，检查发现按钮的点击区域没有扩大，甚至点击返回按钮都被触动按钮点击事件，同样的页面，如果没有显示这个按钮一切逻辑倒是正常的，找同事看了下，笑话说如果真的是这样的效果，能做到也不容易啊</p>
<p>后面发现可能是我电脑缓存的问题，于是把相关的库和工程的缓存都给清理了下，世界清静了 ~ ~ ~</p>
<h2 id="坑二"><a href="#坑二" class="headerlink" title="坑二"></a>坑二</h2><p>更新Alfred (3.6.1), 原先好好的锁屏功能<code>lock</code> 无法识别了，每次都打开QQ的联系人列表，一直没搞明白，后来查到是因为QQ的联系人列表快捷键冲突的问题导致的（哎，当时怎么没往那方面去思考呢~），修改QQ的联系人快捷键，直接废弃好了，反正感觉不常用，终于可以快捷键锁屏了,速度比之前版本快多了  ~ ~ ~ </p>

          
        
      
    </div>
    
    
    

    


    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/flower.jpg"
               alt="Patty" />
          <p class="site-author-name" itemprop="name">Patty</p>
           
              <p class="site-description motion-element" itemprop="description">Life's like a movie, write your own ending, keep believing, keep pretending.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Patty</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_uv">
  本站总访问量<span id="busuanzi_value_site_uv"></span>次
</span>
<span class="post-count"> 博客全站共69.6k字</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
